1
00:00:05,759 --> 00:00:06,360
Hey 大家好

2
00:00:06,360 --> 00:00:09,699
我是Cherno，欢迎回到我的C++系列

3
00:00:09,779 --> 00:00:10,560
所以今天

4
00:00:10,560 --> 00:00:14,880
可能是整个系列中最重要的一集

5
00:00:14,880 --> 00:00:16,140
我们要来讲指针

6
00:00:16,140 --> 00:00:16,710
不幸的是

7
00:00:16,710 --> 00:00:19,620
很多人觉得指针很难

8
00:00:19,620 --> 00:00:21,120
所以我真的想说

9
00:00:21,120 --> 00:00:21,780
别担心

10
00:00:21,780 --> 00:00:23,129
别把它想的太复杂 

11
00:00:23,129 --> 00:00:25,320
指针其实很简单

12
00:00:25,320 --> 00:00:29,160
我还想说的是，今天我们要讲的是原始指针(raw pointer)而非智能指针(smart pointer)

13
00:00:29,160 --> 00:00:30,629
如果你不知道什么是smart pointer

14
00:00:30,629 --> 00:00:32,850
那就别管了，我们以后会讲到的

15
00:00:32,850 --> 00:00:34,109
计算机跟内存打交道

16
00:00:34,109 --> 00:00:36,570
内存是计算机的一切

17
00:00:36,570 --> 00:00:39,990
如果我必须说出编程中唯一最重要的东西

18
00:00:39,990 --> 00:00:41,460
它可能是内存(memory)

19
00:00:41,460 --> 00:00:43,590
当你编写一个应用程序并启动它时

20
00:00:43,590 --> 00:00:46,560
整个的程序被载入内存

21
00:00:46,560 --> 00:00:50,969
在你写的代码中，所有的指令告诉计算机要做什么

22
00:00:50,969 --> 00:00:52,829
所有这些都被加载到内存中

23
00:00:52,829 --> 00:00:58,125
这就是CPU如何访问你的程序并执行指令的

24
00:00:58,125 --> 00:00:59,534
当你创建一个变量时

25
00:00:59,549 --> 00:01:01,530
当你从硬盘中载入数据时

26
00:01:01,530 --> 00:01:03,659
所有东西都会被存储在内存中

27
00:01:03,659 --> 00:01:06,549
如果没有内存，你将什么也做不了

28
00:01:06,549 --> 00:01:11,656
而指针对管理和操纵那个内存极其重要 

29
00:01:11,670 --> 00:01:13,049
所以什么是指针？

30
00:01:13,049 --> 00:01:16,500
在这个视频中，我可能会多次重复

31
00:01:16,500 --> 00:01:18,090
指针是一个整数

32
00:01:18,090 --> 00:01:20,790
一个数字，它存储一个内存地址

33
00:01:20,790 --> 00:01:22,379
这就是它的全部

34
00:01:22,379 --> 00:01:25,500
我不想太深入讨论内存在计算机中是如何工作的

35
00:01:25,500 --> 00:01:27,480
我可能会另做一个视频讲它

36
00:01:27,480 --> 00:01:32,700
但将你电脑里的内存想象成一整块

37
00:01:32,730 --> 00:01:36,060
像很长的一条线，它就是这么回事而已

38
00:01:36,060 --> 00:01:42,540
想象一条街，如果你居住的整个城市都有一条街，有一个起点，有一个终点

39
00:01:42,540 --> 00:01:45,359
然后有很多房子，我们别去想马路对面的房子，对面没有！

40
00:01:45,359 --> 00:01:49,799
我们就假设有一条街，然后一整排房子

41
00:01:49,799 --> 00:01:51,840
这就是内存在电脑里的样子

42
00:01:51,840 --> 00:01:59,340
它只是一个线性的、一维的线，这条街上的每栋房子都有一个门牌号和地址

43
00:01:59,340 --> 00:02:01,590
所以把这个比喻放到电脑身上

44
00:02:01,590 --> 00:02:05,459
把那条街上每个带地址的房子想象成一个byte

45
00:02:05,459 --> 00:02:07,170
它是一个字节的数据

46
00:02:07,170 --> 00:02:09,810
我们显然需要一种方法来给所有bytes取址

47
00:02:09,810 --> 00:02:11,759
也就是我们街上所有的房子取址

48
00:02:11,759 --> 00:02:12,210
因为

49
00:02:12,210 --> 00:02:12,960
例如

50
00:02:12,960 --> 00:02:16,139
假设有人在网上订购了一些东西，并想要送货上门

51
00:02:16,139 --> 00:02:21,990
它需要被送到正确的房子里。或者是有人把东西从他们的房子里送出去

52
00:02:21,990 --> 00:02:22,889
不管怎样

53
00:02:22,889 --> 00:02:27,569
您需要能够从内存中，从那些bytes中、也就是那些房子中，读取和写入

54
00:02:27,569 --> 00:02:34,469
指针就是那个地址，告诉我们房子在哪——那个特定的字节的内存在哪

55
00:02:34,469 --> 00:02:35,759
这是非常重要的

56
00:02:35,759 --> 00:02:42,180
因为我们在代码中所做的每一件事，都是从内存中读取或者写入内存

57
00:02:42,180 --> 00:02:42,360
现在

58
00:02:42,360 --> 00:02:42,719
当然

59
00:02:42,719 --> 00:02:50,550
如果你用c++写程序完全不用指针也是完全可行的，没有说一定要用指针

60
00:02:50,550 --> 00:02:53,420
然而 但它们是非常有用的工具

61
00:02:53,430 --> 00:02:54,330
正如我刚才提到的

62
00:02:54,330 --> 00:02:57,419
内存可能是你所拥有的最重要的东西

63
00:02:57,419 --> 00:03:00,300
你的电脑所能提供的最重要的资源

64
00:03:00,300 --> 00:03:04,830
所有东西都依赖它，所以能够对这些内存有更多的控制至关重要

65
00:03:04,830 --> 00:03:05,069
好了

66
00:03:05,069 --> 00:03:05,580
不管怎样

67
00:03:07,479 --> 00:03:09,389
重申一下

68
00:03:09,389 --> 00:03:12,240
一个指针只是一个地址

69
00:03:12,240 --> 00:03:15,360
它是一个整数，存储着一个内存地址

70
00:03:15,360 --> 00:03:17,879
这就是它的全部，别管什么类型

71
00:03:17,879 --> 00:03:19,949
类型与这些没有任何关系

72
00:03:19,949 --> 00:03:24,060
类型只是我们虚构出来的，好让我们过的更轻松

73
00:03:24,060 --> 00:03:26,039
不管你是有个int指针

74
00:03:26,039 --> 00:03:28,800
还是你有个entity类，然后有个entity指针

75
00:03:28,800 --> 00:03:29,879
这无关紧要

76
00:03:29,880 --> 00:03:32,670
类型... 类型完全 没有意义

77
00:03:32,669 --> 00:03:33,210
好吗？

78
00:03:33,210 --> 00:03:38,879
所有类型的指针都是一个整数，存放一个内存地址

79
00:03:38,879 --> 00:03:40,139
这就是它的全部

80
00:03:40,139 --> 00:03:42,629
让我们看看一些例子

81
00:03:42,629 --> 00:03:42,870
好的

82
00:03:42,870 --> 00:03:43,800
在visualstudio中

83
00:03:43,800 --> 00:03:45,060
我有一个非常简单的项目

84
00:03:45,060 --> 00:03:46,650
它只有一个源文件

85
00:03:46,650 --> 00:03:50,490
你在屏幕上看到的所有东西就是我写的所有代码

86
00:03:50,490 --> 00:03:52,139
让我们来创建一个指针

87
00:03:52,139 --> 00:03:57,400
我们要创建最纯粹的指针，因为它是一个叫做void指针的东西

88
00:03:57,479 --> 00:03:59,819
void基本上指它是完全没有类型的

89
00:03:59,819 --> 00:04:00,509
记住

90
00:04:00,509 --> 00:04:00,840
记住

91
00:04:00,840 --> 00:04:03,449
我说过一个指针只是一个地址

92
00:04:03,449 --> 00:04:06,599
它只是一个在内存中存放地址的整数

93
00:04:06,599 --> 00:04:08,969
所以它不需要什么类型，如果我们给一个指针一个类型

94
00:04:08,969 --> 00:04:14,729
我们只是说，在那个地址的数据可能是我们给它的类型，对吧

95
00:04:14,729 --> 00:04:17,730
除了这一点 它没有任何意义

96
00:04:17,730 --> 00:04:21,899
只是我们可以写出来，让我们的生活，从语法上来说，更轻松

97
00:04:21,899 --> 00:04:25,800
在源码中让我们的生活更轻松，我们可以用指针类型

98
00:04:25,800 --> 00:04:26,100
但是，再一次

99
00:04:26,100 --> 00:04:27,959
一个类型不会改变一个指针

100
00:04:27,959 --> 00:04:29,670
一个指针只是一个内存地址

101
00:04:29,670 --> 00:04:31,110
它只是一个整数

102
00:04:31,110 --> 00:04:31,949
所以void指针

103
00:04:31,949 --> 00:04:37,199
这意味着，在源码中我们现在不关心这个数据到底是啥类型

104
00:04:37,199 --> 00:04:40,230
因为我们只想要存放一个地址

105
00:04:40,230 --> 00:04:40,800
让我们继续

106
00:04:40,800 --> 00:04:44,430
我把它简称为ptr(pointer)，把它设为0

107
00:04:44,430 --> 00:04:45,300
那么什么是0呢

108
00:04:45,300 --> 00:04:47,790
我们给了这个指针一个为0的内存地址

109
00:04:47,790 --> 00:04:48,720
这是什么意思？

110
00:04:48,720 --> 00:04:49,019
其实

111
00:04:49,019 --> 00:04:51,569
0其实不是一个有效的内存地址

112
00:04:51,569 --> 00:04:54,389
内存地址不会是0

113
00:04:54,389 --> 00:04:55,589
0是无效的

114
00:04:55,589 --> 00:04:58,470
这意味着这个指针是无效的

115
00:04:58,470 --> 00:05:01,379
对于指针来说，无效是一个完全可以接受的状态

116
00:05:01,379 --> 00:05:04,949
但我这里说的是，0不是一个有效的内存地址

117
00:05:04,949 --> 00:05:08,160
我们没法读取或者写入地址为0的内存，如果我们试图这样做

118
00:05:08,160 --> 00:05:10,379
我们的程序会崩溃，所以0意味着没有

119
00:05:10,379 --> 00:05:12,389
我们也可以这样写

120
00:05:12,389 --> 00:05:14,009
这实际上只是一个#define

121
00:05:14,009 --> 00:05:16,050
如果你去看一下这个NULL到底是啥，你可以看到

122
00:05:16,050 --> 00:05:18,480
它只一个给0的 #define

123
00:05:18,480 --> 00:05:22,699
所以这和我们在这写0是一回事，或者我们可以c++的一个关键字叫nullptr

124
00:05:22,699 --> 00:05:25,199
这是在c++11引入的，awesome！

125
00:05:25,199 --> 00:05:26,519
我们已经创建了第一个指针

126
00:05:26,519 --> 00:05:30,329
它是完全没有类型的，它的内存地址为0

127
00:05:30,329 --> 00:05:34,199
完全没用，但它是个指针，可能是你能写出来的最简单的指针

128
00:05:34,199 --> 00:05:36,029
让我们做一些更有用的事情

129
00:05:36,029 --> 00:05:37,170
让我们来创建一个int

130
00:05:37,170 --> 00:05:38,639
我将创建一个变量

131
00:05:38,639 --> 00:05:39,569
我把它叫做 var

132
00:05:39,569 --> 00:05:42,209
我想让它等于8，它将是一个整数

133
00:05:42,209 --> 00:05:43,740
这只是一个普通的整数

134
00:05:43,740 --> 00:05:46,425
但是我们创建的任何变量都有一个内存地址

135
00:05:46,699 --> 00:05:48,600
因为我们需要一个存储该变量的地方

136
00:05:48,600 --> 00:05:52,589
所以，如果我想知道那个变量的内存地址是什么

137
00:05:52,589 --> 00:05:53,040
所以

138
00:05:53,040 --> 00:05:54,389
你在内存的什么位置

139
00:05:54,389 --> 00:05:57,329
我可以通过使用&运算符来实现

140
00:05:57,329 --> 00:06:01,439
所以如果我在一个现有的变量前面用一个&符号，像这样

141
00:06:01,439 --> 00:06:03,329
我们实际上是在问这个变量

142
00:06:03,329 --> 00:06:03,810


143
00:06:03,810 --> 00:06:05,250
嘿 你的内存地址是什么

144
00:06:05,250 --> 00:06:05,519
然后

145
00:06:05,850 --> 00:06:08,910
我们拿到那个变量的内存地址

146
00:06:08,910 --> 00:06:12,089
在我们这，把它赋给一个叫ptr的新变量

147
00:06:12,089 --> 00:06:12,660
就是这样

148
00:06:12,660 --> 00:06:15,540
我们现在得到了变量的内存地址

149
00:06:15,540 --> 00:06:18,000
我们把它存储在另一个变量中，一个指针中

150
00:06:18,000 --> 00:06:22,800
我将在这行代码上设置一个断点，并按F5来运行及调试我的程序

151
00:06:22,829 --> 00:06:23,310
所以现在

152
00:06:23,310 --> 00:06:24,600
如果我看一下我们现在有什么

153
00:06:24,600 --> 00:06:25,860
可以看到我们有一个变量

154
00:06:25,860 --> 00:06:27,269
我把鼠标放在上面

155
00:06:27,269 --> 00:06:28,470
它有个8的值

156
00:06:28,470 --> 00:06:30,629
如果我把鼠标悬停在这个指针上

157
00:06:30,629 --> 00:06:33,060
它的值，额，略有不同

158
00:06:33,060 --> 00:06:35,370
以16进制的形式显示的

159
00:06:35,370 --> 00:06:36,089
但它是

160
00:06:36,089 --> 00:06:36,750
如你所见

161
00:06:36,750 --> 00:06:37,800
仍然只是一个数字

162
00:06:37,800 --> 00:06:38,610
它是一个整数

163
00:06:38,610 --> 00:06:43,560
所以这个变量现在持有的是变量var的内存地址

164
00:06:43,560 --> 00:06:46,139
仅此而已，你看到的那个数字

165
00:06:46,139 --> 00:06:47,459
a0fb64

166
00:06:47,459 --> 00:06:51,839
那就是我们在内存中存储我们的整型变量的位置

167
00:06:51,839 --> 00:06:52,259
事实上

168
00:06:52,259 --> 00:06:54,300
我可以拿到它

169
00:06:54,300 --> 00:06:55,350
复制

170
00:06:55,350 --> 00:06:59,300
点Debug->Windows->Memory->memory 1

171
00:06:59,370 --> 00:07:03,629
这个视图现在显示的是我们程序内的所有内存

172
00:07:03,629 --> 00:07:05,040
我要那个值粘贴进来

173
00:07:05,040 --> 00:07:07,889
我先把前面这个ptr去掉

174
00:07:09,480 --> 00:07:10,139
然后按回车

175
00:07:10,139 --> 00:07:12,420
看哪！

176
00:07:12,420 --> 00:07:14,939
我们被带到这个内存地址

177
00:07:15,959 --> 00:07:18,810
我们知道一个整数是4字节，然后你看这个

178
00:07:18,810 --> 00:07:22,170
它有8这个值，我们正在看电脑的内存

179
00:07:22,169 --> 00:07:30,209
我们可以看到，在那个内存地址我们有值8，因为我们创建了那个变量并且设为8

180
00:07:30,209 --> 00:07:30,870
太棒了

181
00:07:32,310 --> 00:07:33,300
我是说

182
00:07:33,300 --> 00:07:35,550
在一个基楚的层面上看，这就是这么回事而已

183
00:07:35,550 --> 00:07:37,529
其他一切都是建立在这个基础之上的

184
00:07:37,529 --> 00:07:39,870
如果你懂这么多，而且有根据自己的理解跟上我的讲解

185
00:07:39,870 --> 00:07:40,170
它。。。

186
00:07:40,170 --> 00:07:41,970
没有魔法的

187
00:07:41,970 --> 00:07:44,160
指针就是这么回事，一个指针是

188
00:07:44,160 --> 00:07:47,009
一个包含地址的变量

189
00:07:47,009 --> 00:07:47,759
一个整数

190
00:07:47,759 --> 00:07:49,350
指针就像任何其他变量一样

191
00:07:49,350 --> 00:07:51,569
只是不是存放一个值，比如说8

192
00:07:51,569 --> 00:07:52,980
而是存放一个内存地址

193
00:07:52,980 --> 00:07:54,509
一个内存地址也是值

194
00:07:54,509 --> 00:07:55,439
它也是一个整数

195
00:07:55,439 --> 00:07:55,649
那么

196
00:07:55,649 --> 00:08:01,769
这个整数有多大—这个指针有多大，取决于很多东西，它可能是一个32位的整数

197
00:08:01,769 --> 00:08:02,970
可能是64位的

198
00:08:02,970 --> 00:08:03,959
可能是16位的

199
00:08:03,959 --> 00:08:05,639
这不重要，好吗

200
00:08:05,639 --> 00:08:06,209
关键是

201
00:08:06,209 --> 00:08:07,199
它是一个整数

202
00:08:07,199 --> 00:08:08,970
它也永远只是一个整数

203
00:08:08,970 --> 00:08:13,199
如果我回到我的代码，把它变成一个整数指针

204
00:08:13,199 --> 00:08:14,759
实际上我并没有改变任何东西

205
00:08:14,759 --> 00:08:16,529
如果我再次运行程序

206
00:08:16,529 --> 00:08:18,540
你会发现没什么不同

207
00:08:18,540 --> 00:08:22,470
如果我继续复制这个值

208
00:08:22,470 --> 00:08:25,019
复制它，粘贴到内存视图

209
00:08:25,019 --> 00:08:26,699
然后按回车

210
00:08:26,699 --> 00:08:29,199
你可以看到它仍然是8

211
00:08:29,279 --> 00:08:30,300
我可以回到这里

212
00:08:30,300 --> 00:08:32,850
我可以把它变成一个完全不同的类型

213
00:08:32,850 --> 00:08:33,750
比如double

214
00:08:33,750 --> 00:08:34,080
当然

215
00:08:34,080 --> 00:08:35,490
它会在这个时候给我一个错误

216
00:08:35,490 --> 00:08:38,279
因为编译器会报警

217
00:08:38,279 --> 00:08:40,139
我可以把它转换成double类型

218
00:08:40,139 --> 00:08:40,889
没关系

219
00:08:40,889 --> 00:08:42,700
我将再次运行代码

220
00:08:42,774 --> 00:08:50,965
我将看一下它的值，复制它的值，粘贴到这里，
然后把后面一串都删掉，回车，然后再看

221
00:08:50,970 --> 00:08:54,059
它带我到内存中存储我的数据的地方

222
00:08:54,059 --> 00:08:58,980
这里有4个字节，存着8这个值，类型完全不会影响

223
00:08:58,980 --> 00:09:02,159
类型对于操纵这块内存有用

224
00:09:02,159 --> 00:09:03,750
如果我想读取和写入它

225
00:09:03,750 --> 00:09:06,870
内存类型可以帮助我，因为编译器会知道

226
00:09:06,870 --> 00:09:07,409
比如

227
00:09:07,409 --> 00:09:09,450
一个整数应该是4个字节

228
00:09:09,450 --> 00:09:11,549
所以当我要设置一个值的时候

229
00:09:11,549 --> 00:09:13,230
它会设置4个字节的内存

230
00:09:13,230 --> 00:09:13,919
但最终

231
00:09:13,919 --> 00:09:16,919
类型是完全没有意义的，在以后的视频中 

232
00:09:16,919 --> 00:09:19,139
我们将更深入地研究这个问题

233
00:09:19,139 --> 00:09:21,779
但现在，就别担心类型的事了

234
00:09:21,779 --> 00:09:22,230
好了

235
00:09:22,230 --> 00:09:25,649
让我们用回我们的void指针，好吧

236
00:09:25,649 --> 00:09:27,360
为什么我们不总使用void指针呢？

237
00:09:27,360 --> 00:09:27,450
嗯

238
00:09:27,450 --> 00:09:29,610
假设我想要读取我的数据

239
00:09:29,610 --> 00:09:32,429
我有一个指向那个数据的指针

240
00:09:32,429 --> 00:09:32,759
然而

241
00:09:32,759 --> 00:09:36,960
现在我想要写入或读取这块数据

242
00:09:36,960 --> 00:09:38,940
所以这个存储值8的变量

243
00:09:38,940 --> 00:09:40,019
我想更改它

244
00:09:40,019 --> 00:09:41,009
如何更改呢

245
00:09:41,009 --> 00:09:41,759
我该怎么。。

246
00:09:41,759 --> 00:09:42,179
我有。。

247
00:09:42,179 --> 00:09:43,289
我知道数据在哪里

248
00:09:43,289 --> 00:09:44,850
但是我怎么才访问它呢

249
00:09:44,850 --> 00:09:46,259
这时候dereferencing（逆向引用）就派上用场了

250
00:09:46,259 --> 00:09:50,549
所以我们从一个var变成了一个指针指向var

251
00:09:50,549 --> 00:09:52,500
但是我怎么才能回到那个var呢

252
00:09:52,799 --> 00:09:57,000
你可以通过在指针前面加上一个星号来实现

253
00:09:57,000 --> 00:09:57,480
换句话说

254
00:09:57,480 --> 00:09:58,889
如果我写这个

255
00:09:58,889 --> 00:10:07,110
我实际上是在逆向引用那个指针，也就是我现在在访问那块数据，我可以读取或者写入那块数据

256
00:10:07,110 --> 00:10:07,679
所以我可以

257
00:10:07,679 --> 00:10:08,279
例如

258
00:10:08,279 --> 00:10:10,289
将值10写入

259
00:10:10,289 --> 00:10:10,649
然而

260
00:10:10,649 --> 00:10:11,549
如果我试着这样做

261
00:10:11,549 --> 00:10:13,169
你会看到我实际上得到了一个错误

262
00:10:13,169 --> 00:10:13,590
为什么

263
00:10:13,590 --> 00:10:15,059
因为我们已经说过了

264
00:10:15,059 --> 00:10:17,250
这个指针是一个void指针

265
00:10:17,250 --> 00:10:18,629
这意味着，我的意思是怎么。。

266
00:10:18,629 --> 00:10:21,200
计算机如何才能把一个值写到一个void指针里去？

267
00:10:21,269 --> 00:10:22,230
它不知道那是什么

268
00:10:22,230 --> 00:10:23,429
这个10是short吗

269
00:10:23,429 --> 00:10:24,539
short是一个两个字节的整数

270
00:10:24,539 --> 00:10:26,730
还是一个int？int是一个4个字节的整数

271
00:10:26,730 --> 00:10:27,539
还是说是一个long long？

272
00:10:27,539 --> 00:10:29,639
那就是一个8字节的整数

273
00:10:29,639 --> 00:10:33,200
我们不知道该写入多少字节的数据，对吧？

274
00:10:33,210 --> 00:10:34,230
我们刚说它是10

275
00:10:34,230 --> 00:10:35,970
但说实话，10可能是任何东西

276
00:10:35,970 --> 00:10:36,899
这时候就要用到类型了

277
00:10:36,899 --> 00:10:37,980
我们需要告诉编译器

278
00:10:37,980 --> 00:10:39,700
其实，这其实是个Integer

279
00:10:39,779 --> 00:10:41,100
所以我需要写入4个字节

280
00:10:41,524 --> 00:10:43,769
那么让我们把它改成int

281
00:10:43,769 --> 00:10:44,250
现在

282
00:10:44,799 --> 00:10:46,500
我们已经告诉编译器这是一个int

283
00:10:46,500 --> 00:10:50,899
是我们告诉编译器的，并不是编译器自己在那，“对，是，没错”

284
00:10:50,970 --> 00:10:52,049
是我们告诉编译器的

285
00:10:52,049 --> 00:10:52,950
如果我们搞错了

286
00:10:52,950 --> 00:10:54,779
如果我们说这是一个double

287
00:10:54,779 --> 00:10:55,799
我们可能会有麻烦

288
00:10:55,799 --> 00:10:58,620
如果我输出var的值

289
00:10:58,620 --> 00:11:01,899
也就是我们原始的变量

290
00:11:01,919 --> 00:11:04,830
你会看到我得到的值是10

291
00:11:04,830 --> 00:11:05,190
好的

292
00:11:05,190 --> 00:11:08,399
所以我们成功地把它从8变成了10

293
00:11:08,399 --> 00:11:12,509
如果我们继续，在这里设置另一个断点并运行我们的程序

294
00:11:12,509 --> 00:11:15,240
我要到watch这里，并输入这个ptr

295
00:11:15,240 --> 00:11:18,299
然后我把这个值一路拖到这里，这样我们就到了指向的内存这

296
00:11:18,299 --> 00:11:20,789
你会看到这块内存存储着8这个值

297
00:11:20,789 --> 00:11:23,549
如果我按F10来前进一行

298
00:11:23,549 --> 00:11:26,669
你会看到现在变成了0a

299
00:11:26,669 --> 00:11:28,700
就是十六进制的10

300
00:11:28,700 --> 00:11:32,000
所以你可以看到，通过解引用一个指针并写入它

301
00:11:32,039 --> 00:11:33,720
我就上是在访问那块数据

302
00:11:33,720 --> 00:11:36,990
在我们这种情况，就是写入那块内存

303
00:11:36,990 --> 00:11:37,379
好了

304
00:11:37,379 --> 00:11:40,169
cool，现在你应该知道指针是怎么工作的

305
00:11:40,169 --> 00:11:44,399
这其实就是它们的全部，一个指针只是指向内存中的一个位置

306
00:11:44,399 --> 00:11:46,620
有些人说它指向一块内存（ a block of memory）

307
00:11:46,620 --> 00:11:50,279
虽然这不是很准确，因为我们不知道那块内存多大

308
00:11:50,279 --> 00:11:51,629
在这种情况下

309
00:11:51,629 --> 00:11:56,309
它是4字节，因为我们有一个int，一个int是4个字节的内存

310
00:11:56,309 --> 00:12:00,330
所以我们确实是有一个指针指向4个字节的一块内存

311
00:12:00,330 --> 00:12:01,019
然而

312
00:12:01,019 --> 00:12:07,500
在实际的指针中，并没有哪里有说内存有多大，当我们创建数组的时候，它有记录大小

313
00:12:07,500 --> 00:12:08,730
我不打算讲那个

314
00:12:08,730 --> 00:12:09,360
但是简单地说

315
00:12:09,360 --> 00:12:10,830
我们不知道指针有多大

316
00:12:10,830 --> 00:12:14,429
我们不知道它含有多少数据，因为它并没有保存数据，对吧

317
00:12:14,429 --> 00:12:18,120
指针只是一个整数，也就是一个内存地址

318
00:12:19,559 --> 00:12:20,490
仅此而已

319
00:12:20,490 --> 00:12:20,970
到目前为止

320
00:12:20,970 --> 00:12:23,399
我们都是直接在stack上创建数据

321
00:12:23,399 --> 00:12:24,779
如果我这样创建变量

322
00:12:24,779 --> 00:12:28,019
我们是在内存的stack部分创建它

323
00:12:28,019 --> 00:12:31,169
我会在以后的视频中介绍stack和heap

324
00:12:31,169 --> 00:12:36,600
如果我做了那个视频的话，本视频上可能会有标记，所以到时候如果你想了解请前去查看

325
00:12:36,674 --> 00:12:39,464
但我也可以在heap上创建一个变量

326
00:12:39,480 --> 00:12:41,610
或者，我们可以问我们的电脑

327
00:12:42,210 --> 00:12:44,610
我想要你为我分配一些内存

328
00:12:44,610 --> 00:12:46,409
而且我想它是一个特定的尺寸

329
00:12:46,409 --> 00:12:49,500
所以我可以做的就是，使用char*

330
00:12:49,500 --> 00:12:53,399
我们知道,char是一个字节，对吧

331
00:12:53,399 --> 00:12:55,110
所以当我问这样的问题时

332
00:12:55,110 --> 00:12:59,200
我管它叫buffer（缓冲缓存的意思），然后把它设为大小为8的new char[]

333
00:12:59,220 --> 00:13:02,129
这里我真正问它要的是8个字节的内存

334
00:13:02,129 --> 00:13:09,899
这为我们分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针

335
00:13:09,899 --> 00:13:12,059
然后我就可以使用一个叫memset的函数

336
00:13:12,059 --> 00:13:15,539
它就是用我们指定的数据填充一块内存

337
00:13:15,539 --> 00:13:20,370
它接受一个指针，该指针指向这块内存的开始处

338
00:13:20,370 --> 00:13:23,850
然后接受一个值，比如0，然后是大小

339
00:13:23,850 --> 00:13:26,279
就是应该填充多少个字节，在我们这

340
00:13:26,279 --> 00:13:28,259
我们知道我们有8个字节

341
00:13:28,259 --> 00:13:29,610
让我们运行这个程序

342
00:13:29,610 --> 00:13:30,720
我现在要把这个。。

343
00:13:30,720 --> 00:13:35,159
你会看到在这里有它的内存地址，不过你已经知道memory窗口是如何工作的以及所有这些，我就不罗嗦了

344
00:13:35,159 --> 00:13:38,639
所以我将在这里输入buffer这个变量，然后回车

345
00:13:38,639 --> 00:13:39,899
你会看到，看这里

346
00:13:39,899 --> 00:13:42,000
我们拿到了8个字节的内存，当然了，是连续的

347
00:13:42,090 --> 00:13:43,320
它们都被设为了0

348
00:13:43,320 --> 00:13:48,659
因为这就我们用memset做到的，是我们在这个例子中，由于我们使用了new这个关键字，所以该数据是分配在heap上的

349
00:13:48,659 --> 00:13:51,210
我们还应该在处理完后删除这个数据

350
00:13:51,210 --> 00:13:53,100
我们可以通过打delete[]来实现（译者按：话说他没有解释new和delete到底是如何实现的，我在评论里解释了下）

351
00:13:53,100 --> 00:13:54,029
我们知道它是一个array

352
00:13:54,029 --> 00:13:56,370
我们使用的是new[]来分配的

353
00:13:56,370 --> 00:14:03,600
所以我们应该使用delele[]来删除，如果我们够nice的话

354
00:14:03,600 --> 00:14:05,159
然而，不管怎样这个程序都会在这里结束

355
00:14:05,159 --> 00:14:08,909
这个例子的目的是再次重申，这是一个指针

356
00:14:08,909 --> 00:14:11,639
我们在这里说过，我们想分配8个char

357
00:14:11,639 --> 00:14:12,840
char是一个字节

358
00:14:12,840 --> 00:14:17,970
因此我们分配了8个字节，然后我们把这块内存的开始地址存在一个指针里

359
00:14:17,970 --> 00:14:22,409
还有一件事我想说的是，指针本身也只是变量

360
00:14:22,409 --> 00:14:25,860
这些指针-这些变量也存储在内存中

361
00:14:25,860 --> 00:14:30,720
但这就是我们可以有double pointers, triple pointers之类的骚操作，其实就是指针的指针

362
00:14:30,720 --> 00:14:32,039
那那些都是怎么工作的呢

363
00:14:32,039 --> 00:14:32,429
嗯

364
00:14:32,429 --> 00:14:37,710
你只要再下一层，就是说我现在有一个指针，它指向另一个指针

365
00:14:37,710 --> 00:14:40,620
所以现在我有一个变量，存储着一个内存地址

366
00:14:40,620 --> 00:14:43,620
它指向另一个变量，那个变量也存储着一个内存地址

367
00:14:44,610 --> 00:14:47,549
很简单，对吧，所以在我们例子中，用我们的buffer

368
00:14:47,549 --> 00:14:49,139
我可以创建一个double pointer

369
00:14:49,139 --> 00:14:49,379
对吧

370
00:14:49,379 --> 00:14:56,460
这个的意思是它是一个指针的指针，我给它取名叫ptr，并将它设为buffer的内存地址

371
00:14:56,460 --> 00:14:59,490
这时候就比较有意思了

372
00:14:59,490 --> 00:15:03,210
我将在把这个断点往上移动到这，因为我还不想删除数据

373
00:15:03,210 --> 00:15:04,559
让我们慢慢地看一看它

374
00:15:04,559 --> 00:15:08,549
这是指针的值，我要把它复制到这里

375
00:15:08,549 --> 00:15:09,629
现在

376
00:15:09,629 --> 00:15:15,090
你可以看到我们这里有b8 f1 02 00，4个字节

377
00:15:15,090 --> 00:15:20,899
我知道这个指针将是4字节，因为我在运行一个32位的应用程序

378
00:15:20,909 --> 00:15:22,679
在一个32位程序里

379
00:15:22,679 --> 00:15:26,250
一个内存地址是32位，更多关于这个的，以后的视频再说

380
00:15:26,250 --> 00:15:29,799
因为这台电脑的endianness其实是逆序的（译者按：所谓little endian）

381
00:15:29,799 --> 00:15:38,100
如果我复制它到这里，我们其实需要重新排列一下它，像这样，00 02 f1 b8 

382
00:15:38,100 --> 00:15:40,000
如果我按回车

383
00:15:40,049 --> 00:15:40,620
看啊

384
00:15:40,620 --> 00:15:45,120
我被带到储存了这些0的buffer的内存位置

385
00:15:45,120 --> 00:15:46,409
好的

386
00:15:46,409 --> 00:15:47,309
就是这样了

387
00:15:47,309 --> 00:15:48,600
指针的指针

388
00:15:48,600 --> 00:15:49,769
解决了

389
00:15:49,769 --> 00:15:50,820
非常简单的东西

390
00:15:50,820 --> 00:15:51,720
就是这样

391
00:15:51,720 --> 00:15:53,460
我可以一整天讲这些

392
00:15:53,460 --> 00:15:54,179
但讲真

393
00:15:54,179 --> 00:15:59,100
我肯定会到头来说指针只是一个存储着内存地址的整数

394
00:15:59,100 --> 00:16:01,860
这就是它的全部，烙在脑子里！

395
00:16:01,860 --> 00:16:08,100
我将会制作更多关于这个话题的视频，以及处理像指针算术之类的以及更高级的指针操作

396
00:16:08,129 --> 00:16:09,330
如果你是新来到这个频道

397
00:16:09,330 --> 00:16:10,440
欢迎订阅

398
00:16:10,440 --> 00:16:12,269
当您开始使用指针时

399
00:16:12,269 --> 00:16:15,000
当我们开始在这个系列中使用指针时

400
00:16:15,000 --> 00:16:18,539
你会得到更多的例子，你会发现它们有多强大，以及我们可以用它们干嘛

401
00:16:18,539 --> 00:16:20,970
但这是它们的原理

402
00:16:20,970 --> 00:16:23,399
不要过度思考

403
00:16:23,399 --> 00:16:24,629
它们真的很简单

404
00:16:24,629 --> 00:16:25,289
谢谢收看

405
00:16:25,289 --> 00:16:26,429
我希望你喜欢这个视频

406
00:16:26,429 --> 00:16:30,809
如果你喜欢，请点赞，你也可以在Twitter和Instagram上关注我

407
00:16:30,809 --> 00:16:34,440
如果你真的喜欢这个视频，你想看更多这样的视频

408
00:16:34,440 --> 00:16:35,610
你可以在patreon上支持我

409
00:16:37,440 --> 00:16:41,100
下节课我们会讲到reference，下个视频再见

410
00:16:41,100 --> 00:16:41,429
再见

