1
00:00:00,000 --> 00:00:04,025
Hey 大家好，我叫Cherno
欢迎来到一个全新的系列！

2
00:00:04,129 --> 00:00:07,450
本系列将带你了解C++你所需要知道的一切。

3
00:00:07,690 --> 00:00:10,630
我们将主要学习游戏开发中的C++

4
00:00:10,750 --> 00:00:13,880
然而，并不是说只运用于游戏开发或者游戏编程

5
00:00:13,980 --> 00:00:16,679
我们只是用游戏来举例子

6
00:00:16,929 --> 00:00:18,600
本系列其实适用于任何人

7
00:00:18,760 --> 00:00:20,449
无论你是初学者还是熟练的码农


8
00:00:20,449 --> 00:00:22,100
我们会涉及C++的基础知识

9
00:00:22,100 --> 00:00:24,230
但会非常简洁


10
00:00:24,230 --> 00:00:28,850
所以，如果你是初学者，你仍然可以跟着学下去

11
00:00:28,850 --> 00:00:34,125
但你得能够去搜索、研究、自己去找一些基础的东西

12
00:00:34,130 --> 00:00:37,100
基本上就是做个正常人，能自己去谷歌你不懂的东西

13
00:00:37,259 --> 00:00:40,549
我不打算在基础上细讲太久，或者极尽详细的介绍

14
00:00:40,770 --> 00:00:42,880
所以你得确保自己搜索一些东西，你可以的！

15
00:00:43,250 --> 00:00:46,880
所以问题来了，我为啥要学C++呢？

16
00:00:46,979 --> 00:00:49,329
难道C++不是有点过时了吗？

17
00:00:49,500 --> 00:00:51,579
现在学C++有什么好处？

18
00:00:51,689 --> 00:00:58,399
其实C++仍然是当你需要写高性能的代码时最常用的语言

19
00:00:58,509 --> 00:01:02,649
或者你在写一个诡异的架构或者平台，然后你需要让代码本地(native)运行

20
00:01:02,840 --> 00:01:05,549
如果你要对硬件的直接控制，C++就是为你而生

21
00:01:05,599 --> 00:01:08,650
比如说游戏行业就大量运用C++

22
00:01:08,709 --> 00:01:13,420
像Unity、Unreal、frostbite之类的游戏引擎都是用C++写的

23
00:01:13,700 --> 00:01:16,299
那我们为什么要对硬件的直接控制呢？

24
00:01:16,400 --> 00:01:20,250
为什么这些引擎都是用C++写的，而非其他语言呢？ 

25
00:01:20,390 --> 00:01:23,879
最主要的原因就是C++能直接控制硬件

26
00:01:23,989 --> 00:01:26,150
我们来稍微讲一下C++是如何工作的

27
00:01:26,290 --> 00:01:30,750
你用C++写好代码，传入编译器(compiler)

28
00:01:30,870 --> 00:01:34,849
然后编译器会为你的目标平台产出机器码

29
00:01:34,930 --> 00:01:39,420
机器码是你设备的CPU执行的真正指令

30
00:01:39,519 --> 00:01:45,420
所以用C++我们完全可以控制你CPU执行的每一条指令

31
00:01:45,480 --> 00:01:48,469
你问C++可以在什么平台运行？基本上任何平台

32
00:01:48,579 --> 00:01:52,280
你只需要一个能产出那个平台的机器码的编译器即可

33
00:01:52,280 --> 00:01:56,230
比如说一个x64编译器会产出x64机器码

34
00:01:56,230 --> 00:01:58,200
从而在x64 CPU上运行

35
00:01:58,299 --> 00:02:03,799
举个例子，包括Windows,Mac,Linux,

36
00:02:03,799 --> 00:02:07,590
其他桌面操作系统（基本上所有的）都是C++开发的

37
00:02:07,599 --> 00:02:11,500
移动操作系统比如iOS，Android，你也都可以用C++来写应用

38
00:02:11,900 --> 00:02:14,700
以及所有主机，XBox，PlayStation

39
00:02:14,875 --> 00:02:18,800
和所有任天堂的主机，比如3ds,wii u,switch

40
00:02:19,974 --> 00:02:22,849
当你需要支持很多平台的时候，C++是非常好的选择

41
00:02:22,849 --> 00:02:24,699
因为只要有一个编译器，

42
00:02:24,849 --> 00:02:29,025
你就可以把代码编译成能在该平台上运行的native code

43
00:02:29,175 --> 00:02:31,865
当然还有其他native语言

44
00:02:31,865 --> 00:02:37,599
只不过C++从80年代初就出现了，而且很流行，所有人都知道

45
00:02:38,449 --> 00:02:40,569
所有人都在用它

46
00:02:40,680 --> 00:02:44,629
其他语言比如C#和Java不一样，因为它们在虚拟机中运行

47
00:02:44,780 --> 00:02:48,129
这表示你的代码会首先被编译成一种中间语言

48
00:02:48,210 --> 00:02:56,250
然后当你在目标平台运行你的应用时，虚拟机会在runtime将代码转化成机器码

49
00:02:56,300 --> 00:02:57,900
如果你愿意，可以想象一下

50
00:02:57,900 --> 00:03:02,719
比方说你用英语写了本书，然后你想让某个德国读者读懂它

51
00:03:02,969 --> 00:03:12,219
所以你决定在德国书店销售英语版本，但是你买书的时候同时会获得一个翻译

52
00:03:12,379 --> 00:03:15,349
一个真的人跟你回家

53
00:03:15,449 --> 00:03:17,599
我知道这个暗喻稍微有点诡异，请再容忍我一会

54
00:03:17,599 --> 00:03:21,625
当这个人回家了，这个德国人想看这本书

55
00:03:21,625 --> 00:03:26,625
这个翻译呢，用英文看那本书然后一边用德语讲出来

56
00:03:27,025 --> 00:03:30,169
所以他就像在即时翻译整本书

57
00:03:30,169 --> 00:03:32,719
这基本上就有点像虚拟机干的事

58
00:03:32,860 --> 00:03:39,680
把书直接翻译成德语然后直接卖德语版本显然更有效率

59
00:03:39,810 --> 00:03:43,219
这样的话就是本土语言——德语了

60
00:03:43,349 --> 00:03:49,569
当然这不是特别完美的比方了，但这基本就是运行C++和其他语言比如Java和C#的区别了

61
00:03:49,719 --> 00:03:58,379
C++是本土语言，C++编译器为那个平台和架构编译出机器码，就完事了，就是native的

62
00:03:58,550 --> 00:04:03,129
编译出的机器码只会运行于这个平台，但这就是这个平台的机器码了

63
00:04:03,229 --> 00:04:12,500
绝对没有任何“翻译”的需要了，它就能直接运行了

64
00:04:12,620 --> 00:04:17,129
当然，你的代码现在是native了，并不是说它就一定很快

65
00:04:17,209 --> 00:04:25,569
如果你用C++写垃圾代码，一样很慢，甚至更有可能会比虚拟机语言(C#,Java)更慢

66
00:04:25,689 --> 00:04:29,180
因为它们会在运行时优化很多东西而C++不会

67
00:04:29,339 --> 00:04:34,339
所以你如果写垃圾代码，C++绝对比C#和Java慢

68
00:04:34,620 --> 00:04:38,430
正因为此，我喜欢用那些语言比如C#只是写一些工具

69
00:04:38,540 --> 00:04:45,399
或者那些不需要我榨干所有性能的时候，C#是一个超好的语言

70
00:04:45,610 --> 00:04:50,149
但本系列是为那些我们需要那种性能的时候，我们需要用C++

71
00:04:50,310 --> 00:04:55,569
所以我们会学到如何正确的写C++代码，如何写好的代码，如何写速度快的代码

72
00:04:55,689 --> 00:04:58,769
所以你会问那我们会涵盖哪些内容呢？

73
00:04:58,980 --> 00:05:06,629
当然，一开始我们会从基础讲起，基础的东西我会很简洁，因为我不想花太多时间在上面

74
00:05:06,769 --> 00:05:11,550
如果你从来没学习过编程，我仍然鼓励你观看本系列

75
00:05:11,550 --> 00:05:15,649
但正如我之前所说，你得学会使用google搜索你不明白的内容

76
00:05:15,649 --> 00:05:17,449
应该会比较容易跟上

77
00:05:17,519 --> 00:05:22,519
学习任何新东西其实就是多练习，多尝试

78
00:05:22,524 --> 00:05:28,394
所以我相信你绝对ok的，只要你有激情，以及想要去学

79
00:05:28,750 --> 00:05:34,024
我们还会学习在需要优化性能的地方如何使用c++(library)库

80
00:05:34,209 --> 00:05:38,649
我们会讲到C++到底是如何工作的，我们会讲内存(memory)和指针(pointer)

81
00:05:38,759 --> 00:05:43,180
讲真，不知道为啥，很多教程教这些东西都教得稀烂

82
00:05:43,279 --> 00:05:47,230
所以我们这次会正确的教指针和内存等东西

83
00:05:47,399 --> 00:05:52,819
内存池(memory arena), custom allocator, smart pointer(智能指针), move semantics(移动语义)等等

84
00:05:52,930 --> 00:05:59,480
摸板(template)以及如何正确的使用它们，如果你懂得用好templates，它们非常强大，让你的工作轻松不少

85
00:05:59,620 --> 00:06:03,180
我们会讲宏(macro)以及怎么给多平台编程

86
00:06:03,250 --> 00:06:08,600
我们会创建自己的数据结构，并学习如何让它们运行比std库里还快

87
00:06:08,759 --> 00:06:12,379
我们甚至会涉及底层优化，比如编译器内联(compiler intrinsics)和汇编(assemblies)

88
00:06:12,529 --> 00:06:14,519
比如写我们自己的map和SSE

89
00:06:14,759 --> 00:06:23,649
这就是所有的了，过程中我们可能还会涵盖其他的，如果你们有希望我讲的（能讲10分钟以上的）

90
00:06:23,850 --> 00:06:26,550
我会做个视频讲它们

91
00:06:26,610 --> 00:06:31,610
如果你好奇我是谁，我是一个软件工程师，在EA墨尔本的游戏引擎团队

92
00:06:31,730 --> 00:06:34,769
我们制作基本上市面上最好的3d移动端游戏引擎

93
00:06:34,850 --> 00:06:39,850
我们最近发布的游戏有Need For Speed No Limits和No Limits VR，你可以在instagram或者tweeter关注我（后面就不翻译了）

