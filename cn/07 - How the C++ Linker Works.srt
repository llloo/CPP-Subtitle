1
00:00:00,000 --> 00:00:01,800
Hey 大家好! 我是cherno

2
00:00:01,800 --> 00:00:03,480
今天我们要讲的是链接

3
00:00:03,480 --> 00:00:04,830
那么什么是链接呢

4
00:00:04,830 --> 00:00:07,410
c++ linker到底做什么呢？

5
00:00:07,410 --> 00:00:13,570
linking是从c++源码到可执行二进制时的一个过程

6
00:00:13,679 --> 00:00:16,469
所以第一个阶段是编译我们的源文件

7
00:00:16,469 --> 00:00:18,239
我有一个视频专门讲它

8
00:00:18,239 --> 00:00:20,670
去看看哟，连接在视频下方描述

9
00:00:20,670 --> 00:00:22,019
一旦我们编译了文件

10
00:00:22,019 --> 00:00:24,420
我们需要通过一个叫做链接的过程

11
00:00:24,420 --> 00:00:31,320
现在链接的主要工作是找到每个符号和函数的位置 并将它们链接在一起

12
00:00:31,320 --> 00:00:31,710
记住

13
00:00:31,710 --> 00:00:35,939
每个文件被编译成一个独立的obj文件作为translation unit

14
00:00:35,939 --> 00:00:37,619
它们之间没有关系

15
00:00:37,619 --> 00:00:39,570
这些文件实际上没法沟通

16
00:00:39,570 --> 00:00:43,439
因此，如果我们决定将程序写在多个c++文件的话

17
00:00:43,439 --> 00:00:45,479
这当然很常见

18
00:00:45,479 --> 00:00:49,829
我们需要一种方法将这些文件链接到一个程序

19
00:00:49,829 --> 00:00:52,109
这就是链接器的主要目的

20
00:00:52,109 --> 00:00:54,689
即使你没有外部文件里的函数

21
00:00:54,689 --> 00:00:57,689
比如说你已经把整个程序写在一个文件里了

22
00:00:57,689 --> 00:01:00,659
应用程序仍然需要知道入口点(entry point)在哪里

23
00:01:00,659 --> 00:01:01,229
换句话说

24
00:01:01,229 --> 00:01:04,530
main函数在哪，当你运行你的程序时

25
00:01:04,530 --> 00:01:06,000
C运行时库可以说

26
00:01:06,000 --> 00:01:06,299
嘿

27
00:01:06,299 --> 00:01:07,319
这是主函数

28
00:01:07,319 --> 00:01:09,719
我要跳到那，从那里开始执行代码

29
00:01:09,719 --> 00:01:11,969
这实际上就是启动你的程序的地方

30
00:01:11,969 --> 00:01:14,370
所以它仍然需要链接主函数和其他东西

31
00:01:14,370 --> 00:01:15,840
即使你没有其他文件

32
00:01:15,840 --> 00:01:18,060
最好的解释方法是通过展示一些例子

33
00:01:18,060 --> 00:01:19,409
让我们过去看一看

34
00:01:19,469 --> 00:01:23,200
在vs中我们有一个非常简单的项目 ，只包含一个源文件

35
00:01:23,310 --> 00:01:24,450
math.cpp

36
00:01:24,450 --> 00:01:29,939
在这里面，我们有两个函数log和multiply，multiply函数实际上调用了log函数

37
00:01:29,939 --> 00:01:32,150
打印出multiply这个单词到控制台

38
00:01:32,170 --> 00:01:34,890
然后返回a*b，非常简单的东西

39
00:01:34,890 --> 00:01:35,250
然而

40
00:01:35,250 --> 00:01:37,079
这并不是一个实际的应用

41
00:01:37,079 --> 00:01:38,819
因为它显然不包含一个主函数

42
00:01:38,819 --> 00:01:44,700
你要意识到的第一件事是编译有两个阶段——编译和链接

43
00:01:44,700 --> 00:01:48,359
实际上有一种方法可以让你在vs中区分两者

44
00:01:48,359 --> 00:01:49,859
如果你按下ctrl+F7

45
00:01:49,859 --> 00:01:51,510
或者如果你按下编译按钮

46
00:01:51,510 --> 00:01:53,370
只有编译会发生

47
00:01:53,370 --> 00:01:55,530
链接完全不会发生

48
00:01:55,530 --> 00:01:59,519
然而如果你build了你的项目，或者如果你按F5运行的时候

49
00:01:59,519 --> 00:02:02,159
它会编译，然后链接

50
00:02:02,159 --> 00:02:04,379
所以如果我只按ctrl+F7

51
00:02:04,379 --> 00:02:06,209
你会发现我实际上没有遇到任何错误

52
00:02:06,209 --> 00:02:09,900
一切都ok，因为编译成功了

53
00:02:09,900 --> 00:02:12,819
它产生了那个math.obj文件，也就是对象文件，一切都很好

54
00:02:12,960 --> 00:02:13,319
然而

55
00:02:13,319 --> 00:02:15,960
如果我是右击我的项目并按build

56
00:02:15,960 --> 00:02:18,360
你会发现我实际上会得到一个链接错误

57
00:02:18,360 --> 00:02:20,460
入口点必须被定义

58
00:02:20,460 --> 00:02:23,340
那是因为我缺少了我的入口点，我的主函数

59
00:02:23,340 --> 00:02:26,250
因为我们的编译分为这两个阶段

60
00:02:26,250 --> 00:02:27,840
编译和链接

61
00:02:27,840 --> 00:02:31,860
所以实际上我们会得到与每个阶段相关的不同类型的错误消息

62
00:02:31,860 --> 00:02:33,750
比如说如果我犯了一个语法错误

63
00:02:33,750 --> 00:02:36,270
这当然是编译器必须处理的事情

64
00:02:36,270 --> 00:02:37,680
如果我编译我的代码

65
00:02:37,680 --> 00:02:40,229
你会看到它告诉我，我有一个错误

66
00:02:40,229 --> 00:02:42,069
也就是所谓的C2143

67
00:02:42,099 --> 00:02:43,599
然后它当然说语法错误

68
00:02:43,650 --> 00:02:46,500
这是这类错误的错误代码

69
00:02:46,500 --> 00:02:49,349
你会注意到它实际上是以C开头

70
00:02:49,349 --> 00:02:52,530
这告诉我们这是在编译阶段发生的错误

71
00:02:52,530 --> 00:02:56,520
如果我修好它，然后build我的整个项目

72
00:02:56,520 --> 00:03:00,210
你会看到这里列出的错误代码以字母LNK开头

73
00:03:00,210 --> 00:03:01,680
这当然代表了链接

74
00:03:01,680 --> 00:03:05,159
它甚至在这里告诉我们，这是在链接阶段发生的

75
00:03:05,159 --> 00:03:08,550
很重要的一点是你得知道你犯的是什么类型的错误

76
00:03:08,550 --> 00:03:11,069
不管是编译错误还是链接错误

77
00:03:11,199 --> 00:03:13,800
因为，你显然需要知道，这样你才能正确地解决它

78
00:03:13,800 --> 00:03:14,520
在这种情况下

79
00:03:14,520 --> 00:03:18,300
我们得到一个错误，告诉我们入口点必须被定义

80
00:03:18,300 --> 00:03:20,669
再一次，这是因为我们是将其编译为一个应用程序

81
00:03:20,669 --> 00:03:25,800
如果我们看一下我们的properties，我们看一下我们设置的configuration type

82
00:03:25,800 --> 00:03:27,360
可以看到它被设置为application(exe)

83
00:03:27,360 --> 00:03:31,770
每个exe文件必须有一个入口点

84
00:03:31,770 --> 00:03:35,159
如果我们进入到linker设置中->Advanced

85
00:03:35,159 --> 00:03:38,219
您可以看到我们可以指定一个自定义入口点

86
00:03:38,219 --> 00:03:42,870
入口点不一定是必须是main函数，只是必须有个入口点

87
00:03:42,870 --> 00:03:43,379
现在

88
00:03:43,379 --> 00:03:47,490
通常是main函数，基本上你以后做任何事的时候

89
00:03:47,490 --> 00:03:49,199
可能都是main函数

90
00:03:49,199 --> 00:03:50,159
但是就让你知道一下

91
00:03:50,159 --> 00:03:53,250
入口点不一定非得是一个叫做main的函数

92
00:03:53,250 --> 00:03:54,900
它可以是任何东西

93
00:03:54,900 --> 00:03:58,319
如果我们回到这里，写出这个主函数

94
00:03:58,319 --> 00:04:00,750
我就写int main

95
00:04:00,750 --> 00:04:02,310
然后我将再次build我的项目

96
00:04:03,449 --> 00:04:08,759
会看到我们不再得到那个链接错误，而且我们已经成功地生成了那个exe文件

97
00:04:09,090 --> 00:04:15,349
好了，现在我们已经明白这一点，让我们继续打印出来这个乘法函数的值

98
00:04:15,349 --> 00:04:18,449
所以我们用5和8相乘

99
00:04:21,300 --> 00:04:24,029
所以我们应该可以看到这个消息被log了

100
00:04:24,029 --> 00:04:26,160
然后40这个值被打印了

101
00:04:26,160 --> 00:04:31,110
我们也加一个cin.get，让我们的控制台不会瞬间关闭

102
00:04:31,110 --> 00:04:34,589
然后我点击这个local windows debug按钮来运行这个

103
00:04:34,589 --> 00:04:38,610
你可以看到，我们拿到了multiply和40，所以我们的应用程序看起来运行正常

104
00:04:38,610 --> 00:04:39,300
非常好

105
00:04:39,300 --> 00:04:41,610
现在假设这些存在于多个文件中

106
00:04:41,610 --> 00:04:42,509
例如

107
00:04:42,509 --> 00:04:47,379
这个log并不需要在这个math文件中，因为显然它只是log一条信息

108
00:04:47,519 --> 00:04:51,569
那么为什么我不搞一个单独的文件来放我所有的log相关的函数呢

109
00:04:51,680 --> 00:04:58,680
右击source files，添加一个新的c++文件，叫log.cpp，点add

110
00:04:58,740 --> 00:05:03,300
我将把这个log函数移动到log.cpp文件

111
00:05:03,319 --> 00:05:07,129
如果我回到math.cpp，试着编译这个代码

112
00:05:07,139 --> 00:05:11,180
我将会得到一个错误，你会知道这是一个编译错误因为错误代码以C开头

113
00:05:11,250 --> 00:05:13,560
告诉我没有找到log

114
00:05:13,560 --> 00:05:17,279
因为这个文件完全不知道一个名为log的函数的存在

115
00:05:17,279 --> 00:05:21,680
所以我们把这个log函数的第一行，也就是签名

116
00:05:21,680 --> 00:05:25,550
并加上这个，从而我们在这个math.cpp上有log函数的声明

117
00:05:25,550 --> 00:05:29,069
按ctrl+F7 ,可以看到编译成功了

118
00:05:29,069 --> 00:05:31,139
让我们去build我们的整个项目

119
00:05:31,139 --> 00:05:33,360
这里有几个错误——编译错误

120
00:05:33,360 --> 00:05:39,060
告诉我们cout没有被找到，因为我们其实得include iostream

121
00:05:40,230 --> 00:05:42,850
当我们这样做以后，让我们build整个项目

122
00:05:42,959 --> 00:05:44,910
好了，很好，看起来成功了

123
00:05:44,910 --> 00:05:47,970
现在让我们来看看我们可能会遇到的一种链接错误

124
00:05:47,970 --> 00:05:50,459
被称为unresolved external symbol（未解决的外部符号）

125
00:05:50,459 --> 00:05:54,839
当链接器找不到它需要的东西时，就会发生这种情况

126
00:05:54,839 --> 00:05:57,930
我们回到这里在log文件中

127
00:05:57,930 --> 00:05:59,819
我要把这个改成说点别的

128
00:05:59,819 --> 00:06:00,600
例如

129
00:06:00,600 --> 00:06:03,089
我要在这里加一个r所以就是logr

130
00:06:03,089 --> 00:06:04,300
如果我回到math.cpp

131
00:06:04,350 --> 00:06:10,139
我仍然有log的声明，所以它仍然期待函数被叫做log

132
00:06:10,139 --> 00:06:12,180
所以这个文件仍然会编译

133
00:06:12,180 --> 00:06:18,060
因为它没有链接，所以它做的只是检查以确保能正确编译

134
00:06:18,060 --> 00:06:21,029
它相信某处有一个log函数

135
00:06:21,029 --> 00:06:25,740
但找到这个log函数其实是链接阶段的工作

136
00:06:25,740 --> 00:06:27,629
所以如果我现在build我的整个项目

137
00:06:27,629 --> 00:06:29,399
你会看到我们得到了一个错误

138
00:06:29,399 --> 00:06:31,050
这是一个linking错误

139
00:06:31,050 --> 00:06:35,550
因为你可以看到它以LNK字母开头，而错误显示未解决的外部符号

140
00:06:35,550 --> 00:06:37,920
它告诉我们具体哪个符号缺失了

141
00:06:37,920 --> 00:06:40,920
是那个log函数，甚至告诉我们在哪里引用它

142
00:06:40,920 --> 00:06:43,439
它在一个叫做multiply的函数中引用它

143
00:06:43,439 --> 00:06:48,990
所以在multiply这里我们调用log 函数，但它找不到该link到哪个函数

144
00:06:49,050 --> 00:06:50,370
所以它必须给我们一个错误

145
00:06:50,370 --> 00:06:53,610
因为当我们在运行时碰到这句代码

146
00:06:53,610 --> 00:06:56,310
当它试图调用log函数时它该怎么办呢

147
00:06:56,310 --> 00:06:58,290
它不知道log函数在哪里

148
00:06:58,470 --> 00:07:02,850
如果我到这里，把这个log函数注释掉，这样我们就永远没有调用它了

149
00:07:02,850 --> 00:07:04,139
如果我试着build这个

150
00:07:04,139 --> 00:07:05,550
我们没有错误

151
00:07:05,550 --> 00:07:08,310
之所以如此是我从未调用过log函数

152
00:07:08,310 --> 00:07:13,019
所以linker不需要通过连接这个函数来调用log函数

153
00:07:13,019 --> 00:07:14,639
因为我们从来没有调用过log函数

154
00:07:14,639 --> 00:07:18,800
另一个有趣的地方是，如果我在multiply这调用log函数

155
00:07:18,839 --> 00:07:23,949
但我把这句注释掉，这样我就从来没有调用multiply了，也就没有在里面调用log

156
00:07:23,949 --> 00:07:25,949
如果我现在build项目

157
00:07:26,069 --> 00:07:29,160
你会看到我仍然有一个linking错误，你可能会黑人问号

158
00:07:29,160 --> 00:07:30,420
但为什么会这样呢

159
00:07:30,420 --> 00:07:33,149
我没在任何地方调用multiply

160
00:07:33,269 --> 00:07:35,250
为什么它会抱怨一个链接错误呢

161
00:07:35,459 --> 00:07:40,500
难道它不应该完全剔除这个函数吗，因为它本质上是从来没有使用过死代码

162
00:07:40,529 --> 00:07:44,250
因为虽然我们没有在这个文件中使用乘法函数

163
00:07:44,250 --> 00:07:47,519
技术上来讲我们可能在另一个文件中使用它

164
00:07:47,519 --> 00:07:49,850
因此linker确实需要链接它。

165
00:07:50,079 --> 00:07:53,579
如果我们有办法告诉编译器这个函数——multiply

166
00:07:53,579 --> 00:07:56,370
我只会在这个文件中使用它

167
00:07:56,550 --> 00:07:59,069
那么当然我们可以消除这种linking的必要

168
00:07:59,069 --> 00:08:02,939
因为multiply从未被调用过，它永远不需要调用log

169
00:08:02,939 --> 00:08:04,000
哦等一下！其实有一种方法实现

170
00:08:04,350 --> 00:08:08,100
如果我们来到这里，在乘法前面写上static这个词

171
00:08:08,100 --> 00:08:12,990
这基本上意味着这个乘法函数只是为这个翻译单元声明的

172
00:08:12,990 --> 00:08:15,360
在我们的例子中也就是这个math.cpp文件

173
00:08:15,360 --> 00:08:18,600
因为multiply从来没有在这个文件里被调用过

174
00:08:18,600 --> 00:08:21,699
如果我build，我们不会有任何linking错误 

175
00:08:21,750 --> 00:08:24,300
如果我把我的comment掉的拿回来，再build

176
00:08:24,300 --> 00:08:26,040
当然我们会得到一个链接错误

177
00:08:26,040 --> 00:08:26,639
在这种情况下

178
00:08:26,639 --> 00:08:28,920
 我们实际上是修改了函数的名称

179
00:08:28,920 --> 00:08:29,490
然而

180
00:08:29,490 --> 00:08:31,680
不仅仅是函数的名字很重要

181
00:08:31,680 --> 00:08:34,629
如果我把这个函数弄回原样，再管它叫log

182
00:08:34,710 --> 00:08:36,000
build我的项目

183
00:08:36,000 --> 00:08:37,710
我们不会有任何错误

184
00:08:37,710 --> 00:08:41,980
但是比如说我将返回类型改为int

185
00:08:42,000 --> 00:08:44,850
然后我就返回0或者类似的东西

186
00:08:44,850 --> 00:08:46,889
如果我现在build我的项目

187
00:08:46,889 --> 00:08:50,340
你会发现我们有了一个错误，因为在math.cpp

188
00:08:50,340 --> 00:08:53,639
我们指定这个log函数是返回void

189
00:08:53,639 --> 00:09:00,299
因为它会寻找一个名为log的函数，它返回void，并且接受这个参数

190
00:09:00,299 --> 00:09:01,320
如果我回到log

191
00:09:01,320 --> 00:09:03,450
可能我把它改回void

192
00:09:03,450 --> 00:09:05,879
删除return 0并build它

193
00:09:05,879 --> 00:09:06,870
一切都很顺利

194
00:09:06,870 --> 00:09:08,970
然后我可以添加另一个参数

195
00:09:08,970 --> 00:09:09,950
例如等级

196
00:09:09,950 --> 00:09:11,220
如果我现在build

197
00:09:11,220 --> 00:09:13,409
将再次得到一个链接错误

198
00:09:13,409 --> 00:09:17,820
因为它期待的log函数没有另一个参数

199
00:09:17,820 --> 00:09:20,820
你会看到，如果我们到这里看链接错误的消息

200
00:09:20,820 --> 00:09:23,519
它实际上期望一个返回void的函数

201
00:09:23,519 --> 00:09:25,110
它有这个调用约定

202
00:09:25,110 --> 00:09:26,190
名字叫log

203
00:09:26,190 --> 00:09:28,289
它必须只有一个参数

204
00:09:28,289 --> 00:09:30,299
也就是一个const char*

205
00:09:30,299 --> 00:09:30,809
就是这样

206
00:09:30,809 --> 00:09:33,179
如果它找不到一模一样的

207
00:09:33,179 --> 00:09:34,850
然后你就会得到一个链接错误

208
00:09:34,919 --> 00:09:39,210
让我们回到我们的log文件，把这个level删掉，这样程序就可以再次工作了

209
00:09:39,210 --> 00:09:42,549
如果我build，我们显然不会得到任何链接

210
00:09:42,700 --> 00:09:47,519
ok，另一种常见的链接错误是当我们有重复的符号时

211
00:09:47,519 --> 00:09:57,960
换句话说，我们有函数或变量有相同的名字和相同签名时，也就是两个相同名称的函数具有相同的返回值和相同的参数

212
00:09:57,960 --> 00:09:59,070
如果发生这种情况

213
00:09:59,070 --> 00:10:00,149
我们有麻烦了

214
00:10:00,149 --> 00:10:05,580
我们麻烦的原因是，linker不知道哪个link到哪个，是不明确的

215
00:10:05,580 --> 00:10:09,210
如果我比如说要写出这个函数的另一个版本

216
00:10:09,210 --> 00:10:12,990
所以我就直接复制粘贴并试着build代码

217
00:10:12,990 --> 00:10:15,029
你会注意到我们实际上有一个编译错误

218
00:10:15,029 --> 00:10:16,889
因为这已经有了一个body

219
00:10:16,889 --> 00:10:23,629
编译器可以告诉我们，“额，这个，好吧，因为我在编译这个文件，可以说你明显有错误”

220
00:10:23,639 --> 00:10:25,500
这种代码是无效的

221
00:10:25,500 --> 00:10:30,029
这个例子说明，当我们有重复符号时，编译器其实可以救我们

222
00:10:30,029 --> 00:10:34,830
因为这一切都发生在一个文件中，而不需要连接发生，就能判断我们有一个错误

223
00:10:35,049 --> 00:10:38,490
然而，如果我把它移到另一个文件中

224
00:10:38,490 --> 00:10:42,519
例如我把它移回到我们的math文件中

225
00:10:42,629 --> 00:10:46,730
所以我们仍然有声明，放在这没关系，它只是一个声明

226
00:10:46,730 --> 00:10:48,870
在这个文件中只有一个关于log的定义

227
00:10:48,870 --> 00:10:52,740
所以它不会给我们一个编译错误，如果我点击ctrlF7来编译它

228
00:10:52,740 --> 00:10:54,419
你可以看见这完全没问题

229
00:10:54,419 --> 00:10:55,559
但是现在build

230
00:10:55,559 --> 00:11:02,850
我们得到一个链接错误，你可以看到它告诉我们有这个log函数已经在log.obj中被定义了

231
00:11:02,850 --> 00:11:05,129
“找到了一个或多个被定义的符号”

232
00:11:05,129 --> 00:11:05,759
在这种情况下

233
00:11:05,759 --> 00:11:09,240
链接器不知道链接到哪个log函数,它该链接到math.cpp里的那个吗？

234
00:11:09,240 --> 00:11:12,919
还是链接到log.cpp里的那个？它不知道呀

235
00:11:12,980 --> 00:11:18,149
现在你可能会认为这种类型的错误不会经常发生，而且你没那么笨的

236
00:11:18,149 --> 00:11:19,919
然而这会发生到你身上的

237
00:11:19,919 --> 00:11:22,440
我来跟你展示下有几种发生的可能

238
00:11:22,440 --> 00:11:22,769
好了

239
00:11:22,769 --> 00:11:27,419
首先我们把这个额外的log定义去掉，从而让我们项目成功build

240
00:11:27,570 --> 00:11:29,129
现在创建一个头文件

241
00:11:29,129 --> 00:11:35,879
 右击header files，add new item，header file，叫它log.h，添加

242
00:11:35,879 --> 00:11:42,570
 在这里，我要把这个log函数拿来，并确保我在这个头文件中声明它

243
00:11:42,570 --> 00:11:44,340
如果我回到log.cpp

244
00:11:44,340 --> 00:11:53,309
我来写个其他函数，比如InitLog，它只是调用log，说初始化了log

245
00:11:53,309 --> 00:11:57,870
当然，如果我们现在尝试编译，我们会得到一个错误，因为我们需要拿到那个log函数

246
00:11:57,870 --> 00:12:00,059
所以我将include log

247
00:12:01,259 --> 00:12:06,700
回到math.cpp，我不会在这声明，相反，我也include log

248
00:12:07,740 --> 00:12:16,139
好了，我们既在math.cpp的乘法函数里调用log，也在log.cpp的InitLog函数里调用它

249
00:12:16,139 --> 00:12:18,000
我有没有调用这个函数并不重要

250
00:12:18,000 --> 00:12:18,870
所以不用担心

251
00:12:18,870 --> 00:12:20,190
我现在来build我的项目

252
00:12:20,190 --> 00:12:21,179
好了，看看这个

253
00:12:21,179 --> 00:12:25,019
我得到一个错误！告诉我log已经在log.obj中定义了

254
00:12:25,019 --> 00:12:28,149
所以我们得到一个'one or more multiply defined symbels found'的错误信息

255
00:12:28,269 --> 00:12:32,879
这是一个重复符号的错误信息，然而你可以看到，我真的只有一个log的定义

256
00:12:32,879 --> 00:12:34,500
它在这个log.h文件中

257
00:12:34,500 --> 00:12:37,110
为什么它会抱怨有多个符号呢？

258
00:12:37,110 --> 00:12:39,539
这又回到了include语句如何工作的问题

259
00:12:39,539 --> 00:12:40,200
记住

260
00:12:40,200 --> 00:12:41,549
当我们include一个头文件时

261
00:12:41,549 --> 00:12:46,679
也就是把这个头文件的内容放到我们的include语句的位置

262
00:12:46,679 --> 00:12:55,399
所以实际在这里发生的是，它把这个log函数，像这样放到log.cpp这里

263
00:12:55,440 --> 00:13:00,200
然后在这里也是，现在你可以看到我们确实有两个log函数

264
00:13:00,240 --> 00:13:01,590
那么我们如何解决这个问题呢

265
00:13:01,860 --> 00:13:03,029
我们这里有几个选择

266
00:13:03,029 --> 00:13:05,820
我们如果撤回刚才这些操作，也就是再次include log

267
00:13:05,820 --> 00:13:08,909
我们可以把这个log函数标记为static

268
00:13:08,909 --> 00:13:13,149
这意味着对这个log函数链接时链接只应该发生在该文件内部

269
00:13:13,169 --> 00:13:19,250
也就是说，当这个log函数被include在log.cpp中和math.cpp时，只会对该文件内部有效

270
00:13:19,250 --> 00:13:25,950
就像我们对multiply做的一样，基本上，log和math会有它们自己版本的log函数

271
00:13:25,950 --> 00:13:28,679
它对任何其他obj文件都是不可见的

272
00:13:28,679 --> 00:13:30,240
如果我们现在编译这个

273
00:13:30,240 --> 00:13:32,159
你会发现我们没有任何链接错误了

274
00:13:32,159 --> 00:13:34,740
另外一种办法是让它变成

275
00:13:34,799 --> 00:13:39,929
显然inline的意思就是把函数的身体拿过来取代调用

276
00:13:39,929 --> 00:13:40,740
在这种情况下

277
00:13:40,740 --> 00:13:45,269
这个log（“initializedlog”）就会变成这样

278
00:13:46,529 --> 00:13:48,899
所以如果这样做，并且build

279
00:13:48,899 --> 00:13:50,700
你会发现我们也没有错误

280
00:13:50,700 --> 00:13:54,799
我们还有一种方法来解决，这可能是我在这种情况下会做的

281
00:13:54,840 --> 00:13:58,379
这就是把它的定义移动到一个翻译单元中

282
00:13:58,379 --> 00:14:02,909
因为现在所发生的是这个log函数被包含在两个翻译单元中

283
00:14:02,909 --> 00:14:04,740
log.ccp和math.cpp

284
00:14:04,740 --> 00:14:06,509
这就是导致错误的原因

285
00:14:06,509 --> 00:14:09,059
所以我们可以把它移动到第三个翻译单元

286
00:14:09,059 --> 00:14:13,110
或者我们可以把这个log定义放到一个现有的翻译单元中

287
00:14:13,110 --> 00:14:17,580
因为这个函数被称log且跟logging有关，我将把它放进log.cpp

288
00:14:17,580 --> 00:14:21,129
我拿到这个函数，复制到log.cpp

289
00:14:21,179 --> 00:14:28,600
我将去掉inline，然后回到log.h，然后只留下声明，当然也删掉inline

290
00:14:28,710 --> 00:14:31,320
现在这个头文件只有log的声明

291
00:14:31,320 --> 00:14:38,879
实际链接的log函数只在logcpp中include了一次，只出现在了一个翻译单元里

292
00:14:38,879 --> 00:14:40,620
然后main会调用它

293
00:14:40,620 --> 00:14:41,820
如果我build这个

294
00:14:41,820 --> 00:14:45,750
我们没有链接错误，我们的项目能够成功地链接起来

295
00:14:45,750 --> 00:14:49,860
就是这样拉，基本上这就是个关于linking和linking如何工作的速成课程了

296
00:14:49,860 --> 00:14:56,639
记住，到头来链接器就是要编译过程中生成的所有对象文件链接起来

297
00:14:56,639 --> 00:14:59,879
它还会导入我们可能使用的其他库

298
00:14:59,879 --> 00:15:07,450
例如C运行时库，C++标准库，如果有需要，我们的平台API，还有很多其他的东西

299
00:15:07,500 --> 00:15:09,990
从许多不同的地方链接是很常见的

300
00:15:09,990 --> 00:15:11,429
然后也有不同类型的链接

301
00:15:11,429 --> 00:15:13,769
我们有静态链接，还有动态链接

302
00:15:13,769 --> 00:15:15,809
但我还是把它留到另一个视频里

303
00:15:15,809 --> 00:15:16,559
谢谢收看

304
00:15:16,559 --> 00:15:17,940
我希望你喜欢这个视频

305
00:15:17,940 --> 00:15:19,230
如果你还有其他问题

306
00:15:19,230 --> 00:15:20,940
把它们放在下面的评论区

307
00:15:20,940 --> 00:15:22,320
我将尽我所能回答他们

308
00:15:22,320 --> 00:15:24,509
一定要在Twitter和Instagram上关注我

309
00:15:24,509 --> 00:15:25,710
如果你真的喜欢这个视频

310
00:15:25,710 --> 00:15:28,830
你可以在patreon上支持我，这将帮助我制作更多的视频

311
00:15:28,830 --> 00:15:33,629
而且你也可以接触到视频的早期草稿，并参与到计划过程中

312
00:15:33,629 --> 00:15:35,429
但是一如平常，下次再见

313
00:15:35,429 --> 00:15:36,570
再见 foowo！

