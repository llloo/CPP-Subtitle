1
00:00:00,000 --> 00:00:03,475
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:03,774 --> 00:00:05,825
我回到了墨尔本的家中，不再是酒店房间

3
00:00:05,825 --> 00:00:09,800
我在我的工作室，你可以把这里称为工作室

4
00:00:09,800 --> 00:00:12,525
今天我们来学习C++中的数组

5
00:00:12,525 --> 00:00:16,199
在开始学习之前，非常重要的事情是你理解了什么是指针

6
00:00:16,199 --> 00:00:20,969
在之前的视频中我们有讲解过指针(p16)

7
00:00:20,969 --> 00:00:22,600
如果没看就先去看看指针吧

8
00:00:22,600 --> 00:00:26,699
指针是C++数组如何工作的基础知识，所以你一定要先明白指针是什么

9
00:00:26,699 --> 00:00:28,399
首先，数组是什么？

10
00:00:28,399 --> 00:00:33,170
数组是一些元素的集合，是一些按照特定顺序排列的东西

11
00:00:33,170 --> 00:00:37,939
在我们的例子中，数组基本上就是用来表示存放一堆变量的集合

12
00:00:37,939 --> 00:00:42,149
通常来说，存放的都是相同的类型

13
00:00:42,149 --> 00:00:50,625
数组非常重要和有用的原因是因为
有非常多的场景我们想要去表示一大堆数据的整个集合

14
00:00:50,625 --> 00:00:57,000
创建一大堆的变量对我们来说是没有意义的，这些数据应该被放在一个数据集里

15
00:00:57,000 --> 00:01:02,975
因为变量是需要手动创建的，我们要到代码中设置变量然后给它们一个变量名

16
00:01:02,975 --> 00:01:08,525
假设有时候我们想要去存储代表某种数据的50个整数

17
00:01:08,525 --> 00:01:13,875
我们肯定不想手动指定数字一，数字二... 这样子一直到数字五十。

18
00:01:13,875 --> 00:01:20,275
因为首先这太恐怖了，完全不可行而且没办法维护

19
00:01:20,275 --> 00:01:26,650
想像一下，把这些变量设置为0，你必须要去写50行代码手动把它们一一设置为0

20
00:01:26,650 --> 00:01:29,950
处理这么多的变量是非常非常麻烦的

21
00:01:29,950 --> 00:01:35,250
所以在这种场景下我们需要用一个数组同时去包含所有这些50个相同类型的元素

22
00:01:35,250 --> 00:01:38,375
这样子处理起来就会非常非常轻松

23
00:01:38,375 --> 00:01:43,174
请记住一个数组就像在一个变量里有很多个变量

24
00:01:43,174 --> 00:01:48,950
我们给数组一个名字，这样我们就可以指向这些我们在一个数组里创建的变量了

25
00:01:48,950 --> 00:01:50,525
让我们来写些代码看看

26
00:01:50,525 --> 00:01:54,474
定义数组很简单，假如我想要一个包含5个整数的数组

27
00:01:54,599 --> 00:02:02,650
我只要先写上我要的类型，给它一个名字example，然后方括号中写上数组大小，写入5

28
00:02:02,650 --> 00:02:07,174
就是这样，我现在有个包含5个整数的数组了

29
00:02:07,174 --> 00:02:10,474
而且分配了足够的空间来存储这5个整数

30
00:02:10,474 --> 00:02:17,824
现在为了设置和访问这些整数，我可以写下数组的名字，
然后在方括号里写上一个叫索引的东西

31
00:02:17,824 --> 00:02:22,594
索引代表我正在指向数组中的哪一个元素或变量

32
00:02:22,594 --> 00:02:27,125
指向第一个我们要写0，因为C++中的索引是从0开始的

33
00:02:27,125 --> 00:02:31,525
有些语言，比如说Lua是从1开始的，这是很奇怪的事

34
00:02:31,525 --> 00:02:36,295
一般来说索引都是从0开始的，也就是说0代表第一个元素

35
00:02:36,295 --> 00:02:40,025
因为它是整形的，所以我们可以在这里把它设置为任何整数

36
00:02:40,025 --> 00:02:49,900
当我们通过特定索引访问其中一个元素时，我们得到的就是这个数组的类型，这里是整形

37
00:02:49,900 --> 00:02:51,275
比如说，我们可以把它设置为2

38
00:02:51,275 --> 00:02:56,199
你可以注意到我们给它分配了5个整形空间，但是第一个索引是0

39
00:02:56,375 --> 00:03:02,675
这意味这既然我们有5个整形，那么最后一个索引就应该是4而不是5

40
00:03:02,675 --> 00:03:09,000
因为索引5实际上指向第六个元素，让我们把它设置为4，暂时先不设置其他元素

41
00:03:09,199 --> 00:03:16,599
读取这些元素很简单，如果我想打印一个元素，只需要像这样指明要打印的索引

42
00:03:17,050 --> 00:03:25,275
如果你想打印这个数组，那只会打印出它的内存地址，因为它实际上是一个指针

43
00:03:25,625 --> 00:03:31,500
我之前提过，当你索引一个数组中的元素时，你会得到底层的数据类型
所以在这个例子中是一个整形

44
00:03:31,599 --> 00:03:39,074
所以我可以创建一个新变量，然后从数组中复制这个值给这个新变量
你可以看到这个数据类型就是整形

45
00:03:39,419 --> 00:03:48,699
如果我要访问一个不在数组中的索引，比如-1或者5

46
00:03:49,574 --> 00:03:54,650
我们把这叫做内存访问冲突(memory access violation)
因为我正在尝试访问不属于我的内存

47
00:03:54,650 --> 00:04:00,625
在debug模式下，你会得到一个程序崩溃的错误来帮助你调式这些问题


48
00:04:00,724 --> 00:04:06,574
但是在release模式下，你可能不会收到错误，这意味着你已经改动了不属于你的内存

49
00:04:06,599 --> 00:04:12,025
你要非常小心这个问题，并且确保总是在数组边界内操作，这很重要


50
00:04:12,025 --> 00:04:17,774
如果不这样，会产生很难调试的问题，因为你只是修改了不属于这个数组的内存

51
00:04:17,774 --> 00:04:29,975
但这个内存属于代码中其他变量的一部分，
相当于你只是在代码里无意识修改了其他变量

52
00:04:30,399 --> 00:04:35,725
所以要确保你设置了安全检查，确保操作没有越界

53
00:04:35,725 --> 00:04:38,800
我们会在以后更多的讨论这些问题

54
00:04:39,100 --> 00:04:46,074
数组总是伴随着for循环，因为for循环可以在特定范围内使用索引进行便利

55
00:04:47,125 --> 00:04:52,324
所以如果我们想要设置数组中的每个值，一个很好的方式就是通过for循环实现

56
00:04:52,550 --> 00:04:57,120
如果没有for循环，我们就必须通过所有的索引然后手动设置它们

57
00:04:57,649 --> 00:04:59,600
这就是我如何将数组所有元素设置为2

58
00:04:59,774 --> 00:05:04,774
但是通过for循环，遍历整个数组的长度，就是5

59
00:05:04,925 --> 00:05:08,475
然后设置example[i]=2就行了

60
00:05:08,739 --> 00:05:17,050
我们所做的就是遍历整个数组，就是遍历索引从0到4，因为索引4是小于5的最后一个值

61
00:05:17,250 --> 00:05:21,800
我们也可以写小于等于4，但是没有人会这么写

62
00:05:22,000 --> 00:05:26,083
而且这样写也有性能问题，因为你在做的是小于和等于比较

63
00:05:26,300 --> 00:05:29,774
那样它必须同时要做比较是否等于的操作，而不只是小于操作

64
00:05:29,800 --> 00:05:34,699
所以一般都是写成小于5，而不是小于等于4

65
00:05:34,875 --> 00:05:37,899
如果我们运行代码，在这里打上断点

66
00:05:38,033 --> 00:05:40,925
我们可以看看内存中实际是什么样子的

67
00:05:41,122 --> 00:05:45,324
看下内存视图，如果你想知道关于内存视图更多内容

68
00:05:45,324 --> 00:05:47,375
我之前有做过一个关于C++调试的视频里有说过(p11) 

69
00:05:47,649 --> 00:05:54,381
在这里，我要找到数组的内存地址，example 就是一个内存地址，因为example是一个整形指针

70
00:05:54,774 --> 00:06:01,824
所以我要在这里输入example，你可以看到我得到了一行的2

71
00:06:02,050 --> 00:06:08,550
有关数组很重要的一点就是数组中的数据是连续的
就是说它们把数据放在了一行

72
00:06:08,600 --> 00:06:13,875
我给5个整形分配了空间，意味着我把它们一个接着一个放进内存中

73
00:06:14,199 --> 00:06:21,350
每个整形都是4个字节，所以我在这里得到了
一行被分成几个4字节的20字节的内存

74
00:06:21,588 --> 00:06:26,588
不是真的被分成了4字节，但是当我们通过代码访问它

75
00:06:26,887 --> 00:06:32,399
我们的目的就是为了把它分成4字节段 尽管并不是字面意义上的分割

76
00:06:32,650 --> 00:06:39,399
这就是你再内存视图里看到的，有5个2，每个都占了4个字节因为它们是整形

77
00:06:39,625 --> 00:06:46,475
当我们通过特定的索引example[i]来访问时，这其实是对这段内存做了个偏移

78
00:06:46,850 --> 00:06:53,600
如果我用example[2],它会从数组开头的地方开始，你可以看到就是这个内存地址

79
00:06:53,824 --> 00:06:58,199
它只需要加上8字节，因为每个整形有4个字节

80
00:06:58,479 --> 00:07:03,479
我们想要访问“元素2”，其实它是第三个元素,因为索引是从0开始的

81
00:07:03,584 --> 00:07:08,584
所以”元素2“地址偏移就是2乘以每个元素大小，所以在这里是2乘以4

82
00:07:08,904 --> 00:07:12,250
从这里向后8个字节就到这里的这个整数

83
00:07:12,477 --> 00:07:18,225
如果我们给example[2]写入一个值，就会被写入内存里这个位置

84
00:07:18,500 --> 00:07:21,300
我说过一个数组就只是一个指针，


85
00:07:21,541 --> 00:07:26,725
在这里它是一个指向包含5个整数的内存块的整形指针

86
00:07:27,053 --> 00:07:33,149
这意味着我可以在这里创建一个整形指针类型的变量，并把example赋值给它

87
00:07:33,350 --> 00:07:37,975
你看它可以正常工作，也能通过编译，因为example就是一个整形变量

88
00:07:38,194 --> 00:07:47,324
像我之前说的，访问元素2号，然后给它赋值为5，结果就是会写入从指针偏移8字节的内存中

89
00:07:47,675 --> 00:07:56,250
这里的代码可以使用指针重写，实际上就是指针加2，
因为我们要向前访问2个元素

90
00:07:56,629 --> 00:08:00,225
然后解引用，把它设为6

91
00:08:00,875 --> 00:08:06,050
我们把for循环移到前面，然后看这里，我要加个断点

92
00:08:06,774 --> 00:08:10,175
如果我访问example,它是数组的内存地址

93
00:08:10,175 --> 00:08:17,699
 你可以看到第三个元素被设置为5，然后我按F10,它就会被设置为6

94
00:08:18,975 --> 00:08:25,324
我之前说加8字节，但是指针这里我们写的是+2

95
00:08:25,524 --> 00:08:31,274
这么做是因为，处理指针时，只要在指针上加上像2这样的值

96
00:08:32,075 --> 00:08:34,174
它会根据数据类型来计算实际的字节数

97
00:08:34,424 --> 00:08:41,350
所以在这里因为这个指针是整形指针
所以会是加上2乘以4，因为每个整形是4字节

98
00:08:41,600 --> 00:08:47,524
如果我真的想用字节来处理，
我可以把这个指针转换成一个字节大小的类型，比如说char

99
00:08:48,000 --> 00:08:51,799
如果我这么做，那我必须要加上刚才说过的8字节

100
00:08:52,108 --> 00:08:56,250
因为我想写的是一个4字节的整数而不是一字节的char

101
00:08:56,475 --> 00:09:03,524
一旦我加上了8，那么我还需要把它转换回int指针类型
当然现在这个指向就是整形了

102
00:09:03,725 --> 00:09:07,500
我可以把它设置为6，这代码很奇怪，我们来检查下。

103
00:09:07,744 --> 00:09:11,325
当我按F5，然后去看example,你可以看到它被设置为5

104
00:09:11,549 --> 00:09:14,674
当我在按F10，你可以看到我们得到了和之前完全相同的结果，它被设置为6

105
00:09:15,000 --> 00:09:21,600
是的，你可以像这样写的很花哨，但本质上我在这里写的就是这个索引

106
00:09:21,725 --> 00:09:25,524
这不是魔法，这就是数组的工作原理 它就是一个连续的数据块

107
00:09:25,750 --> 00:09:30,382
你可以把他们当作一本字典一样去索引它们，然后写入到特性的页面

108
00:09:30,382 --> 00:09:32,000
在这个例子里是个具体的整数

109
00:09:32,225 --> 00:09:37,289
我马上要把这段代码删掉，因为我不想把数组讲的太深入免得对你们造成困惑

110
00:09:37,299 --> 00:09:39,649
你还可以在堆上创建一个数组

111
00:09:39,825 --> 00:09:43,100
我们还没有讨论过堆和栈，以及内存的真正工作原理

112
00:09:43,100 --> 00:09:45,399
我很快就会讲到它们

113
00:09:45,601 --> 00:09:52,375
就像我们用new关键字来创建类的实例，我们也可以用new在这里创建一个数组

114
00:09:52,625 --> 00:10:01,049
把它叫做another, int*类型，然后把它设置为 new int[],方括号里是数组的大小

115
00:10:01,149 --> 00:10:02,174
我还是设置为5

116
00:10:02,252 --> 00:10:06,375
这行代码和之前的是同一个意思， 但是它们的生存期是不同的

117
00:10:06,600 --> 00:10:11,600
这个是创建在栈上的，它会在跳出这个作用域时被销毁

118
00:10:11,700 --> 00:10:18,346
但是因为这个是创建在堆上的
实际上它会一直存活到直到我们把它销毁或者程序结束

119
00:10:18,471 --> 00:10:21,149
所以你需要用delete关键字来删除它

120
00:10:21,322 --> 00:10:25,750
而且因为这是一个数组，我们用数组操作符来分配内存

121
00:10:25,750 --> 00:10:28,149
我们使用了new关键字和方括号

122
00:10:28,401 --> 00:10:31,274
所以我们也要用delete和方括号来删除它

123
00:10:31,697 --> 00:10:36,049
让我们把for循环加回来，把它设置为2

124
00:10:36,215 --> 00:10:43,049
对another数组也做同样的操作：another[i]=2

125
00:10:43,269 --> 00:10:47,075
当然我也可以把它们写在一个for循环里 but...

126
00:10:47,524 --> 00:10:51,725
按F5，如果在这里输入example，在内存视图里我会得到5个2在同一行

127
00:10:52,225 --> 00:10:55,424
当然如果我们输入another,我也会得到相同的结果

128
00:10:55,600 --> 00:10:59,899
那为什么要使用new关键字来动态分配，而不是在栈上创建它们呢？

129
00:10:59,931 --> 00:11:02,924
最大的原因是因为生存期

130
00:11:03,100 --> 00:11:07,174
因为new分配的内存，会一直存在，直到你手动删除它

131
00:11:07,350 --> 00:11:16,024
如果你有个函数要返回新创建的数组，那么你必须要使用new来分配，
除非你传入的参数是一个内存地址

132
00:11:16,625 --> 00:11:22,575
如果你想返回的是在函数内新创建的数组，那你就要用new关键字来创建。

133
00:11:22,700 --> 00:11:25,649
另一件要考虑的是memory indirection(内存间接寻址) 

134
00:11:25,649 --> 00:11:32,875
我的意思是，我们有个指针，指针指向另一个保存着我们实际数组的内存块
p -> p -> array

135
00:11:32,875 --> 00:11:40,424
这会产生一些内存碎片和缓存丢失
所有这些复杂的情况我们会在以后的视频中讲到

136
00:11:40,674 --> 00:11:42,799
但是我要给你看一个简单的例子，你就能明白我的意思了

137
00:11:43,039 --> 00:11:47,700
如果我在这里创建一个叫Entity的类，然后把Example数组移到这里

138
00:11:47,873 --> 00:11:53,725
我还要创建一个构造函数，基本上就是我的for循环，用来初始化所有值为2

139
00:11:53,909 --> 00:11:57,799
然后把这些都设为public，如果我像这样创建Entity

140
00:11:58,030 --> 00:12:00,325
删除其他的代码，按F5

141
00:12:00,642 --> 00:12:04,799
如果我们查看Entity e的内存地址，回车

142
00:12:04,971 --> 00:12:07,774
你可以看到我获取到了我的内存情况

143
00:12:08,041 --> 00:12:13,625
Entity的内存上实际就是一行，包含了数组中所有的2，所有的数据都在这儿

144
00:12:13,750 --> 00:12:19,674
但是如果我在这里使用new关键字在堆上创建，运行相同的代码

145
00:12:19,902 --> 00:12:25,100
进入Entity的内存地址，你可以看到这里根本没有2

146
00:12:25,325 --> 00:12:28,375
我看到另一个内存地址， 其实这就是个指针

147
00:12:28,524 --> 00:12:35,674
我可以复制然后粘贴到这里，因为endian(字节序)的原因
我必须要反转它们: 007d5eb8

148
00:12:37,274 --> 00:12:40,649
回车，我得到了我真正的数据

149
00:12:41,125 --> 00:12:42,725
这就是memory indirection(内存间接寻址)

150
00:12:42,950 --> 00:12:47,500
我们在e地址上实际上得到的另一个地址，这个地址指向我们实际的数组

151
00:12:47,855 --> 00:12:51,850
这意味着如果我们要访问这个数组，我们基本上要在代码里跳来跳去

152
00:12:52,084 --> 00:12:55,674
先找到Entity，然后再找到数组，就是这样子

153
00:12:55,947 --> 00:12:59,174
如果可以你应该在栈上创建数组来避免这种情况

154
00:12:59,250 --> 00:13:02,774
因为像这样在内存里跳跃肯定会影响性能

155
00:13:02,799 --> 00:13:04,975
现在我还想说另一件事

156
00:13:05,286 --> 00:13:09,549
我知道这个视频很长，你可能没时间来看这么长的视频

157
00:13:09,611 --> 00:13:12,200
但是我还想说下C++11里的数组

158
00:13:12,398 --> 00:13:19,250
C++11中有std::array, 这是一个内置数据结构，定义在C++11的标准库中

159
00:13:19,460 --> 00:13:24,725
很多人喜欢用它来代替这里的原生数组，因为他有很多优点

160
00:13:24,993 --> 00:13:29,649
它有边界检查，有记录数组的大小

161
00:13:29,975 --> 00:13:34,075
另外我没提到的一点是，实际上我们没有办法计算原生数组的大小

162
00:13:34,307 --> 00:13:38,399
如果我们像这样在堆上分配一个数组，大小为5

163
00:13:38,614 --> 00:13:45,674
在一些他语言中，我们可以写example->size(), C++里你不能这么做

164
00:13:46,075 --> 00:13:50,750
你没办法知道数组的大小，虽然我说不可能(no way)

165
00:13:51,064 --> 00:13:53,924
但显然还是有一些方法

166
00:13:54,151 --> 00:14:01,475
因为当你删除这个数组时，编译器要知道实际上需要释放多少内存

167
00:14:01,746 --> 00:14:07,825
是的，有一种方法就是通过依赖编译器，它有可能会在数组中存储一个负索引

168
00:14:07,995 --> 00:14:13,100
比如-1，这取决于很多东西，而且很...

169
00:14:13,341 --> 00:14:18,975
你不能相信它，所以你应该永远都不要在数组内存中访问数组的大小

170
00:14:19,143 --> 00:14:20,125
这很危险

171
00:14:20,252 --> 00:14:23,975
如果你在栈上分配一个数组：int a[5];

172
00:14:24,075 --> 00:14:25,350
你不知道他的实际大小

173
00:14:25,405 --> 00:14:30,299
因为它是在栈上分配的，也就是说这是栈上的地址加上偏移量

174
00:14:30,299 --> 00:14:35,375
所以如果你写sizeof(a)，你得到的实际上是这个数组占了多少字节

175
00:14:35,375 --> 00:14:40,600
在这里int是4个字节，我们有5个元素，所以是20个字节

176
00:14:40,728 --> 00:14:42,049
这个会返回20字节

177
00:14:42,334 --> 00:14:47,500
如果你想知道有多少个元素，可以用它除以数据类型的大小 就是int

178
00:14:47,500 --> 00:14:51,500
这些代码会计算出元素的数量

179
00:14:51,625 --> 00:14:53,625
我喜欢称它为count而不是size

180
00:14:53,870 --> 00:14:59,299
就个人来说，说size我指的是字节数，说count我指的是元素的数量

181
00:14:59,500 --> 00:15:04,450
所以这里会返回5，也就是元素的数量

182
00:15:04,774 --> 00:15:13,674
但是如果你用example做同样的事，你再这里得到的实际上是一个整形指针的大小，就是4字节

183
00:15:13,950 --> 00:15:20,399
4/4 就是1 (作者口误)

184
00:15:20,624 --> 00:15:21,924
无论如何这肯定是错误的

185
00:15:22,123 --> 00:15:25,350
所以你只能在栈分配的数组上用这个技巧

186
00:15:25,603 --> 00:15:33,950
如果你把它改成栈分配的数组，这也能工作，但是你真的不能相信这个方法

187
00:15:34,049 --> 00:15:40,549
当你把它放在函数或者它变成了指针，那你完蛋了

188
00:15:40,750 --> 00:15:43,750
所以你要做的就是自己维护数组的大小

189
00:15:43,993 --> 00:15:48,993
我知道这样很麻烦，但是C++里它就是这么工作的，你必须自己去维护它

190
00:15:48,993 --> 00:15:50,575
个人来说，我会这样写

191
00:15:50,740 --> 00:15:55,975
我会声明一个常量size为5，然后放到这里

192
00:15:56,125 --> 00:15:58,975
报错了，不能这么做

193
00:15:59,049 --> 00:16:03,700
因为当你在栈中为数组申请内存时 它必须是一个编译时就需要知道的常量

194
00:16:03,700 --> 00:16:09,325
这里要打个星号，因为这是C++,有个问题我们会在以后的视频讲到

195
00:16:09,544 --> 00:16:11,274
但是这个值必须要在编译时就知道

196
00:16:11,408 --> 00:16:15,950
所以你必须要用static标记，这里还可以用constexpr表达式

197
00:16:16,146 --> 00:16:18,875
类中的常量表达式必须时静态的

198
00:16:19,087 --> 00:16:21,600
这些你可以在另一个视频中看到

199
00:16:21,825 --> 00:16:26,975
 这集视频有很多的关联内容，因为我们将要进入真正有趣的东西
希望你们会感兴趣

200
00:16:27,174 --> 00:16:32,174
加上static，其实也不需要用constexpr，这就是我的处理方法

201
00:16:32,174 --> 00:16:38,174
在这个例子中，可以写成exampleSize，因为它是专门来处理example的

202
00:16:38,174 --> 00:16:44,200
然后就可以把这些放进for循环，就可以知道你的数组的大小了，这就是你要做的

203
00:16:44,390 --> 00:16:49,325
如果你用的是C++11的std::array,你要怎么做？

204
00:16:49,325 --> 00:16:54,875
你只要写std::array, 确保写了#include <array>

205
00:16:55,098 --> 00:17:01,200
给它命名，比如说another，还要给它一个类型和大小

206
00:17:01,387 --> 00:17:08,549
我们需要类型和大小，所以写int, 5

207
00:17:08,549 --> 00:17:13,650
这样就创建了个数组，然后要填满它，我们可以写another.size()

208
00:17:13,875 --> 00:17:16,799
这样就好了 这是一种很简单的处理方法

209
00:17:16,799 --> 00:17:21,224
当然这会有额外开销，因为如果你想的话它会做边界检查

210
00:17:21,349 --> 00:17:25,525
它实际上也维持一个整数size，也许你并不需要这个

211
00:17:25,768 --> 00:17:28,549
所以这有一些额外开销，通常这是值得的

212
00:17:28,924 --> 00:17:35,450
如果你想用着个，
当我们最终讲到数据结构我们会有一整个视频来件讲它是如何工作的

213
00:17:35,631 --> 00:17:37,400
还是有些值得思考的事

214
00:17:37,617 --> 00:17:41,724
个人而言，我总是用原生的数组，大多数人都这么用，会更快一点

215
00:17:41,969 --> 00:17:44,650
而且我用的时候也并没有遇到什么问题

216
00:17:44,790 --> 00:17:51,325
但是如果你想安全，或者你可能来自另一种语言，你可能就想用std::array

217
00:17:51,950 --> 00:17:58,474
说实话，使用std数组比原生数组是要安全得多，但是我就喜欢危险 :)

218
00:17:58,719 --> 00:18:02,849
希望你们喜欢这个视频，记得点赞

219
00:18:02,849 --> 00:18:07,849
...

