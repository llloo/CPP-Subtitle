1
00:00:02,669 --> 00:00:03,970
我非常喜欢这些枕头。

2
00:00:04,320 --> 00:00:09,320
Hey 大家好! 我是Cherno，欢迎回到我的c++系列。

3
00:00:09,720 --> 00:00:11,550
今天我们又回到了沙发上。

4
00:00:11,800 --> 00:00:15,000
你们这些家伙似乎觉得我没有太多的时间去制作令人激动的视频。

5
00:00:15,410 --> 00:00:18,750
但是，内容将弥补这一点。

6
00:00:18,870 --> 00:00:23,179
因为今天我们将要学习如何使用Visual Studio调试我们的代码。 

7
00:00:23,280 --> 00:00:26,769
 不幸的是，在计划这个系列的时候，我面临着一个艰难的决定。

8
00:00:26,870 --> 00:00:31,870
我试着决定哪个视频在哪里，以什么顺序等等.

9
00:00:32,369 --> 00:00:35,670
很多视频都是相互依赖的。

10
00:00:35,719 --> 00:00:40,719
 如果你看到我在某些视频中提到了我在之前的视频中没有提到的东西，

11
00:00:40,820 --> 00:00:43,549
这并不意味着我忽略了

12
00:00:43,570 --> 00:00:47,329
它只是意味着它可能会晚些时候出现。

13
00:00:47,390 --> 00:00:52,390
尽管如此，调试(Debug)仍然是编程中非常重要的一部分。

14
00:00:52,700 --> 00:00:54,310
而且不仅仅是编程，也是学习的一部分

15
00:00:54,420 --> 00:00:56,350
因为如果你知道如何调试你的代码，

16
00:00:56,359 --> 00:00:58,880
你就会明白这个程序是如何工作的

17
00:00:58,950 --> 00:01:01,950
以及计算机如何运行你的代码。

18
00:01:02,030 --> 00:01:06,250
所以我认为我应该在系列视频的早期就介绍了调试，

19
00:01:06,250 --> 00:01:08,019
因为实际上我将使用很多我们今天介绍的很多内容

20
00:01:08,480 --> 00:01:13,480
来解释其余语言以及计算机程序一般是如何工作的。

21
00:01:13,680 --> 00:01:16,000
在这个视频中，像我所有的c++视频一样，

22
00:01:16,090 --> 00:01:17,719
我将使用Visual Studio。

23
00:01:17,859 --> 00:01:21,829
然而，这些概念几乎适用于任何IDE。

24
00:01:21,879 --> 00:01:25,469
大多数IDE将完全支持我今天在这里展示的内容。

25
00:01:25,629 --> 00:01:27,450
只是可能在不同的地方，

26
00:01:27,510 --> 00:01:31,030
但基本上我们会讲到两个重要的特征…

27
00:01:31,030 --> 00:01:32,950
还是三个?是三吗?我甚至不知道有多少…

28
00:01:33,140 --> 00:01:36,500
我们可以把它分成两部分。

29
00:01:36,659 --> 00:01:37,500
Breakpoints断点

30
00:01:37,579 --> 00:01:41,099
这将是非常有趣的，因为断点是调试的重要部分。

31
00:01:41,099 --> 00:01:42,829
和看内存(memory)。

32
00:01:42,909 --> 00:01:44,849
断点和读取内存

33
00:01:45,000 --> 00:01:47,150
这是调试的两个主要部分。

34
00:01:47,150 --> 00:01:49,579
当然你们会一起使用它们。

35
00:01:49,579 --> 00:01:52,700
换句话说，你需要设置断点来读取内存。

36
00:01:52,700 --> 00:01:54,530
那么调试的意义是什么呢?

37
00:01:54,530 --> 00:01:56,799
我说的调试代码是什么意思?

38
00:01:56,799 --> 00:02:00,420
debug这个词的意思是清除bug，对吧?

39
00:02:00,420 --> 00:02:02,049
从我们的代码中移除bug

40
00:02:02,170 --> 00:02:04,030
为了从我们的代码中移除一个bug，

41
00:02:04,030 --> 00:02:06,099
我们必须诊断我们的程序出了什么问题，

42
00:02:06,129 --> 00:02:08,449
这部分其实很棘手，

43
00:02:08,539 --> 00:02:10,780
即使你对这门语言很有经验。

44
00:02:10,819 --> 00:02:14,250
不管怎么说，你必须记住电脑总是正确的

45
00:02:14,349 --> 00:02:16,699
我说的“总是”是指99%的情况下。

46
00:02:16,750 --> 00:02:21,750
不太可能你做对了但电脑不像预期的那样工作了。

47
00:02:21,860 --> 00:02:24,629
通常是你犯了错。

48
00:02:24,699 --> 00:02:28,150
并逐渐意识到这对程序员来说是非常重要的。

49
00:02:28,259 --> 00:02:31,319
你很快就会发现，电脑几乎总是对的。

50
00:02:31,439 --> 00:02:33,569
所以这都是关于找出你的错误。

51
00:02:33,650 --> 00:02:34,780
我做错了什么？

52
00:02:34,879 --> 00:02:37,000
我做了什么该受这样的惩罚?

53
00:02:37,199 --> 00:02:39,180
所以让我们接下来学习断点和读取内存

54
00:02:39,259 --> 00:02:41,719
这里我有一个非常简单的Visual Studio项目。

55
00:02:41,780 --> 00:02:44,349
这里是主文件，调用log。

56
00:02:44,360 --> 00:02:46,819
这是“Log.cpp”和“Log.h”

57
00:02:46,879 --> 00:02:49,629
就是我们之前讲c++头文件的时候写的。

58
00:02:49,719 --> 00:02:52,530
我们首先要做的是设置一个断点，

59
00:02:52,610 --> 00:02:54,599
然后我们将逐步执行一个程序。

60
00:02:54,710 --> 00:02:56,449
所以什么是断点？

61
00:02:56,460 --> 00:03:01,460
断点是程序中调试器会中断的一个点，

62
00:03:01,740 --> 00:03:04,569
break在这里的意思是暂停。

63
00:03:04,639 --> 00:03:09,639
我们可以在程序的任何一行代码上设置断点。

64
00:03:09,919 --> 00:03:14,849
当执行到达这一行时，它会暂停。

65
00:03:14,900 --> 00:03:19,129
它将悬停该执行线程，或者在我们的例子中，悬停整个程序。

66
00:03:19,189 --> 00:03:22,199
让我们来看看这个项目的状态。

67
00:03:22,240 --> 00:03:24,650
状态，实际上指的是内存。

68
00:03:24,710 --> 00:03:29,710
我们可以暂停程序，看看它的内存中发生了什么。

69
00:03:30,240 --> 00:03:33,780
记住，一个正在运行的程序的内存几乎就是它的全部。

70
00:03:33,849 --> 00:03:36,400
它是每个变量被设置的值。

71
00:03:36,439 --> 00:03:38,430
它是下一个要调用的函数。

72
00:03:38,610 --> 00:03:43,610
内存就是一切。

73
00:03:43,930 --> 00:03:50,750
所以在诊断程序的问题时，能够查看内存是非常有用的。

74
00:03:51,159 --> 00:03:54,530
因为通过查看内存，你可以看到每个变量被设置成什么样子

75
00:03:54,590 --> 00:03:57,900
就像“嘿，这个变量不应该设为这个值”

76
00:03:57,969 --> 00:03:59,099
“显然是错误的。”

77
00:03:59,270 --> 00:04:02,629
你还可以逐行执行程序，

78
00:04:02,689 --> 00:04:06,569
我可以在第5行放一个断点，然后点击一个按钮

79
00:04:06,669 --> 00:04:11,150
程序只会将一行代码推进到第6行

80
00:04:11,270 --> 00:04:14,750
你也可以直接执行函数，看看它们会把你带到哪里

81
00:04:14,780 --> 00:04:19,069
使用断点可以做的事情太多了

82
00:04:19,120 --> 00:04:21,680
如果你编程却不会用断点，那我都不知道你在干什么。

83
00:04:21,800 --> 00:04:23,100
所以，回到Visual Studio

84
00:04:23,129 --> 00:04:25,480
为了在Visual Studio中设置断点，

85
00:04:25,579 --> 00:04:29,519
你可以按F9，它会在当前这行代码上设置一个断点，

86
00:04:29,629 --> 00:04:32,600
或者你可以点击这个侧边栏，在侧边栏的任何地方。

87
00:04:32,779 --> 00:04:34,879
只需单击一次，就可以设置断点。

88
00:04:35,000 --> 00:04:38,199
显然，如果在第3行设置断点没什么用，

89
00:04:38,259 --> 00:04:41,519
因为第3行没有任何东西会被执行。

90
00:04:41,620 --> 00:04:47,250
所以一定要设置断点在实际执行的代码上。

91
00:04:47,319 --> 00:04:51,050
所以第6行，肯定会被执行，因为这是主函数的第一行代码

92
00:04:51,120 --> 00:04:53,899
然后你所要做的就是通过调试器运行你的代码。

93
00:04:53,949 --> 00:04:56,850
一个提示是确保你处于debug模式，

94
00:04:56,870 --> 00:05:01,050
因为如果你在release模式，编译器实际上会改变代码，

95
00:05:01,129 --> 00:05:05,730
你的断点可能永远不会被执行，因为你的程序被重新安排了

96
00:05:06,100 --> 00:05:09,730
我们以后将更深入地讨论release模式实际上是做什么的。

97
00:05:09,730 --> 00:05:12,800
但要点是，如果正在调试，只要确保处于调试(Debug)模式即可。

98
00:05:12,850 --> 00:05:14,990
如果我们点击本地windows调试器，

99
00:05:15,129 --> 00:05:17,300
它能确保你在运行的时候附加了调试器，

100
00:05:17,420 --> 00:05:27,930
我们的程序将执行，而且你会发现Visual Studio变成了这种不同的交替布局

101
00:05:28,089 --> 00:05:30,930
亮点上有一个大大的黄色箭头

102
00:05:30,930 --> 00:05:35,110
指示当前指令指针所在的位置。

103
00:05:35,329 --> 00:05:38,730
在这里要看的主要区域基本上是这个“继续”(Continue)按钮，

104
00:05:38,800 --> 00:05:41,800
它将像往常一样继续执行程序。

105
00:05:41,850 --> 00:05:43,879
然后这里有一堆按钮，

106
00:05:44,100 --> 00:05:46,699
让我们"step into""step over"或"step out"。

107
00:05:46,930 --> 00:05:50,949
这三个按钮将精确地控制程序接下来会发生什么

108
00:05:51,060 --> 00:05:54,730
所以“step into”会进入当前函数

109
00:05:54,829 --> 00:05:57,199
如果有函数，它就在这行代码中。

110
00:05:57,300 --> 00:06:00,430
所以在这种情况下，如果我进入log。

111
00:06:00,519 --> 00:06:02,750
我们会进入log函数

112
00:06:02,759 --> 00:06:04,600
这样我们就能看到它的作用。

113
00:06:04,769 --> 00:06:09,180
“Step over”将转到当前函数的下一行代码，

114
00:06:09,310 --> 00:06:14,879
“step out”实际上是要跳出当前函数，让我们回到这个函数

115
00:06:15,250 --> 00:06:17,569
在这个例子下，因为这是主函数，

116
00:06:17,699 --> 00:06:19,230
将是C标准库。

117
00:06:19,279 --> 00:06:24,279
你还可以使用F11来step into，F10来step over，Shift+F11来step out。

118
00:06:24,600 --> 00:06:27,129
让我们step into这个log函数，看看会发生什么。

119
00:06:27,170 --> 00:06:29,649
按F11。OK，看看这个。

120
00:06:29,810 --> 00:06:33,050
所以我们进入这个函数，我们在堆栈的最开始。

121
00:06:33,180 --> 00:06:37,850
我们还没有开始执行任何代码，我们只是设置函数堆栈框架

122
00:06:38,000 --> 00:06:41,319
我们可以将鼠标悬停在这个message变量上并检查它

123
00:06:41,389 --> 00:06:43,649
它告诉我们它被设置为“Hello World!”

124
00:06:43,769 --> 00:06:48,399
这就是调试的第二部分，我们在读取内存

125
00:06:48,550 --> 00:06:51,699
如果我按下F10，它会把我们带到这一行代码。

126
00:06:51,860 --> 00:06:58,100
黄色箭头在这行代码上，意味着它还没有执行这行代码。

127
00:06:58,329 --> 00:07:00,300
它就在那里。这是真的。

128
00:07:00,550 --> 00:07:07,699
只要我们按下F10或Shift+F11来退出函数或者F5来继续项目…

129
00:07:07,779 --> 00:07:11,949
只要我们按下其中一个，就会执行那一行代码，甚至更多。

130
00:07:12,009 --> 00:07:14,750
但是黄色箭头表示它在这一行代码上。

131
00:07:14,839 --> 00:07:17,230
它还没有实际执行那行代码

132
00:07:17,269 --> 00:07:22,250
如果我现在打开程序，你可以看到“Hello World!”信息还没有打印出来

133
00:07:22,360 --> 00:07:27,050
但是看看这个，按F10，然后再检查看看。

134
00:07:27,139 --> 00:07:31,019
我们打印了“Hello World!”因为我们把它叫做“std::cout”函数，

135
00:07:31,139 --> 00:07:33,399
它将文本打印到控制台

136
00:07:33,550 --> 00:07:35,199
我们已经执行了那个函数。

137
00:07:35,259 --> 00:07:38,899
通过设置断点和逐步执行我们的程序，

138
00:07:38,949 --> 00:07:42,519
我们可以逐行运行整个程序

139
00:07:42,550 --> 00:07:44,569
这真的很酷很有用

140
00:07:44,839 --> 00:07:46,879
当你试图找出自己做错了什么的时候。

141
00:07:47,000 --> 00:07:49,350
回到这里，如果我们继续按F10

142
00:07:49,550 --> 00:07:52,129
你会看到我们最终会回到我们的主函数。

143
00:07:52,230 --> 00:07:54,930
点击F10会把我们带到主函数的下一行代码，

144
00:07:54,939 --> 00:07:56,550
然后继续下去。

145
00:07:56,699 --> 00:08:04,180
如果我按下F5来继续运行程序，我可以按下回车键来关闭我的程序，就像它在正常运行一样

146
00:08:04,420 --> 00:08:05,480
好吧，这是个很酷的东西。

147
00:08:05,569 --> 00:08:09,850
虽然这看起来很简单，但这就是它的全部。

148
00:08:10,069 --> 00:08:12,250
我的意思是我已经给你们展示了几乎所有的东西。

149
00:08:12,370 --> 00:08:14,230
我会给你们看更多的例子，这样你们就能真正理解，

150
00:08:14,300 --> 00:08:16,480
但这就是它的要点。

151
00:08:16,490 --> 00:08:19,350
我们继续创建一些变量来让事情变得有趣。

152
00:08:19,449 --> 00:08:22,930
我要创建一个整数，叫a，设它等于8。

153
00:08:23,050 --> 00:08:26,069
我要用“a++”，它会使a增加1。

154
00:08:26,290 --> 00:08:27,930
换句话说，它会把a设为9。

155
00:08:28,000 --> 00:08:34,379
我要在这里创建一个C字符串，在控制台输入 const char* string = "Hello";

156
00:08:34,450 --> 00:08:40,480
我要写一个非常基本的for循环来迭代这个字符串，并将每个字符打印在单独的行上。

157
00:08:40,779 --> 00:08:43,769
然后我会在我的log留下“Hello World!”

158
00:08:43,919 --> 00:08:47,730
如果我不设断点运行程序，看看会发生什么

159
00:08:47,860 --> 00:08:52,299
你会看到我们有“Hello”和“Hello World”

160
00:08:52,879 --> 00:08:55,149
好吧。现在我一行一行地来。

161
00:08:55,259 --> 00:08:58,850
所以我想在最上面的int a上设置一个断点，然后按F5

162
00:08:58,980 --> 00:09:01,200
好，我们来看看a是什么。

163
00:09:01,269 --> 00:09:04,700
为什么它是负8.58亿？

164
00:09:04,809 --> 00:09:09,629
好。记住，黄色箭头并不意味着我们运行了这段代码。

165
00:09:09,769 --> 00:09:11,669
我们正要运行它，

166
00:09:11,669 --> 00:09:13,850
但实际上我们还没有执行第6行。

167
00:09:13,850 --> 00:09:16,230
就是实际创建并设置“变量”的那一行。

168
00:09:16,529 --> 00:09:22,250
所以调试器现在给我们显示的是内存

169
00:09:22,250 --> 00:09:24,980
因为我们还没有把这个变量设为任何值，

170
00:09:25,120 --> 00:09:26,879
它只是一个未初始化的内存，

171
00:09:27,000 --> 00:09:30,649
这意味着这个值只是显示给我们，并不是内存实际的值。

172
00:09:30,809 --> 00:09:35,809
这将是一个极好的时间来引出这三个重要的窗口：

173
00:09:35,980 --> 00:09:37,700
Autos, Locals and Watch。

174
00:09:37,700 --> 00:09:43,850
Autos和Locals基本上只是向你展示局部变量或者对你来说重要的变量。

175
00:09:43,919 --> 00:09:47,379
Watch，我们通常用来监控变量。

176
00:09:47,470 --> 00:09:52,230
所以我能做的就是输入变量的名字“a”，然后按下回车键。

177
00:09:52,330 --> 00:09:54,730
你可以看到它显示了a的值。

178
00:09:54,789 --> 00:09:58,769
如果我还想查看“string”是什么，我也可以把它放进去，

179
00:09:58,809 --> 00:10:00,399
它会告诉我“string”是什么。

180
00:10:00,610 --> 00:10:02,830
当然，我们还没有初始化这个内存，

181
00:10:02,929 --> 00:10:05,580
所以它目前完全没用。这只是垃圾。

182
00:10:05,639 --> 00:10:10,230
但是当我们逐步完成我们的项目时，这些值将更新以确定内存中实际存在的内容。

183
00:10:10,269 --> 00:10:15,049
说到内存，实际上有一个视图我们可以用来查看整个程序的内存。

184
00:10:15,129 --> 00:10:16,769
当然，这叫做内存视图。

185
00:10:16,860 --> 00:10:21,000
所以如果我们调试→Windows→内存→内存1

186
00:10:21,090 --> 00:10:23,980
迎接我们的将是这个奇怪的面板

187
00:10:24,090 --> 00:10:26,669
这将显示我们程序的所有内存。

188
00:10:26,799 --> 00:10:29,230
在最左边，我们看到了内存地址。

189
00:10:29,330 --> 00:10:34,330
在中间，我们看到了数据的实际值，它是以十六进制表示的。

190
00:10:34,490 --> 00:10:38,250
在右边，我们看到的是对这些数字的ASCIl解释。

191
00:10:38,379 --> 00:10:44,830
如果你想定位变量a实际存储在程序内存的哪个位置，你需要知道它的内存地址。

192
00:10:44,840 --> 00:10:48,500
要做到这一点，我们只需输入“&”和“a”。

193
00:10:48,539 --> 00:10:52,629
所以变量名前面的&会取到此变量的内存地址。

194
00:10:52,830 --> 00:10:57,830
如果我们回车，就会被带到变量a的内存地址

195
00:10:57,830 --> 00:10:59,649
在这种情况下，就是一大堆C。

196
00:10:59,860 --> 00:11:04,149
所以那个数字，cc，实际上是一个十六进制数。

197
00:11:04,299 --> 00:11:07,669
如果你想知道它的十进制表示，你可以调出计算器。

198
00:11:07,809 --> 00:11:11,830
如果我们切换到程序员视图，我们可以输入十六进制值。

199
00:11:11,840 --> 00:11:17,980
如果我点击十六进制，输入cc，你可以看到它就是：204

200
00:11:18,019 --> 00:11:20,899
所以204，cc，为什么会这样呢?

201
00:11:20,940 --> 00:11:23,299
内存不应该是随机的吗?

202
00:11:23,370 --> 00:11:26,480
一大堆“cc”似乎是特定的

203
00:11:26,570 --> 00:11:28,450
这就是调试模式很酷的地方

204
00:11:28,529 --> 00:11:30,850
以及为什么调试模式会减慢我们的程序

205
00:11:30,870 --> 00:11:34,519
因为编译器会让程序做某些事情，

206
00:11:34,600 --> 00:11:39,250
一些会让我们便于调试的额外的事情。

207
00:11:39,320 --> 00:11:46,200
举个例子，这个内存是一大堆“cc”的事实，意味着它是一个未初始化的堆栈内存。

208
00:11:46,250 --> 00:11:50,769
实际上，编译器知道我们在尝试创建一个变量，

209
00:11:50,769 --> 00:11:52,549
但是我们还没有初始化。

210
00:11:52,649 --> 00:11:57,100
我们要做的就是用cc来填充内存

211
00:11:57,230 --> 00:11:59,879
所以如果我们在调试代码时出错了，

212
00:12:00,029 --> 00:12:01,669
我们可以看看内存。

213
00:12:01,690 --> 00:12:03,399
我们可以看到它被设置为“cc”

214
00:12:03,470 --> 00:12:06,500
我们可以这样说：“当然！我从来没有初始化过那个变量。”

215
00:12:06,600 --> 00:12:08,169
“这就是为什么这一切都错了。”

216
00:12:08,210 --> 00:12:12,919
现在通过做一些额外的事情，比如在初始化内存之前将其设置为“cc”

217
00:12:13,029 --> 00:12:16,649
很明显，我们的程序正在做一些额外的事情所以使速度变慢了

218
00:12:16,759 --> 00:12:18,730
我们不想在release模式中这样做

219
00:12:18,799 --> 00:12:22,049
当我们真正relese我们的程序或发行游戏时，我们不想这样做

220
00:12:22,090 --> 00:12:24,419
但是在调试时，它非常有用。

221
00:12:24,470 --> 00:12:28,519
如果我像这样，按下F10，很多事情将会发生。

222
00:12:28,610 --> 00:12:31,450
你可以在这个Watch窗口中做的另一件事是

223
00:12:31,450 --> 00:12:33,899
右击并选择十六进制显示。

224
00:12:33,980 --> 00:12:38,149
现在你可以看到a的值实际上是一串" C "。

225
00:12:38,269 --> 00:12:42,379
当然，这意味着“a”当前是一个未初始化的堆栈内存。

226
00:12:42,429 --> 00:12:45,919
让我们回到非十六进制显示，按下F10。

227
00:12:45,919 --> 00:12:48,000
一些很酷的事情将会发生。

228
00:12:48,139 --> 00:12:52,100
也就是说，在这个Watch窗口中的值已经变成了8。

229
00:12:52,169 --> 00:12:56,000
它也是红色的，表示它从最后一个断点开始改变。

230
00:12:56,019 --> 00:12:57,480
我们的指令指针向下移动了，

231
00:12:57,509 --> 00:12:59,629
这表明它即将被执行。

232
00:12:59,879 --> 00:13:01,500
这行代码还没有做到这一点

233
00:13:01,590 --> 00:13:02,899
不，不，不！还没有。

234
00:13:02,960 --> 00:13:04,250
但很快就会。

235
00:13:04,440 --> 00:13:06,129
然后如果我们看一下内存视图，

236
00:13:06,149 --> 00:13:10,830
您还可以看到这四个字节(byte)的内存被设置为8。

237
00:13:10,929 --> 00:13:15,299
顺便说一下，我应该提一下这里的每两个数字等于1字节(byte)。

238
00:13:15,419 --> 00:13:18,080
这也是为什么我们用十六进制来表示，

239
00:13:18,379 --> 00:13:23,379
因为如果我们这样做，每两个十六进制数字总是对齐为一个字节内存。

240
00:13:23,620 --> 00:13:28,620
所以我们可以通过观察这个来判断这8个十六进制数字是内存字节，

241
00:13:28,830 --> 00:13:31,519
你可以看到它被设为8。

242
00:13:31,629 --> 00:13:33,580
这就是我们要做的。这就是我们现在所做的。

243
00:13:33,679 --> 00:13:36,379
我们已经暂停了程序，现在看一下它的状态。

244
00:13:36,389 --> 00:13:37,649
我们正在读取它的内存。

245
00:13:37,750 --> 00:13:39,169
如果我再按一次F10，

246
00:13:39,220 --> 00:13:40,019
我们前进了一步。

247
00:13:40,139 --> 00:13:41,600
现在设置为9。

248
00:13:41,700 --> 00:13:43,600
这里也设为9。

249
00:13:43,649 --> 00:13:44,879
酷

250
00:13:44,879 --> 00:13:47,279
你可以看到“string”仍然是未初始化的堆栈内存，

251
00:13:47,279 --> 00:13:48,019
但是看看这个

252
00:13:48,049 --> 00:13:50,769
我要在这行中初始化它，如果我按下F10，

253
00:13:50,990 --> 00:13:54,200
它被初始化，因为这是一个实际的指针，

254
00:13:54,240 --> 00:13:57,350
它还告诉我们那个字符串的内存地址。

255
00:13:57,450 --> 00:14:04,669
如果我从Watch窗口复制这个内存地址，粘贴到我的内存视图中，然后回车。

256
00:14:04,730 --> 00:14:06,419
看，我被带到这些字节，

257
00:14:06,419 --> 00:14:10,980
在ASCIl的解释中，你可以看到它是“Hello”。

258
00:14:11,139 --> 00:14:14,700
有趣的是，如果你继续读下去，

259
00:14:14,750 --> 00:14:19,799
你可以看到，内存中靠近"Hello"的下面有

260
00:14:19,799 --> 00:14:23,480
"Stack around the variable '.' was corrupted（变量周围的堆栈已损坏）"

261
00:14:23,519 --> 00:14:27,399
"The variable '..' is being used without being initialized（变量在未初始化的情况下被使用）"

262
00:14:27,549 --> 00:14:31,659
显然，我们的程序包含了字符串，比如内存中的"Stack around the variable '.' was corrupted"

263
00:14:31,899 --> 00:14:34,480
这在发布(release)模式中是不存在的，

264
00:14:34,639 --> 00:14:39,000
但这是另一个很好的例子，说明在调试模式下实际会发生什么，以帮助您调试程序。

265
00:14:39,039 --> 00:14:42,769
好吧，当然，这里的事情变得非常有趣，因为我们遇到了这个“for”循环。

266
00:14:42,850 --> 00:14:45,419
如果我继续前进会怎么样？

267
00:14:45,600 --> 00:14:49,879
现在我们还没有在本系列中介绍“for”循环或任何类型的控制流语句。

268
00:14:49,950 --> 00:14:52,669
接下来的几段视频可能会解决这个问题。

269
00:14:52,750 --> 00:14:54,500
我真的想先介绍一下调试器

270
00:14:54,659 --> 00:14:58,769
这样我们就可以在将来逐步了解这些控制流语句，看看它们是如何工作的。

271
00:14:58,929 --> 00:15:01,649
而你们就已经知道如何使用这个调试视图了。

272
00:15:01,799 --> 00:15:04,019
但基本上，它会做很多次。

273
00:15:04,129 --> 00:15:08,269
所以如果我们逐步完成这个程序，你可以看到“i”被设置为0

274
00:15:08,350 --> 00:15:11,019
它将从这个字符串中获取索引[0]，

275
00:15:11,019 --> 00:15:13,850
这将是字符串中的第一个字符，

276
00:15:14,169 --> 00:15:15,950
它是一个大写的H。

277
00:15:16,039 --> 00:15:20,200
如果我们按F10键，我们可以将鼠标悬停在“c”上，看它是否设置为“H”。

278
00:15:20,279 --> 00:15:24,149
我们也可以到这儿看看，然后输入“c”

279
00:15:24,399 --> 00:15:26,299
你可以看到，我们现在正在看“c”是什么。

280
00:15:26,490 --> 00:15:29,830
当我按F10键时，它会打印这个字母到控制台。

281
00:15:30,019 --> 00:15:34,350
然后当它回到这个大括号，它将运行这个比较。

282
00:15:34,629 --> 00:15:36,950
如果“i”小于5，它将进行比较。

283
00:15:37,139 --> 00:15:41,379
然后，如果是这样，它会增加“i”，然后跳回到这里。

284
00:15:41,539 --> 00:15:44,750
所以如果我按F10，你可以看到我们跳到这里来做比较。

285
00:15:44,889 --> 00:15:48,580
如果我再按F10，我们就完成了“i++”，i现在是1

286
00:15:48,769 --> 00:15:50,950
我们要重新做同样的事情。

287
00:15:51,049 --> 00:15:57,600
这次“i”是1，所以它将抓取第二个字符，即字母“e”，然后继续。

288
00:15:57,740 --> 00:16:01,480
此时，c等于“e”，在我们的Watch中已经改变了。

289
00:16:01,610 --> 00:16:10,350
如果我们来到这里，输入“&c”并按回车，可以看到显示65，根据ASCII码，这是字母e。

290
00:16:10,370 --> 00:16:13,799
好极了！我可以像这样一直走下去。

291
00:16:13,960 --> 00:16:18,200
现在假设我想退出这个循环函数，跳入log函数

292
00:16:18,379 --> 00:16:20,225
我不关心这个循环后面是什么。

293
00:16:21,519 --> 00:16:23,330
我怎么才能从这个for循环中出来？

294
00:16:23,470 --> 00:16:28,049
如果我尝试跳出或点击Shift +F11，它实际上要退出整个函数。

295
00:16:28,240 --> 00:16:32,250
我不想这样做。我只是想继续运行for循环，然后停在这里。

296
00:16:32,250 --> 00:16:33,230
我该怎么做？

297
00:16:33,379 --> 00:16:37,649
很简单，你所要做的就是在下一个要停止的地方设置一个断点。

298
00:16:37,889 --> 00:16:44,299
如果我点击F5或按此处的继续按钮，它实际上将运行我的程序，直到它到达下一个断点

299
00:16:44,590 --> 00:16:46,129
在本例中，这是一个log函数

300
00:16:46,299 --> 00:16:51,379
所以到现在为止，这个c变量在内存中被设置为“o”

301
00:16:51,509 --> 00:16:53,580
它实际上仍然active，那个内存仍然在，

302
00:16:53,580 --> 00:16:55,919
我们将在未来讨论这个问题。

303
00:16:56,039 --> 00:16:59,269
但是内存被设置为“Hello”一词的最后一个字符。

304
00:16:59,370 --> 00:17:02,919
如果我们带回我们的程序，你可以看到它打印了整个“Hello”。

305
00:17:02,929 --> 00:17:06,500
然后我们就要执行这个“Hello World“log函数。

306
00:17:06,710 --> 00:17:09,970
按F10，我们将跳转到下一行代码。

307
00:17:10,079 --> 00:17:11,599
这里要打印“Hello World”。

308
00:17:11,670 --> 00:17:16,670
现在我们已经暂停了这个程序的执行，因为这里有一个断点，我刚刚按了F10。

309
00:17:16,759 --> 00:17:19,400
所以如果我按回车键，什么都不会发生。

310
00:17:19,470 --> 00:17:24,470
我需要按F5键，然后我们的程序将关闭，因为它仍将检测到按回车键。

311
00:17:24,740 --> 00:17:29,740
就这样，基本调试的一个非常简单的概述。

312
00:17:29,789 --> 00:17:37,880
通过这样我们能做到更多，但在这段视频中展示的是实际如何调试代码的基础

313
00:17:38,059 --> 00:17:41,000
记住，一个程序实际上是由内存组成的

314
00:17:41,500 --> 00:17:48,339
甚至指令指针，我们正在执行的实际代码…

315
00:17:48,339 --> 00:17:50,150
所有这些都存储在内存中。

316
00:17:50,430 --> 00:17:54,920
因此，能够查看内存是最重要的，是我们真正需要的，

317
00:17:55,059 --> 00:18:00,920
并且通过设置断点，它允许我们在给定的时间，在给定的代码行暂停一个程序。

318
00:18:01,099 --> 00:18:06,099
实际上，检查一下它，看看我们所有的变量都设置了什么，

319
00:18:06,240 --> 00:18:09,220
当然，在运行代码时，它会非常有用

320
00:18:09,220 --> 00:18:11,525
希望你们能喜欢这个视频，请记得点赞。

321
00:18:11,525 --> 00:18:26,650
...

