1
00:00:00,000 --> 00:00:03,419
Hey 大家好，我是 Cherno，欢迎回到我的c + +系列。

2
00:00:03,419 --> 00:00:07,669
今天我们继续学些C++面向对象编程，类或者其他内容

3
00:00:07,669 --> 00:00:09,919
我们要讨论的是构造函数

4
00:00:09,919 --> 00:00:11,720
那什么是构造函数？

5
00:00:11,720 --> 00:00:16,800
构造函数是一种特殊的方法，它在类每次实例化的时候运行

6
00:00:16,850 --> 00:00:19,140
用个例子来描述是最好的方法

7
00:00:19,140 --> 00:00:23,140
假设我们要建一个Entity类, 让我们来深入了解下

8
00:00:23,140 --> 00:00:27,399
在这里创建一个Entity类，有两个成员：float X, Y

9
00:00:27,399 --> 00:00:33,399
用来表示entity的位置

10
00:00:33,399 --> 00:00:37,350
如果我创建一个Entity的实例， 然后给它一个print函数

11
00:00:37,350 --> 00:00:42,780
这样它就能把内容输入到控制台

12
00:00:42,780 --> 00:00:48,420
把 X,Y 打印出来

13
00:00:48,420 --> 00:00:52,890
实例话Entity后，调用print函数

14
00:00:52,890 --> 00:00:58,350
运行代码，你可以看到它可以打印出内容 好像是一些随机值

15
00:01:00,310 --> 00:01:06,980
这是因为当我们实例化Entity类并且分配内存的时候，但实际上还没有对内存进行初始化

16
00:01:06,980 --> 00:01:11,219
就是说内存空间还是原来的内容

17
00:01:11,219 --> 00:01:16,530
我们想做的可能就是初始化内存并把它设置为0

18
00:01:16,530 --> 00:01:20,989
这样我们的位置默认就是0，而我们并不用显示的去指定一个值

19
00:01:20,989 --> 00:01:26,500
以后我会做一个关于类初始化的深度讲解视频，这里还是说的简单点。

20
00:01:26,500 --> 00:01:30,379
另一个很好的例子是，如果我们想手动打印 X和Y

21
00:01:30,379 --> 00:01:35,840
因为它们是公有的，所以我可以使用e.X直接把X打印出来

22
00:01:36,299 --> 00:01:41,969
如果我们编译代码，会得到一个“uninitialized local variable”的报错信息

23
00:01:41,969 --> 00:01:47,769
换句话说，这个代码都不能通过编译，因为我们在尝试使用未初始化的没存

24
00:01:47,769 --> 00:01:53,129
这个print函数芮苒可以通过编译，但是它并没有像我们期望的那样运行，当然这是因为它在打印X和Y

25
00:01:53,129 --> 00:01:55,859
虽然它们好像都被设置为随机值

26
00:01:55,859 --> 00:01:58,950
我们已经知道要做的就是需要做某种初始化

27
00:01:58,950 --> 00:02:07,079
我们需要某种在我们创建Entity实例的时候就会自动把X和Y设置为0的方法，除非我们显示地设置为其他值

28
00:02:07,079 --> 00:02:10,710
可能你想做的就是创建一个初始化方法

29
00:02:10,710 --> 00:02:16,379
因此我们来创建一个Init方法，这是一个void方法，它的工作就是设置X和Y得值为0

30
00:02:17,360 --> 00:02:21,520
现在我能做的就是当我创建Entity的时候，调用e.Init()

31
00:02:22,050 --> 00:02:26,389
然后调用print尝试进行打印，你会看到打印出了0

32
00:02:26,389 --> 00:02:32,150
当我调用print方法的时候，打印出了0，0 这就意味着X和Y被设置为0了

33
00:02:32,310 --> 00:02:37,030
但是我们添加了太多的代码，我们必须定义这个Init方法

34
00:02:37,030 --> 00:02:42,569
然后每当我要创建一个Entity的时候我都必须要去调用Init函数

35
00:02:42,569 --> 00:02:45,789
这代码非常冗余而且一点也不清爽

36
00:02:45,789 --> 00:02:51,710
如果当我们创建Entity的时候能自动运行这个初始化方法就好了

37
00:02:51,710 --> 00:02:56,750
那就是构造函数，它是一种特殊类型的方法，主要就是用在这里

38
00:02:56,750 --> 00:03:00,090
每当你创建一个对象的时候它就会被调用

39
00:03:00,090 --> 00:03:04,300
我们可以就像定义其他方法一样去定义它，不同的是构造函数没有返回类型

40
00:03:04,300 --> 00:03:07,180
而且它的命名必须和类名一样

41
00:03:07,180 --> 00:03:11,229
写Entity的构造函数是，先输入类名：Entity

42
00:03:11,229 --> 00:03:17,189
我可以给它一个参数或者不给，这个我们会在后面讲到，然后是函数体。

43
00:03:17,189 --> 00:03:23,110
在这里，我可以设置 X=0， Y=0，删掉Iinit方法

44
00:03:23,159 --> 00:03:26,909
在下面这里, 我们不用再去调用Init方法

45
00:03:26,909 --> 00:03:32,919
运行代码，你可以看见我们得到了和运行Init函数是相同的结果

46
00:03:32,919 --> 00:03:36,539
但是我们现在已经不需要Init方法了，可以用构造函数来替代它。

47
00:03:36,590 --> 00:03:40,050
如果你不指定构造函数，你仍然有一个构造函数。
If you don't specify constructor, you still have a constructor.

48
00:03:40,050 --> 00:03:44,590
这叫做默认构造函数(default constructor), 是默认就有的

49
00:03:44,639 --> 00:03:49,560
但是这个默认构造函数什么都没干，它大约就等于这样(空函数体)，它什么都没做

50
00:03:49,560 --> 00:03:52,069
没有初始化变量

51
00:03:52,069 --> 00:03:57,650
在Java中，基本数据类型中，比如int和float类型会默认被初始化为0

52
00:03:57,650 --> 00:04:03,360
但是C++中不是这样的. 你必须手动初始化所有的基本类型

53
00:04:03,360 --> 00:04:07,530
不然，它们就会被设置为之前留存在内存中的值

54
00:04:07,530 --> 00:04:09,990
所以非常非常重要的是，不要忘记进行初始化

55
00:04:09,990 --> 00:04:16,379
还是那样，我会在以后的视频中讲解更多关于初始化和正确初始化的策略和方法

56
00:04:16,379 --> 00:04:19,500
记得去看

57
00:04:19,500 --> 00:04:24,259
让我们来看看带参数的构造函数，我可以写很多个构造函数

58
00:04:24,339 --> 00:04:30,060
但是要给他们提供不同的参数，这个我写同名方法是一样的

59
00:04:30,060 --> 00:04:35,769
其实这叫函数重载，就是相同的函数名有不同的参数的不同版本函数

60
00:04:35,769 --> 00:04:40,899
我把x和y作为参数添加到这里，然后把x和y赋值给X和Y。

61
00:04:40,899 --> 00:04:45,910
也就是说在这里我把参数赋值给了成员变量

62
00:04:45,910 --> 00:04:49,079
我现在可以使用参数来构造Entity了

63
00:04:49,079 --> 00:04:55,040
在这里简单地写下我想要的值，比如10和5，删掉这些多余的代码

64
00:04:55,040 --> 00:05:00,389
如果运行代码，我应该会看到10和5被打印到控制台，就像这样。

65
00:05:00,389 --> 00:05:02,879
Cool, 构造函数讲的差不多了

66
00:05:02,879 --> 00:05:11,600
当然构造函数不会再你没有实例化对象的时候运行，所以如果你只是使用类的静态方法，构造函数是不会执行的。

67
00:05:11,600 --> 00:05:16,100
我们还没有讨论堆分配(heap allocation), 我们很快就会在后面的视频中讲到...

68
00:05:16,100 --> 00:05:21,860
当然了，当你用new关键字创建对象实例的时候也会调用构造函数。

69
00:05:21,860 --> 00:05:28,819
也有一些方法可以删除构造函数，比如说你有一个只有静态方法的Log类

70
00:05:28,819 --> 00:05:35,000
就像这里的static void Log(), 还是把它写成write吧

71
00:05:35,000 --> 00:05:40,459
然后我想让别人只像这样使用这个Log类，不希望别人创建实例

72
00:05:40,459 --> 00:05:46,839
有两种不同的解决方法，我们可以通过设置private来隐藏构造函数

73
00:05:46,839 --> 00:05:50,430
你看到这里报了错，因为我不能访问构造函数

74
00:05:50,430 --> 00:05:54,600
如果我不这么做，你可以看到显然是允许构造这个对象的。

75
00:05:54,600 --> 00:05:57,519
因为C++默认为我们提供了构造函数

76
00:05:57,519 --> 00:06:01,230
但是我们可以对编译器说：“不，我不想要那个默认构造函数“

77
00:06:01,230 --> 00:06:06,610
我们可以像这样写成 Log() = delete;

78
00:06:06,610 --> 00:06:14,160
然后你看这里，我们就无法像这样调用Log,因为默认构造函数已经不存在了，被删除了。

79
00:06:14,160 --> 00:06:18,540
还有一些特殊类型的构造函数，比如说赋值构造函数和移动构造函数

80
00:06:18,540 --> 00:06:21,829
它们每个都是单独的视频，因为它们都比较复杂

81
00:06:21,829 --> 00:06:24,250
对于基本的使用来说，这些就是构造函数的内容：

82
00:06:24,250 --> 00:06:27,759
一个特殊的函数，会在你每次实例化类的时候调用。

83
00:06:27,759 --> 00:06:30,970
最主要的用处就是用来初始化类。

84
00:06:30,970 --> 00:06:37,019
当你创建一个对象实例的时候，确保你初始化了所有的内存和做了所有你需要的设置

85
00:06:37,019 --> 00:06:41,269
还有很多东西要讲，下次见, Goodbye!

