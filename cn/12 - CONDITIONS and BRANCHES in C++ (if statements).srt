1
00:00:00,030 --> 00:00:01,879
Hey 大家好 我是cherno

2
00:00:02,149 --> 00:00:05,379
欢迎重新回到我的C++系列教程   

3
00:00:05,379 --> 00:00:07,849
今天就让我们来看看条件语句  

4
00:00:07,849 --> 00:00:13,470
换句话说就是if语句和if-else语句的全部内容了

5
00:00:13,500 --> 00:00:15,130
我知道对于大部分的观众来说

6
00:00:15,130 --> 00:00:20,379
你们可能觉得你们已经知道所有关于if还有它在C++里的分支行为的知识了

7
00:00:20,379 --> 00:00:22,769
但是我仍然建议大家继续看这个视频

8
00:00:22,769 --> 00:00:24,679
因为你可能会学习到一些新的知识

9
00:00:24,679 --> 00:00:28,100
我实际上已经准备在条件结构如和在C++中工作这一方面讲得更加深入一些

10
00:00:28,100 --> 00:00:29,170
所以很值得看看

11
00:00:29,179 --> 00:00:33,950
好，条件语句、if句式或者分支结构到底意味着什么

12
00:00:33,950 --> 00:00:35,579
这些都是什么？

13
00:00:35,579 --> 00:00:41,100
简单来说总有某些时候，当代码需要根据某个值

14
00:00:41,140 --> 00:00:45,750
来决定我们下一步的执行操作

15
00:00:46,020 --> 00:00:49,770
所以举个例子 那就让我们假设有一个变量X并且赋值为5

16
00:00:49,770 --> 00:00:54,250
我们能够写出当值为5的情况下而做出某些特定操作的代码

17
00:00:54,250 --> 00:00:56,770
这就是条件结构存在的意义了

18
00:00:56,770 --> 00:01:00,350
条件结构就是 当X等于5时 我们可以根据这个情况

19
00:01:00,350 --> 00:01:02,829
跳转到我们所需要的分支

20
00:01:02,829 --> 00:01:05,849
当我们写if句式的时候 有两件事会发生

21
00:01:05,849 --> 00:01:09,420
当我们运行代码的时候，就会有对实际条件情况的比较

22
00:01:09,420 --> 00:01:12,400
然后，还有取决于比较结果的分支

23
00:01:12,400 --> 00:01:18,299
换句话说 我们的条件为true,我们就要跳转到我们代码中的某一部分

24
00:01:18,799 --> 00:01:22,530
如果为false,我们就得跳转到另一部分

25
00:01:22,530 --> 00:01:24,250
当然我说的是源代码

26
00:01:24,250 --> 00:01:27,349
但是在运行的应用中，这可能就得说成是机器指令

27
00:01:27,349 --> 00:01:32,349
所以，也可以说是我们跳转到了机器码或者cpu指令的分支中

28
00:01:32,349 --> 00:01:34,299
或者跳转到另一部分的CPU指令当中

29
00:01:34,299 --> 00:01:39,849
当我们开启一个应用，一个完整的应用，伴随着它的诸多模组就加载到了内存中

30
00:01:39,849 --> 00:01:44,849
所以，这时候所有组成我们程序的所有代码都储存到内存中

31
00:01:44,849 --> 00:01:49,049
当我们有一个条件指令指向一个分支时，我们就是在告诉电脑

32
00:01:49,049 --> 00:01:50,900
嘿，快跳转至这个部分的内存

33
00:01:50,900 --> 00:01:53,299
然后开始执行我们的指令

34
00:01:53,299 --> 00:01:56,174
因为这些跳转和分支

35
00:01:56,174 --> 00:02:01,299
这确实比我所说的难那么一些 这还有一些值得探索的

36
00:02:01,974 --> 00:02:09,754
比如说 我们比较条件、跳转到内存中的其他部分然后执行指令

37
00:02:09,770 --> 00:02:11,849
意味着

38
00:02:11,849 --> 00:02:16,000
如果我们的语句和分支分布在内存距离较远的地方

39
00:02:16,000 --> 00:02:17,750
并且当我们打算写一些高效的代码时

40
00:02:17,750 --> 00:02:20,449
我们就有可能决定不去使用if句式

41
00:02:20,449 --> 00:02:25,250
实际上，很多优化过的代码会尤其避免分支结构，避免比较

42
00:02:25,250 --> 00:02:28,099
因为那么做会让代码变慢

43
00:02:28,099 --> 00:02:35,150
在这个系列的最后我们会看一些 将分支结构去除的优化例子

44
00:02:35,150 --> 00:02:37,050
但是，现在为时过早

45
00:02:37,050 --> 00:02:39,349
我想说的是我对这个系列有很多计划

46
00:02:39,349 --> 00:02:41,310
所以各位，敬请期待

47
00:02:41,310 --> 00:02:44,689
无论如何，不想讲得太复杂

48
00:02:44,689 --> 00:02:52,229
记住条件结构就是当条件为真就跳转并执行代码的某一部分

49
00:02:52,229 --> 00:02:54,620
这就是基础的全部内容

50
00:02:54,620 --> 00:02:57,379
现在给大家展示例子

51
00:02:57,379 --> 00:02:59,099
我用这个这个非常基础的应用给大家展示

52
00:02:59,099 --> 00:03:01,099
在前几集中我们也用的是这个VS IDE

53
00:03:01,099 --> 00:03:03,129
我们开始吧

54
00:03:03,129 --> 00:03:05,849
拿X作为一个例子

55
00:03:05,849 --> 00:03:08,949
声明它并赋值5然后

56
00:03:08,949 --> 00:03:12,949
我们现在想当X==5时就输出hello world

57
00:03:12,949 --> 00:03:15,000
所以我可以做的就是输入if

58
00:03:15,000 --> 00:03:17,099
然后键入条件

59
00:03:17,129 --> 00:03:19,469
为了能让功能实现

60
00:03:19,469 --> 00:03:22,900
也为了我们确实能检查X是否等于5

61
00:03:22,900 --> 00:03:25,699
我们就不得不执行一种叫做比较的操作

62
00:03:25,699 --> 00:03:29,650
也就是拿一个值和另外的一个值比较

63
00:03:29,650 --> 00:03:33,000
这个实际上是一个布尔类型的语句

64
00:03:33,000 --> 00:03:35,719
也就是说 就是一个表达true或者false的语句

65
00:03:35,719 --> 00:03:38,050
X可能是5也可能不是

66
00:03:38,050 --> 00:03:39,800
所以通过这个就可以知道其真假

67
00:03:39,800 --> 00:03:43,900
如果我们想要存储一个布尔语句，我们知道我们可以用布尔类型的变量来存储

68
00:03:43,900 --> 00:03:50,650
所以我们就键入变量comparisonResult = x == 5

69
00:03:50,650 --> 00:03:55,324
在这里的双等号被称作等于(equality)运算符

70
00:03:55,324 --> 00:03:59,150
它是用来确认x是否是等于5的

71
00:03:59,150 --> 00:04:02,400
如果等于5这个比较结果就是true

72
00:04:03,175 --> 00:04:06,449
如果不相等就会返回false

73
00:04:06,449 --> 00:04:09,000
所以一旦这行代码得到执行

74
00:04:09,000 --> 00:04:11,379
比较的结果就会是真或者假

75
00:04:11,379 --> 00:04:12,770
这取决于x的值

76
00:04:12,770 --> 00:04:17,769
这个运算符是这个含义的原因是它在C的标准库中已经被加载过了

77
00:04:17,769 --> 00:04:26,459
某人写了一个函数，可以接纳两个整数
然后从内存中调出整数 进行比较确保是否相等

78
00:04:26,459 --> 00:04:30,079
如果相等返回true，这就是这个==的功能的全部

79
00:04:30,079 --> 00:04:35,079
你们所见的所有运算符，在C&C++里的都不是什么魔术之类的

80
00:04:35,079 --> 00:04:40,079
他们已经在某种方式上被实施执行过了，就像在本例中的标准库一样

81
00:04:40,079 --> 00:04:42,850
它们才能以整数的形式展现

82
00:04:42,850 --> 00:04:48,199
大部分原始的数据结构，实际上在检查两个整数是否相等的时候

83
00:04:48,199 --> 00:04:51,455
你其实是将表示他们的四个字节给抓取出来

84
00:04:51,470 --> 00:04:53,889
然后再逐字节逐位地进行比较

85
00:04:53,889 --> 00:04:57,379
在内存中对应位的二进制数都得相同

86
00:04:57,379 --> 00:04:58,819
才能是相等的

87
00:04:58,819 --> 00:05:03,819
所以最后我们才能使用这个if语句中的比较结果  

88
00:05:03,819 --> 00:05:06,149
如果我们想让条件为真 时执行某个分支

89
00:05:06,149 --> 00:05:08,149
我们有两种写法

90
00:05:08,149 --> 00:05:10,230
我们可以写if(comparisonResult==true)

91
00:05:10,230 --> 00:05:12,850
然而这没什么必要

92
00:05:12,850 --> 00:05:21,310
因为如果我们就写成if(comparisonResult)也能得到相同的效果

93
00:05:21,310 --> 00:05:25,379
简而言之就是只要comparisonResult非真那么 if句式的内容就不会运行

94
00:05:25,379 --> 00:05:27,899
然后呢我们就得在{}内的主体内写上一些详尽的代码

95
00:05:27,899 --> 00:05:31,100
这就是你分支要跳转到的地方

96
00:05:31,100 --> 00:05:33,899
就是当你的条件为真时，你希望电脑能跑的代码 

97
00:05:33,899 --> 00:05:36,230
所以呢我们在这里先键入{}

98
00:05:36,230 --> 00:05:38,350
然后输入log函数，很好

99
00:05:38,350 --> 00:05:41,149
我们现在已经创造了一个分支

100
00:05:41,149 --> 00:05:42,500
所以，如果comparisonResult这个变量是真

101
00:05:42,500 --> 00:05:44,500
我们就要输出hello world到控制台

102
00:05:44,500 --> 00:05:45,899
否者就不要输出

103
00:05:45,899 --> 00:05:47,600
然后呢，还有一些有意思的事

104
00:05:47,600 --> 00:05:51,300
即使是在这段我们写的短小的代码也可以与之相关

105
00:05:51,300 --> 00:05:54,300
因为他们实在是无处不在

106
00:05:54,300 --> 00:05:57,300
我们先运行一下代码看看会发生什么再说

107
00:05:57,300 --> 00:05:59,500
如果我们敲击F5它就会逐行运行

108
00:05:59,500 --> 00:06:01,250
现在开始运行我的程序

109
00:06:01,375 --> 00:06:04,024
你可以看到我得到了hello world的输出

110
00:06:04,024 --> 00:06:07,199
然而如果我把x改成6

111
00:06:07,199 --> 00:06:09,300
我再按F5，就什么也不会发生

112
00:06:09,300 --> 00:06:11,800
如果我们在这放置一个断点

113
00:06:11,800 --> 00:06:14,100
我在上期视频中讲到过了断点和debug

114
00:06:14,100 --> 00:06:15,500
如果你们还没去看过

115
00:06:15,500 --> 00:06:17,500
你们也想去看看的话 

116
00:06:17,500 --> 00:06:19,800
在电脑屏幕的附近必定有相应的视频或这链接什么的

117
00:06:19,800 --> 00:06:23,000
我们会用到很多关于断点和debug的知识

118
00:06:23,000 --> 00:06:23,899
所以你们还是去看看吧

119
00:06:23,899 --> 00:06:26,100
在设置好断点的情况下，我按下F5

120
00:06:26,100 --> 00:06:28,500
先把这个内存管理窗口关了好了

121
00:06:28,500 --> 00:06:30,600
接下来我要按F10了

122
00:06:30,600 --> 00:06:34,000
我们可以看到x等于6这么一个情况

123
00:06:34,000 --> 00:06:37,100
在这个情况下x==5就返回了false

124
00:06:37,100 --> 00:06:39,250
comparisonResult将会是false

125
00:06:39,250 --> 00:06:43,120
如果我在这直接按下F10

126
00:06:43,120 --> 00:06:44,600
if语句就会直接评估条件

127
00:06:44,600 --> 00:06:48,449
然后你可以看到它直接跳到了这cin.get()

128
00:06:48,449 --> 00:06:50,889
这行代码从来没被运行过因为

129
00:06:50,889 --> 00:06:57,899
只有当comparisonResult是真的时候才输出helloworld

130
00:06:57,899 --> 00:07:02,100
如果我们想再深入地了解一点背后运作的机理和

131
00:07:02,100 --> 00:07:03,850
实际上在工作的CPU指令知识

132
00:07:03,850 --> 00:07:07,750
我们可以将其编译成汇编语言，再来检查这些汇编语言

133
00:07:07,889 --> 00:07:09,500
然而还有一件很重要的事 

134
00:07:09,500 --> 00:07:12,199
我们可以做一件类似于debug中的部分工作的事

135
00:07:12,199 --> 00:07:14,250
我们使用VS中的disassemblely工具来处理目前这些代码 

136
00:07:14,250 --> 00:07:16,399
如果我们在设定好断点的情况下按下F5来运行我们的程序

137
00:07:16,399 --> 00:07:18,500
我们可以做的就是在这点击鼠标

138
00:07:18,500 --> 00:07:20,500
这是我们的软件产生的

139
00:07:20,500 --> 00:07:23,449
我可以右键这里然后选择go to disassembly(ctrl+G)然后就转到了这个界面

140
00:07:23,449 --> 00:07:25,600
然后就转到了这个界面

141
00:07:25,600 --> 00:07:30,000
在这我们既有源代码又有与之相应的汇编语言

142
00:07:30,000 --> 00:07:32,699
换句话说我们的编译器

143
00:07:32,699 --> 00:07:35,250
将这行源代码转化成了这一行

144
00:07:35,250 --> 00:07:39,399
这一行又编译成这些汇编语言

145
00:07:39,399 --> 00:07:42,449
我们也可以逐行来运行这些汇编语言

146
00:07:42,449 --> 00:07:45,699
可以看看在我们CPU的寄存器里都存储了什么

147
00:07:45,699 --> 00:07:53,149
这挺叼的，并且很有用，特别是当你想要去debug一些你没法直接看出问题的源代码

148
00:07:53,149 --> 00:07:56,350
也可以debug一些CPU指令，当然这简直是场恶梦

149
00:07:56,350 --> 00:07:59,149
btw，大家尽可能的避免去debug汇编语言吧

150
00:07:59,149 --> 00:08:03,399
不过用来快速查看编译器产生了什么样的代码，还是蛮有用的

151
00:08:03,399 --> 00:08:07,899
而不是去将所有的输出都放到一个文件里，然后几乎可以填满我的家

152
00:08:07,899 --> 00:08:14,550
这不是C++编译器视频所以回到我们前面说的地方

153
00:08:14,550 --> 00:08:17,050
你们可以看到的第一件事 是在这儿发生的

154
00:08:17,050 --> 00:08:20,600
我不是要花半个小时的时间的时间来教你们汇编语言

155
00:08:20,600 --> 00:08:24,600
但我确实很想在以后做几期关于汇编的视频

156
00:08:24,600 --> 00:08:27,475
如果你们想要的话，就在下方留下评论吧

157
00:08:27,725 --> 00:08:29,649
因为确实有很有人来问我关于这方面的问题

158
00:08:29,649 --> 00:08:33,450
但是现在我的确不想在这方面花太多的时间

159
00:08:33,450 --> 00:08:34,500
来解释每件事是怎么工作的

160
00:08:34,500 --> 00:08:35,000
所以我在这解释一下

161
00:08:35,000 --> 00:08:37,000
如果你们感兴趣并且想要学习更多知识

162
00:08:37,000 --> 00:08:38,240
你可以自行上网学习

163
00:08:38,240 --> 00:08:39,250
或者留下评论吧

164
00:08:39,259 --> 00:08:41,549
某天我可能就会尝试去做一个视频

165
00:08:41,549 --> 00:08:43,250
我们再来看看这些代码

166
00:08:43,250 --> 00:08:47,100
在这发生的是我们把一个值载入到一个寄存器中

167
00:08:47,100 --> 00:08:49,850
这个MOVE指令就意味着移动

168
00:08:49,850 --> 00:08:53,100
我们将6移动至寄存器，对吧？

169
00:08:53,230 --> 00:08:56,250
你可以把它当作它把变量设置成了6

170
00:08:56,250 --> 00:08:57,570
如果我们在这按下F10

171
00:08:57,570 --> 00:08:59,149
我们就会到下一条指令

172
00:08:59,149 --> 00:09:01,850
这个就是我们提到的布尔声明

173
00:09:01,850 --> 00:09:07,700
我们现在在做的就是 我们将5给加载到同样的寄存器中去

174
00:09:07,700 --> 00:09:12,000
这很有趣，因为编译器对我们的代码做了美化

175
00:09:12,000 --> 00:09:15,649
我们继续往下读 就可以看到JNE语句

176
00:09:15,649 --> 00:09:17,750
它的意思是如果不等 就跳转(jump not equal)

177
00:09:17,750 --> 00:09:21,649
也就是如果比较结果是假 就跳转

178
00:09:21,649 --> 00:09:25,049
很显然这个CMP语句就是在比较两个值，5和6

179
00:09:25,230 --> 00:09:26,500
如果他们不相等

180
00:09:26,539 --> 00:09:28,700
我们就跳转到这个内存地址 

181
00:09:28,899 --> 00:09:33,200
这个内存地址就是这里写的这个值01B59B7

182
00:09:33,409 --> 00:09:36,799
我们看看这个地址9B7

183
00:09:36,799 --> 00:09:39,049
就在这下方这行

184
00:09:39,049 --> 00:09:41,399
如果他们不相等我们就要跳转到这一行

185
00:09:41,399 --> 00:09:43,200
现在我们都知道是不相等的

186
00:09:43,200 --> 00:09:47,399
所以我按下F10你可以看到我们的指令指针

187
00:09:47,399 --> 00:09:50,500
这个黄色的箭头就是我们的电脑正在执行的位置

188
00:09:50,500 --> 00:09:54,000
现在跳转到这个内存地址来执行下一条指令

189
00:09:54,000 --> 00:09:59,000
这条指令要将某个值，在这里是0，载入寄存器中

190
00:09:59,000 --> 00:10:01,980
这个寄存器叫做EBP

191
00:10:01,980 --> 00:10:04,980
实质是寄存器EBP减去某个补偿(offset)

192
00:10:05,129 --> 00:10:07,450
我们现在要把值0给加载进去

193
00:10:07,450 --> 00:10:10,250
现在我们可以再来讲讲布尔类型了

194
00:10:10,250 --> 00:10:13,750
不知道大家有没有看过我那期关于变量和C++的视频

195
00:10:13,750 --> 00:10:15,019
没看的可以去看看

196
00:10:15,019 --> 00:10:19,049
我说过这样一件事，布尔类型本质上是一种一个字节(8位)长度的数据类型

197
00:10:19,049 --> 00:10:23,399
就和其他数据类型一样，在C++里根本没有true或者false的概念

198
00:10:23,399 --> 00:10:25,100
所以布尔类型是怎么工作的呢？

199
00:10:25,100 --> 00:10:28,700
如果值是0那么就是假

200
00:10:28,700 --> 00:10:32,629
如果值是其他任何数，那就是真

201
00:10:32,629 --> 00:10:33,899
我们只是在处理数字而已

202
00:10:33,899 --> 00:10:35,019
计算机在这儿处理数字

203
00:10:35,019 --> 00:10:39,269
但是因为我们在可编址内存获取了一个相当庞大的空间

204
00:10:39,269 --> 00:10:43,169
如果我们申请布尔类型就会占用一个字节

205
00:10:43,169 --> 00:10:47,379
我们也没必要去确认有一位被置1

206
00:10:47,379 --> 00:10:50,169
所以就像在使用时那样

207
00:10:50,169 --> 00:10:52,649
只要不是0就会被认作是真

208
00:10:52,649 --> 00:10:55,200
当然，如果我们只处理一位的话

209
00:10:55,200 --> 00:10:57,600
我们也就只有两个可能的值0和1

210
00:10:57,600 --> 00:10:59,399
如果是0就是假

211
00:10:59,399 --> 00:11:00,750
如果是1就是真

212
00:11:00,750 --> 00:11:03,379
既然我们有一个这么大的空间

213
00:11:03,379 --> 00:11:05,629
我们可以非常自信的说

214
00:11:05,629 --> 00:11:08,080
即使是100，这也将会是真

215
00:11:08,080 --> 00:11:10,769
当然，是0 ，肯定被判做是假

216
00:11:10,850 --> 00:11:15,269
尽管如此，在这儿发生的就是我们将0载入到这个寄存器中

217
00:11:15,269 --> 00:11:19,100
所以才能将0分配到那个布尔类型的变量之中

218
00:11:19,100 --> 00:11:23,879
所以假就是0 真在通常情况下是1 

219
00:11:23,879 --> 00:11:28,399
虽然我们必须得把值输入进去 可以是1

220
00:11:28,399 --> 00:11:34,549
然而，也没说非得去填1，可以是很多数

221
00:11:34,549 --> 00:11:37,299
但是假的的确确就是0

222
00:11:37,299 --> 00:11:39,600
真也可以是1

223
00:11:39,600 --> 00:11:44,000
这个MOVE指令将0载入了那个内容为假的内存块

224
00:11:44,000 --> 00:11:50,730
这也就是把那个布尔变量给设置成了假，因为比较失败了 

225
00:11:50,759 --> 00:11:51,950
我们接着往下看

226
00:11:51,950 --> 00:11:53,629
这里有一些其他类型的代码

227
00:11:53,629 --> 00:11:55,350
我们不需要太关心它们

228
00:11:55,350 --> 00:11:58,000
我们来看看if语句编译出来的汇编语言

229
00:11:58,000 --> 00:12:00,250
所以我们在if语句中都做了什么

230
00:12:00,250 --> 00:12:03,100
同样，我们再次把某些值载入到EAX寄存器里

231
00:12:03,100 --> 00:12:06,950
我们来测试一下这个EAX寄存器是否有传递我们的条件

232
00:12:06,950 --> 00:12:12,330
这里这个test指令 对两个操作数执行“与”操作 并把结果保存到第一个寄存器中

233
00:12:12,330 --> 00:12:14,799
我不想在这方面讲的太深入

234
00:12:14,799 --> 00:12:17,500
简单来说 如果这个test操作成功了

235
00:12:17,500 --> 00:12:19,850
接下来就会进行JE(jump equal)操作

236
00:12:19,850 --> 00:12:22,799
换句话说 就是如果test操作是真

237
00:12:22,799 --> 00:12:27,450
那么我们就要跳转到地址尾为90F的内存块

238
00:12:27,450 --> 00:12:28,379
这其实是这行代码所在的地址

239
00:12:28,379 --> 00:12:30,950
那么我们会直接跳过log函数的代码段

240
00:12:30,950 --> 00:12:36,919
如果不是这个情况 我们就不跳过这个代码段

241
00:12:36,919 --> 00:12:40,399
这不是个通常的JUMP命令这是，不是JMP

242
00:12:40,399 --> 00:12:41,649
这是JE

243
00:12:41,649 --> 00:12:43,519
所以这是个条件型的跳转指令

244
00:12:43,519 --> 00:12:46,169
所以如果比较失败了

245
00:12:46,169 --> 00:12:47,799
我们就会到下面一行

246
00:12:47,799 --> 00:12:50,419
这里又来了新的一条CPU指令

247
00:12:50,419 --> 00:12:52,419
做了如下的一点事

248
00:12:52,419 --> 00:12:55,019
然而我们已经知道这个测试就要成功了

249
00:12:55,019 --> 00:12:56,830
因为这个comparisonResult是假的

250
00:12:56,830 --> 00:13:00,700
所以如果我们按下F10 你可以看到我们就跳到了这里

251
00:13:00,700 --> 00:13:03,830
我们继续运行我们的程序，一切正常

252
00:13:03,830 --> 00:13:08,500
这些就是稍微深入地讨论了一下在计算机里实际上发生的事

253
00:13:08,500 --> 00:13:12,519
记住，我在debug模式下编译并且运行这个代码

254
00:13:12,519 --> 00:13:15,950
这意味着这并没有优化我们的代码

255
00:13:15,950 --> 00:13:20,980
所以如果我们再重新看看这个这个代码，这里其实有很多都是可以被简化的

256
00:13:20,980 --> 00:13:24,049
编译器知道这个变量x被赋值为6

257
00:13:24,049 --> 00:13:25,950
然后再拿它和5作比较

258
00:13:25,950 --> 00:13:27,350
它完全可以自己完成这个工作

259
00:13:27,350 --> 00:13:29,049
没有必要在运行的时候再来比较

260
00:13:29,049 --> 00:13:33,169
完全可以在编译的时候来解决这个问题

261
00:13:33,169 --> 00:13:35,799
这种被称为常数折迭(constant folding)的技术就出现了

262
00:13:35,799 --> 00:13:38,000
它会把这些都转到一个常变量中

263
00:13:38,000 --> 00:13:41,000
因为这些常量都会在编译时被知晓

264
00:13:41,000 --> 00:13:46,330
就可以摆脱这个comparisonResult还有这个if语句

265
00:13:46,330 --> 00:13:48,879
只留下这个std::cin.get()

266
00:13:48,879 --> 00:13:52,519
他就会直接移除6-11行的所有内容

267
00:13:52,519 --> 00:13:54,669
因为他们没有运行的必要

268
00:13:54,669 --> 00:13:58,830
所以为什么要编译他们？为什么要在运行时做条件检查？

269
00:13:58,830 --> 00:14:00,500
仅仅是在浪费时间而已

270
00:14:00,500 --> 00:14:01,830
我们清楚地知道我们不需要它

271
00:14:01,830 --> 00:14:04,100
记住，如果你想在这一方面搞得比较清楚

272
00:14:04,100 --> 00:14:06,580
通过查看disassemblely来弄懂这些事物都是怎么工作的

273
00:14:06,580 --> 00:14:10,129
确保你是在debug模式下 确保尽可能地不去优化代码

274
00:14:10,129 --> 00:14:14,269
因为如果你不这么做 编译器就会做它该做的事

275
00:14:14,399 --> 00:14:15,750
表演一些魔法

276
00:14:15,750 --> 00:14:16,879
然后你觉会被虐

277
00:14:16,879 --> 00:14:18,330
好，我们重新回到这个

278
00:14:18,330 --> 00:14:21,299
我们知道这个comparisonResult是一个布尔类型

279
00:14:21,299 --> 00:14:25,100
布尔类型变量简单来说就是个整数，对吧？

280
00:14:25,100 --> 00:14:26,919
是0就是假

281
00:14:26,919 --> 00:14:28,399
1就是真

282
00:14:28,399 --> 00:14:30,330
所以if语句究竟在做什么

283
00:14:30,330 --> 00:14:33,269
它在看条件是不是数字0

284
00:14:33,269 --> 00:14:38,519
如果是0，它就不去运行后面的语句了

285
00:14:38,519 --> 00:14:41,730
然而如果不是0，比如说是1

286
00:14:41,730 --> 00:14:43,799
他就会跳入到后面这一部分

287
00:14:43,799 --> 00:14:45,480
这就是这些玩意工作的原因

288
00:14:45,480 --> 00:14:48,350
我们没有必要去写==true

289
00:14:48,350 --> 00:14:52,000
因为我们没必要去检查这是否等于1或者等于true

290
00:14:52,000 --> 00:14:53,049
或者之类的东西

291
00:14:53,100 --> 00:14:57,330
我们可以简单的检查这个东西是否为0 这就是它所做的

292
00:14:57,330 --> 00:15:01,250
这就像是在说 嘿 看看这个comparisonResult存储的内存块

293
00:15:01,250 --> 00:15:03,799
里面存的是不是0啊

294
00:15:03,799 --> 00:15:06,379
如果不是0，就执行下面这个代码

295
00:15:06,389 --> 00:15:07,629
如果是0，就别

296
00:15:07,629 --> 00:15:10,080
这就是if语句的重点所在

297
00:15:10,100 --> 00:15:12,299
举个例子 如果我们写if(1) 

298
00:15:12,299 --> 00:15:16,269
然后运行我的代码，代码编译得很流畅

299
00:15:16,269 --> 00:15:19,669
你就会看到hello world被输出到了屏幕上

300
00:15:19,669 --> 00:15:23,100
如果我输入if(0)，它就不会被输出到屏幕上

301
00:15:23,100 --> 00:15:24,950
非常简单，我们都已经懂了

302
00:15:24,950 --> 00:15:28,500
当然，有了comparisonResult我们都不用另外声明变量来存储

303
00:15:28,500 --> 00:15:32,980
我声明了x是因为 我想给大家展示 这个条件是一个 布尔类型

304
00:15:32,980 --> 00:15:39,669
你们可以在这写成x==5 这可以简化你的代码一些

305
00:15:39,669 --> 00:15:42,149
如果我们的if语句后 只有一个语句

306
00:15:42,149 --> 00:15:45,000
我们连大括号都不要

307
00:15:45,000 --> 00:15:47,379
我可以写成这样子  这样也是ok的

308
00:15:47,379 --> 00:15:49,250
你还可以更改一下位置

309
00:15:49,250 --> 00:15:50,769
有的人喜欢把它们写在同一行

310
00:15:50,769 --> 00:15:51,980
我个人是不喜欢这么写的

311
00:15:51,980 --> 00:15:58,169
举个例子，因为当你想要进行debug的时候，你把断点放在这儿

312
00:15:58,169 --> 00:16:05,149
就无法弄清楚现在是在执行比较还是在log函数

313
00:16:05,149 --> 00:16:07,950
如果我按F10，它就跳过了 我不知道发生了啥

314
00:16:07,950 --> 00:16:13,799
然而 如果我把他们分成两行 我就可以检查具体情况了

315
00:16:13,799 --> 00:16:16,350
你可以看到在 如果我按F10，没有经过那一行

316
00:16:16,350 --> 00:16:18,019
那行没有被执行

317
00:16:18,019 --> 00:16:21,379
简单实在 因为布尔类型就是简单的数值

318
00:16:21,379 --> 00:16:25,019
也因为if语句只检测数字

319
00:16:25,019 --> 00:16:27,799
你可以用if做一点看起来蛮叼的事

320
00:16:27,850 --> 00:16:36,950
比如，我可以写if(x) 然后如果我运行代码就会去检查x是0与否

321
00:16:36,950 --> 00:16:41,669
当然，x是6，所以如我我按F10

322
00:16:41,669 --> 00:16:46,850
我们就可以跳转到log函数

323
00:16:46,850 --> 00:16:48,730
这个技巧可以应用在指针上

324
00:16:48,730 --> 00:16:51,399
如果我们想要去检查一个指针是否是null

325
00:16:51,399 --> 00:16:52,299
null当然也是0

326
00:16:52,299 --> 00:16:55,169
我们可以把这个指针

327
00:16:55,169 --> 00:16:57,830
放入if语句的条件中 就像这样

328
00:16:57,830 --> 00:17:10,450
举个例子，如果我有一个指针，const char* pointer = “hello”; （继续写代码）

329
00:17:10,450 --> 00:17:12,150
如果我运行这段代码

330
00:17:12,150 --> 00:17:14,279
你可以发现pointer被置成了某些值 

331
00:17:14,279 --> 00:17:15,099
而且不是null

332
00:17:15,119 --> 00:17:18,920
因为我们可以将它打印出来

333
00:17:18,920 --> 00:17:22,099
假如它是等于空指针(nullptr)

334
00:17:22,099 --> 00:17:27,549
你会发现这行代码就不运行了

335
00:17:27,549 --> 00:17:32,220
所以不要写pointer!=nullpter

336
00:17:32,220 --> 00:17:33,720
我们可以写得更简洁一点

337
00:17:33,720 --> 00:17:36,720
这也是一种个人代码风格吧

338
00:17:36,720 --> 00:17:39,079
有些人就是喜欢写得详细一点

339
00:17:39,079 --> 00:17:40,799
他们认为这样能让代码的可读性更好

340
00:17:40,799 --> 00:17:42,500
我个人不是太感冒

341
00:17:42,500 --> 00:17:43,549
我通常是这样写

342
00:17:43,549 --> 00:17:46,130
因为对我来说，这样更有意义吧

343
00:17:46,130 --> 00:17:48,599
这个ptr也是有效的值

344
00:17:48,599 --> 00:17:49,829
就这么写吧

345
00:17:49,829 --> 00:17:51,970
这样看起来干净整洁

346
00:17:51,970 --> 00:17:56,029
有些能在C++里做的事并不能在别的语言中做到比如java/C#

347
00:17:56,029 --> 00:18:01,549
它俩看起来可明确，但是C++本来就是一种更加难懂的语言，对吧？

348
00:18:01,549 --> 00:18:02,470
反正什么事都有可能发生

349
00:18:02,470 --> 00:18:05,529
现在，如果你想做一些别的事

350
00:18:05,529 --> 00:18:09,880
比如，在这 如果ptr是一个有效的值

351
00:18:09,880 --> 00:18:11,970
如果它不为null 那就进行log函数

352
00:18:11,970 --> 00:18:15,130
但是如果我想 运行一些不是这个情况下发生的代码

353
00:18:15,130 --> 00:18:17,670
那我们就在后面加上else语句 所以我可以写

354
00:18:17,670 --> 00:18:21,849
（写代码）

355
00:18:21,849 --> 00:18:25,750
然后如果我运行我的程序你可以看到会发生的事

356
00:18:25,750 --> 00:18:28,000
他将要输出pointer is null

357
00:18:28,000 --> 00:18:31,099
当然因为我用debugger逐行调试代码

358
00:18:31,099 --> 00:18:33,950
这个pointer是null或者0

359
00:18:33,950 --> 00:18:35,349
这就会运行下面这个

360
00:18:35,349 --> 00:18:36,950
之后就会跳转到else后面的语句

361
00:18:36,950 --> 00:18:38,000
帅

362
00:18:38,000 --> 00:18:42,250
同样的 我们可以使用else if语句来继续添加条件分支

363
00:18:42,250 --> 00:18:46,329
也就是说 我可以检查这个ptr==“Hello”是否为真

364
00:18:46,329 --> 00:18:50,109
然后再键入代码log("pointer is hello");

365
00:18:50,109 --> 00:18:51,099
将会发生什么呢

366
00:18:51,099 --> 00:18:57,150
因为这是一个else if
只有当前面这个if后的条件为假了才会来检测else if 后的条件

367
00:18:57,150 --> 00:19:04,349
所以从理论上来说
 我写在这里的代码可能从来不会运行 至少这个部分永远不会运行

368
00:19:04,349 --> 00:19:08,779
因为指针不是null 所以磁盘就不会去读取它

369
00:19:08,779 --> 00:19:13,799
如果我把我的指针设成….比如hello

370
00:19:13,799 --> 00:19:17,849
然后我按F5 接下来会发生什么

371
00:19:17,849 --> 00:19:22,579
就是这个指针不是null 所以这个分支就会执行

372
00:19:22,579 --> 00:19:25,880
如果我按F10 我们直接跳到最后

373
00:19:25,880 --> 00:19:27,529
因为这些代码根本不起作用

374
00:19:27,529 --> 00:19:32,849
只有当if后的条件为假时才会来检测else if后的条件

375
00:19:32,849 --> 00:19:35,079
然而如果我这么写

376
00:19:35,079 --> 00:19:37,500
把这个else if前的else去掉

377
00:19:37,500 --> 00:19:40,700
你会发现这个条件就会被检测

378
00:19:40,700 --> 00:19:44,029
然后检测成功 我们的控制台会有两个东西打印出来

379
00:19:44,029 --> 00:19:49,029
其实else if语句就是一个你可能不会注意到的小把戏

380
00:19:49,029 --> 00:19:51,500
但它就是发生了

381
00:19:51,500 --> 00:19:54,779
它也不过就是某种聪明地隐藏了语法的的方式

382
00:19:54,779 --> 00:20:00,250
我们再看看代码 我把它们写回原型

383
00:20:00,250 --> 00:20:03,329
写成两个独立的句型 

384
00:20:03,329 --> 00:20:05,670
看看这个新代码

385
00:20:05,670 --> 00:20:10,049
运行的结果和之前的一模一样

386
00:20:10,049 --> 00:20:16,470
所以说没有else if这样的整体 他们只是被结合到了一起

387
00:20:16,470 --> 00:20:22,779
就像我们把if(…)和log(…)写到了同一行一样

388
00:20:22,779 --> 00:20:27,220
就是个else 和 if

389
00:20:27,400 --> 00:20:30,779
我们前面在讲的 这个条件失效了

390
00:20:30,779 --> 00:20:34,150
才来验证下面这个ptr="hello"的条件

391
00:20:34,150 --> 00:20:37,700
就是说 只有在前面的if失败的情况下才会来执行else后的代码

392
00:20:37,700 --> 00:20:40,849
如果这是假 这段代码就会运行

393
00:20:40,849 --> 00:20:43,650
所以,不过是一些小把戏

394
00:20:43,650 --> 00:20:46,950
我记得我第一次发现这事的时候 觉得有些不可思议

395
00:20:46,950 --> 00:20:51,579
因为我没有意识到 我当时觉得else if像是某种关键字

396
00:20:51,579 --> 00:20:52,380
遗憾的是它不是

397
00:20:52,380 --> 00:20:56,220
在C++的定义中也根本没有else if这样的关键字

398
00:20:56,220 --> 00:20:57,950
就仅仅是else和if而已

399
00:20:57,950 --> 00:21:01,720
我们在做的就是把他们连在一起

400
00:21:01,720 --> 00:21:09,700
无论如何 我已经讲了很多关于if语句、条件和分支的基础知识

401
00:21:09,700 --> 00:21:12,599
希望各位能够理解这些东西是怎么工作的

402
00:21:12,599 --> 00:21:14,599
如果你感觉没全懂

403
00:21:14,599 --> 00:21:17,670
没什么关系 因为我讲得相当复杂

404
00:21:17,670 --> 00:21:24,724
从另一方面说就是，if语句这里我讲的要比其他的C++教程多一些

405
00:21:24,724 --> 00:21:27,250
我们会在代码中经常用到if语句

406
00:21:27,250 --> 00:21:30,970
编程有两个重要的组成部分

407
00:21:30,970 --> 00:21:33,970
一部分是数学编程(mathematical programming)
一部分是逻辑编程(logical programming)

408
00:21:33,970 --> 00:21:37,750
只是我想把它分成这两部分而已

409
00:21:37,750 --> 00:21:43,349
当然也有些编程你只要进行数学运算即可

410
00:21:43,349 --> 00:21:45,150
确实有挺多的

411
00:21:45,150 --> 00:21:50,150
很多高效、高速的程序本质上都是数学运算

412
00:21:50,150 --> 00:21:54,700
之中，前面提到的逻辑编程就比较少

413
00:21:54,700 --> 00:21:56,900
它们全都是与逻辑相关的

414
00:21:56,900 --> 00:22:00,250
如果某个条件符合了，就去做某件事

415
00:22:01,049 --> 00:22:07,779
这有些无聊 我不是说它没必要

416
00:22:07,779 --> 00:22:14,029
世界上也没有游戏和应用是没有使用if语句的

417
00:22:14,029 --> 00:22:19,029
我的意思是 之后我们会 学习怎么去写更好的代码

418
00:22:19,029 --> 00:22:23,720
你会看到许多你用if语句的地方我就不会去用

419
00:22:23,720 --> 00:22:32,029
我可能会用某些运算来代替比较和分支

420
00:22:32,029 --> 00:22:36,029
因为这么做的话确实会让你的代码变快许多

421
00:22:36,029 --> 00:22:39,130
如果是考虑到所谓的工作时用的代码，它可能也会更实用

422
00:22:39,130 --> 00:22:42,625
无论如何，我就是在闲谈

423
00:22:42,625 --> 00:22:44,500
今天就讲到这

424
00:22:44,500 --> 00:22:47,049
如果你喜欢这个视频请点赞

425
00:22:47,049 --> 00:22:50,875
建议你在推特和Ins上面关注我

426
00:22:50,875 --> 00:22:55,875
如果你真的喜欢这个系列，可以在Patreon上支持我。

427
00:22:55,875 --> 00:23:00,875
...

