1
00:00:00,000 --> 00:00:04,080
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:04,080 --> 00:00:07,919
今天我们要讲的是C++里的虚函数。

3
00:00:07,960 --> 00:00:12,630
在之前的视频里，我们一直在讨论类，面向对象编程，继承

4
00:00:12,630 --> 00:00:17,010
还有虚函数等这些东西对整体的概念来说都是非常重要的

5
00:00:17,010 --> 00:00:20,519
虚函数可以让我们在子类中重写方法

6
00:00:20,920 --> 00:00:23,719
比如说我们有两个类A和B

7
00:00:23,800 --> 00:00:27,640
B是从A派生来的，也就是说B是A的子类

8
00:00:27,640 --> 00:00:35,820
如果我们在A类里新建一个方法并把它标记为虚函数，我们可也在B类中重写这个方法让去做些其他的事情。

9
00:00:35,859 --> 00:00:39,030
最好还是来看个例子吧。

10
00:00:39,030 --> 00:00:43,619
我要在这里创建两个类，一个是Entity类，用来做我们的基类

11
00:00:43,619 --> 00:00:50,250
Entity只有一个公共的方法GetName, 这个方法会返回一个字符串

12
00:00:50,250 --> 00:00:54,299
因为这是一个Entity，所以我们返回单词”Entity“

13
00:00:54,299 --> 00:00:59,259
然后，我们长江另一个类Player, 它是Entity的子类

14
00:00:59,259 --> 00:01:00,719
我们要在这个类中增加更多的东西

15
00:01:00,719 --> 00:01:08,269
首先给它一个m_Name，然后在给它一个构造函数，用来更改这个name

16
00:01:10,769 --> 00:01:18,109
然后再给它一个方法GetName, 在这里它会返回这个m_Name，就是那个成员变量

17
00:01:18,109 --> 00:01:21,239
ok cool! 让我们来看看怎样使用这些设置。

18
00:01:21,239 --> 00:01:26,709
在这里创建一个Entity, 然后我要试着打印Entity的GetName返回值

19
00:01:27,459 --> 00:01:32,129
然后在创建一个Player， 把它称作Cherno

20
00:01:32,359 --> 00:01:35,150
然后我也要把这个Player的名字打印出来

21
00:01:35,159 --> 00:01:40,799
我不会去删除这些对象，因为程序会终止(对象被自动删除)，不用手动删除

22
00:01:41,109 --> 00:01:42,599
按F5运行代码

23
00:01:42,599 --> 00:01:48,560
如果我们看这结果，cool，看起来很好，我们打印出了Entity和Cherno，一切看起来都很好

24
00:01:48,560 --> 00:01:55,489
但是如果使用多态的概念来看，目前为止我们写的这些都是不合格的

25
00:01:55,489 --> 00:02:01,739
如果我引用这个Player并把它当成Entity类型，就会出现问题

26
00:02:01,780 --> 00:02:08,409
比如，如果我在这里创建一个entity变量， 然后用p给它赋值

27
00:02:08,409 --> 00:02:10,960
p 是一个Player类型的指针

28
00:02:10,960 --> 00:02:15,009
它是一个Player，但是我把它指向了一个Entity

29
00:02:15,020 --> 00:02:18,879
如果我进行打印 "enitiy->GetName()".

30
00:02:18,930 --> 00:02:24,889
运行代码，你会看见打印出了“Entity”,但是我们希望的是打印Player

31
00:02:24,930 --> 00:02:32,479
虽然我们指向的是一个Entity*, 但是它实际上是一个Player, 它是一个Player类的实例

32
00:02:32,610 --> 00:02:38,360
一个可能更好地例子是，假设我们有一个PrintName函数，参数类型是 Entity*

33
00:02:38,360 --> 00:02:48,789
然后是："std::cout << entity->GetName() << std::endl"
接着用"PrintName(e);"和"PrintName(p);"把这些替换掉

34
00:02:48,830 --> 00:02:53,960
现在我们有个可以接受任何类型Entity的函数

35
00:02:53,960 --> 00:02:57,699
你可以看到，当我们给它传入p时，没有提示任何编译错误

36
00:02:57,699 --> 00:03:01,439
因为p其实也是一个Entity,对吧？ Player也是一个Entity

37
00:03:01,439 --> 00:03:07,270
我们这儿做的就是调用entity的GetName函数，我们希望这个GetName作用于Entity

38
00:03:07,539 --> 00:03:10,349
然后这个GetName作用于Player

39
00:03:10,349 --> 00:03:15,979
但是，如果我们运行代码，你会发现我们打印了Entity两次。这是为什么呢？哪里出问题了？

40
00:03:15,979 --> 00:03:20,860
原因是如果我们在类中正常声明函数或方法

41
00:03:20,919 --> 00:03:26,370
当调用这个方法的时候，它总是会去调用属于这个类型的方法

42
00:03:26,599 --> 00:03:31,210
看看这个PrintName函数，它的参数类型是Entity*

43
00:03:31,210 --> 00:03:37,669
意味着它会调用Entity内部的GetName函数，它只会在Entity的内部寻找和调用GetName

44
00:03:38,000 --> 00:03:41,629
但是我们希望C++能意识到

45
00:03:41,669 --> 00:03:47,560
在这里我们传入的其实是一个Player, 所以请调用Player的GetName

46
00:03:47,659 --> 00:03:50,340
这就是要用到虚函数的地方了

47
00:03:50,340 --> 00:03:55,689
虚函数引入了一种要动态分派的东西，一般通过虚表(vtable)来实现编译

48
00:03:55,689 --> 00:04:00,650
虚表就是一个包含类中所有虚函数映射的列表

49
00:04:00,650 --> 00:04:04,659
通过虚表我们就可以在运行时找到正确的被重写的函数

50
00:04:04,659 --> 00:04:08,280
以后我们会深入全面的讲解虚函数是怎么工作的

51
00:04:08,280 --> 00:04:10,610
如果你感兴趣请坚持看下去。

52
00:04:10,610 --> 00:04:17,540
但是简单来说，你需要知道的就是如果你想重写一个函数，你么你必须要把基类中的原函数设置为虚函数

53
00:04:17,639 --> 00:04:18,709
回到代码

54
00:04:18,709 --> 00:04:26,470
只要在基类Entity的GetName函数前面加上virtual

55
00:04:26,470 --> 00:04:32,230
看起来没做什么，但是这样就是在对编译器说：“Hey, 把这个函数设置为虚函数”

56
00:04:32,300 --> 00:04:35,189
“如果它被重写了，你可以找到正确的函数”

57
00:04:35,199 --> 00:04:37,730
有了这些改动，按F5运行代码

58
00:04:37,730 --> 00:04:41,399
看这里，我们正确地打印了Entity和Cherno

59
00:04:41,399 --> 00:04:48,529
另外可以做的是：C++11新标准允许给被重写的函数用“override”关键字标记

60
00:04:48,579 --> 00:04:49,560
写在这里

61
00:04:50,079 --> 00:04:54,370
当然，这不是必须的，你能看到我们刚刚没有写代码仍能正常运行

62
00:04:54,370 --> 00:04:56,290
但是，你还是应该写上

63
00:04:56,290 --> 00:05:00,879
因为首先，这让代码可读性更好，这很容易让我们知道这个函数被重写了

64
00:05:00,879 --> 00:05:05,240
然后这还可以帮助我们预防bug,比如拼写错误等

65
00:05:05,279 --> 00:05:08,759
比如说这里写成了小写n， 你看这回有个报错

66
00:05:08,759 --> 00:05:11,920
这是因为基类里没有一个这样的函数给我们重写

67
00:05:11,920 --> 00:05:14,980
如果我们重写一个没有被virtual标记的函数

68
00:05:14,980 --> 00:05:18,439
你看也会有报错，这很有帮助

69
00:05:18,439 --> 00:05:20,839
好了，这些就是虚函数的基本内容

70
00:05:20,839 --> 00:05:26,149
虚函数并不是没有成本的，有两种虚函数运行时的花费。

71
00:05:26,149 --> 00:05:30,199
一种就是需要额外的内存用来存储虚表

72
00:05:30,199 --> 00:05:37,540
这样我们就可以分配到正确的函数，基类里还有一个指针成员指向虚表

73
00:05:37,540 --> 00:05:43,759
还有就是每次调用虚函数的时候，我们必须要遍历虚表去找到最终要运行的函数

74
00:05:43,759 --> 00:05:45,589
这也是额外的性能损失。

75
00:05:45,589 --> 00:05:49,889
因为这些性能花费，有些人一点也不喜欢用虚函数

76
00:05:50,050 --> 00:05:59,399
说实话，根据我的经验来看，我从没有遇到开销很大的情况
如果不用虚函数也没什么不同

77
00:05:59,399 --> 00:06:02,699
就个人而言，我经常用也没遇到什么问题。

78
00:06:02,699 --> 00:06:09,759
也许在一些嵌入式平台上，CPU的性能确实很差

79
00:06:09,879 --> 00:06:16,910
可能这时候要避免使用虚函数
但总的来说，我不会告诉你说：因为性能别去用虚函数

80
00:06:16,910 --> 00:06:21,079
因为它造成的影响很小，你可能根本觉察不到。

81
00:06:21,079 --> 00:06:23,290
希望你喜欢这个视频

82
00:06:23,290 --> 00:06:27,920
有任何问题请留言，下次见，Goodbye.

