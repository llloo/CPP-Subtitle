1
00:00:00,300 --> 00:00:02,399
Hey 大家好 我是Cherno

2
00:00:02,399 --> 00:00:08,449
欢迎来到我的新一期C++视频，所以今天我们要学习C++是如何工作的

3
00:00:08,470 --> 00:00:13,470
我们目前会尝试保持简单，但我们会学习如何从源文件

4
00:00:13,679 --> 00:00:16,800
也就是文本文件转化到

5
00:00:16,800 --> 00:00:18,870
能运行的可执行二进制文件或者说程序

6
00:00:18,870 --> 00:00:27,320
写一个简单的c++程序的基本工作流程是你有一些源文件，上面有你写的文本

7
00:00:27,429 --> 00:00:31,129
然后把它传入一个编译器，然后编译成某种二进制文件（binary）

8
00:00:31,320 --> 00:00:35,600
这个binary可以说某种库，或者是实际的可执行文件

9
00:00:35,649 --> 00:00:39,750
今天我们主要讲可执行程序或者说可执行binary

10
00:00:39,750 --> 00:00:42,240
所以让我们打开VS来看一下

11
00:00:42,240 --> 00:00:49,000
ok,我们现在看到的是我们之前在讲解如何安装C++的课程中编写的Hello Word 项目

12
00:00:49,200 --> 00:00:52,270
非常简单的程序，但有很多东西在发生着

13
00:00:52,450 --> 00:00:57,270
首先我们有这个#include <iostream>语句，这种叫preprocessor语句（预处理指令）

14
00:00:57,450 --> 00:01:00,670
任何以 # 开头的都是预处理指令

15
00:01:00,880 --> 00:01:06,349
当编译器收到一个源文件时它做的第一件事就是预处理你所有的预处理指令（preprocessor statement）

16
00:01:06,469 --> 00:01:11,474
 这就是为啥它们被称为预处理指令，因为它们发生在真正的编译之前

17
00:01:11,474 --> 00:01:17,500
在此处我们找的是一个叫iostream的文件

18
00:01:17,500 --> 00:01:22,674
该文件里的所有内容会被复制黏贴到目前这个文件里

19
00:01:22,875 --> 00:01:28,375
你include的这些文件一般被称为header file(头文件)，我们今后会详细讨论

20
00:01:28,700 --> 00:01:31,590
我们之所以include这个叫iostream的东西是因为

21
00:01:31,590 --> 00:01:34,469
我们需要一个函数(function)：cout的声明

22
00:01:34,579 --> 00:01:39,329
cout使我们能够打印东西到console（控制台），然后我们有这个main函数，main函数相当重要

23
00:01:39,329 --> 00:01:44,629
因为每个c++程序都有类似这个main函数的东西，它被称作入口点（entry point）

24
00:01:44,750 --> 00:01:52,170
也就是进入我们程序的入口，也就是说当我们要运行我们的程序时，计算机会从该函数里的代码开始执行

25
00:01:52,280 --> 00:01:56,450
程序运行时，我们电脑会一行一行按照顺序运行我们写的代码

26
00:01:56,549 --> 00:02:00,450
当然有一些东西可以打破或者改变执行的顺序

27
00:02:00,530 --> 00:02:04,299
那些很多时候是control flow statements（控制流语句）或者是调用其他函数

28
00:02:04,599 --> 00:02:08,550
但要点就是我们的程序是一行一行被执行的

29
00:02:08,550 --> 00:02:12,879
所以我们程序第一个被执行的就是这句hello world cout语句

30
00:02:12,889 --> 00:02:18,800
然后就是这句cin.get()函数，然后因为这就是我们main函数，的所有东西了

31
00:02:18,949 --> 00:02:20,990
所以我们的程序会终止

32
00:02:20,990 --> 00:02:25,680
对于熟悉函数的同学，你们可能会注意到main函数的返回类型(return type)其实是int（整型）,

33
00:02:25,699 --> 00:02:28,000
然而我们并没有返回一个整数(integer)

34
00:02:28,199 --> 00:02:33,719
这是因为main函数其实是个例外，你不需要从主函数返回任何类型的值

35
00:02:34,125 --> 00:02:39,780
如果你不返回任何值，它会返回0，这只适用于main函数,是个例外

36
00:02:39,930 --> 00:02:42,550
好了我们再讲一下，这句到底在干嘛

37
00:02:42,680 --> 00:02:48,599
这种语法对c++新手看起来可能会很奇怪，其实写成这样是很不幸的

38
00:02:48,620 --> 00:02:51,319
因为你第一次看它的时候确实看不出来意思

39
00:02:51,469 --> 00:02:56,375
这些向左的带角的括号，看起来有点像左位移符号(bit shift)

40
00:02:56,375 --> 00:02:58,180
其实是被重载的符号

41
00:02:58,180 --> 00:03:02,974
你得把它们想象成一个函数，我知道它们看起来像运算符(operator)

42
00:03:02,974 --> 00:03:06,300
但实际上呢，运算符就是函数

43
00:03:06,300 --> 00:03:11,300
所以在这种情况下就跟类似cout.print一模一样的

44
00:03:11,430 --> 00:03:20,469
然后hello world是我们的parameter（参数）
然后我们可能再接着加一个print，就像这样

45
00:03:20,469 --> 00:03:25,819
你得把这些操作符想象成函数，如果你能这么想象会更好理解一点

46
00:03:25,900 --> 00:03:33,719
所以我们在这边做的就是我们把这个Hello world字符串传入这个cout
cout就是把它打印在控制台里

47
00:03:33,719 --> 00:03:38,949
然后我们又传入一个endl（end line)
endl 就是告诉我们的控制台前进到另一行

48
00:03:39,139 --> 00:03:44,800
cin.get()函数在我们这种情况下其实就是等待我们输入回车
然后才会接着执行底下一行代码

49
00:03:44,849 --> 00:03:51,599
我们底下一行当然什么也没有，我就是说我们的程序会在这一行暂停，直到我们按回车

50
00:03:51,599 --> 00:03:54,319
因为这个函数基本上就是会等待我们输入回车

51
00:03:54,319 --> 00:04:00,379
然后我们进入下一行，下一行什么也没有
也就是说会返回0，说明我们的程序成功运行了

52
00:04:00,550 --> 00:04:02,925
这就是我们的整个程序了。

53
00:04:02,925 --> 00:04:08,599
okay 所以这是我们的源文件，我们其实有这样一个main.cpp
也就是我们源文件

54
00:04:08,870 --> 00:04:13,500
我们怎么从这个文件到可执行程序呢

55
00:04:13,500 --> 00:04:16,240
基本上我们会经历几个阶段

56
00:04:16,240 --> 00:04:24,800
首先是这个include iostream，就是我们所说的preprocessor语句
会在编译文件之前被评估

57
00:04:24,800 --> 00:04:29,899
这句呢其实就是把iostream文件里，的所有内容拷贝到这个文件里

58
00:04:30,125 --> 00:04:36,500
就是字面意思，拷贝和粘贴include的文件内容到当前这个文件里

59
00:04:36,500 --> 00:04:42,500
如我之前所说，之后我会更深入的讲，所以现在别太担心不懂它

60
00:04:42,629 --> 00:04:49,199
目前你需要知道的就是我们include这个文件，就是为了用cout和cin这两个函数

61
00:04:49,230 --> 00:05:01,180
当我们的preprocessor被评估以后，我们的文件会被编译。
这个阶段，编译器把我们的c++代码转化成实际的机器码

62
00:05:01,360 --> 00:05:06,100
其实有几个很重要的设置来决定这一切是如何发生的，我们简单看一下它们

63
00:05:06,100 --> 00:05:14,600
在vs里，有这两个重要的下拉选项，一个叫solution configuration（方案配置），一个叫solution platform（方案平台） 

64
00:05:14,629 --> 00:05:19,819
默认会被设为debug，然后要么是x86 或者win32，它俩一回事

65
00:05:19,819 --> 00:05:26,000
如果我们点开debug，你会看到有两个选项，debug和release，
这两个选项在vs里是新建项目时的默认设置

66
00:05:26,050 --> 00:05:32,774
然后在方案平台里有x64 和x86两个选项,它们依然只是默认选项

67
00:05:32,774 --> 00:05:37,914
配置(configuration)只是一系列规则用于如何build一个项目

68
00:05:38,000 --> 00:05:44,129
而solution platform呢，是我们的目前编译的目标平台

69
00:05:44,129 --> 00:05:51,949
举个例子x86就是定位于32位windows，也就是说我们会生成一个用于windows的32位的程序

70
00:05:52,324 --> 00:05:54,699
更复杂的项目可能会面向不同的平台

71
00:05:54,699 --> 00:06:04,319
你可能会有一个安卓平台，然后如果你想build、部署、以及debug安卓程序，你就得把平台改成安卓

72
00:06:04,480 --> 00:06:09,430
至于solution configuration，是定义如何为这个平台编译的一系列规则

73
00:06:09,579 --> 00:06:12,899
我们来看一下有哪些规则可以改

74
00:06:12,970 --> 00:06:15,189
在项目上右击，选properties（属性）

75
00:06:15,189 --> 00:06:21,930
这就是vs的properties页面，这些就是定义在哪些配置和平台去如何build的一些规则

76
00:06:21,930 --> 00:06:34,550
首先你要注意的是这个configuration和platform两个区域，确保你的configuration和platform有被设置为你确实想要修改的那个选项

77
00:06:34,550 --> 00:06:39,250
有时候鬼知道什么原因会被设置到release选项，而你显然在build一个debug的

78
00:06:39,339 --> 00:06:42,449
那么这边所有的改变都不会被应用到你目前的配置

79
00:06:42,449 --> 00:06:47,269
如果你忘了这一点，你可能会疑惑为啥不管用，我就砰到好几次了,是挺烦的

80
00:06:47,350 --> 00:06:56,629
我们在这个debug配置了，你看我们这里有win32，win32就是x86，一模一样的，不知为啥有不同名字

81
00:06:56,629 --> 00:07:02,500
这里有一些sdk的基本信息，版本啊，输出目录，中继目录和一些其他东西

82
00:07:02,699 --> 00:07:06,930
需要注意的是，我们项目的Configuration type是设置为Application的

83
00:07:06,930 --> 00:07:10,399
如果我们想要一个库，可以在这里更改

84
00:07:10,399 --> 00:07:13,230
但这就是编译会产出的二进制文件了

85
00:07:13,300 --> 00:07:16,699
由于我们本来就要一个可执行程序，就选application.exe了

86
00:07:16,730 --> 00:07:20,629
编译器设置位于这个C/C ++这里

87
00:07:20,750 --> 00:07:23,000
这里有一些重要设定，比如additional include directories、

88
00:07:23,129 --> 00:07:33,500
可能需要用到的优化设置、代码生成设置、预处理定义，以及一大堆我们近期都不会触及的东西

89
00:07:33,569 --> 00:07:37,819
vs的默认设置其实蛮不错的，所以我们其实不用做什么

90
00:07:37,889 --> 00:07:41,769
但这些就是决定我们的文件被如何编译的规则了

91
00:07:41,939 --> 00:07:45,629
你可以很明显地看到debug和release配置的区别

92
00:07:45,750 --> 00:07:52,220
如果你进入optimization（优化）标签，把configuration改成release，就可以看到optimization被设置成maximize speed（速度最大化）

93
00:07:52,220 --> 00:07:59,879
而在debug下是disabled（禁用）状态，这就是debug模式默认会比release慢许多的原因之一

94
00:07:59,879 --> 00:08:06,129
因为优化被关了，当然关闭优化会有助于我们debug，之后我们就会发现了

95
00:08:06,300 --> 00:08:14,850
如果你想知道编译器怎么工作的，我专门做了一期视频深入解释，如果你感兴趣，请去查看

96
00:08:14,850 --> 00:08:16,269
链接在youtube视频的描述里

97
00:08:16,399 --> 00:08:23,500
所有.cpp文件都会被编译，而头文件(header file)则不会，只有cpp

98
00:08:23,500 --> 00:08:31,274
记住header file通过preprocessor被include到cpp文件里，那是它们被编译的时候

99
00:08:31,519 --> 00:08:36,299
所以我们有一堆cpp文件被编译，而且它们是一个个单独被编译的

100
00:08:36,539 --> 00:08:44,169
每个cpp文件会被编译成一个object文件，扩展名的话，用windows编译器是.obj

101
00:08:44,269 --> 00:08:53,830
当我们有了一个个obj文件，也就是cpp文件被编译过后的结果，我们得有办法把它们联系起来，组成一个exe

102
00:08:53,980 --> 00:08:56,240
这时就是我们的朋友linker（链接器）的用武之处了

103
00:08:56,240 --> 00:09:04,500
你可以在linker标签下看到linker的设定，但基本上linker就是把所有obj拿过来，然后把它们联系起来

104
00:09:04,500 --> 00:09:11,100
所以linker的作用就是把所有obj缝起来组成一个exe文件

105
00:09:11,100 --> 00:09:17,409
当然它究竟怎么做到的其实很复杂，所以我也做了一个视频讲它

106
00:09:17,409 --> 00:09:20,169
记得去看哟，链接在描述里

107
00:09:20,169 --> 00:09:22,299
我们来实际看看它运行

108
00:09:22,299 --> 00:09:30,629
首先我打算只编译这个cpp文件，在vs里，你可以按ctrl + F7 单独编译文件

109
00:09:30,700 --> 00:09:35,730
在output窗口可以看到我们在building这个main.cpp文件，而且成功了

110
00:09:35,980 --> 00:09:39,230
如果不想按ctrl+F7的话，可以调出这个compile按钮

111
00:09:39,230 --> 00:09:50,149
可以右击这里，然后点击build，然后点add/remove buttons->customize->add command，选build，找到compile

112
00:09:50,250 --> 00:09:53,700
所以点击这个按钮以后，我们的文件就在编译了

113
00:09:53,700 --> 00:10:00,519
如果我们有什么语法错误，比如说少了个分号，就可以看到提示error

114
00:10:00,519 --> 00:10:08,659
vs会有很多方式呈现错误，其中一种是这个error list，另一种是在output窗口

115
00:10:08,830 --> 00:10:13,730
我现在就可以告诉你，这个error list基本上没什么用

116
00:10:13,950 --> 00:10:17,304
它可能会显得易读，特别是像这种错误

117
00:10:17,304 --> 00:10:21,480
但你千万别指望它，很多时候它都缺失了很多信息

118
00:10:21,480 --> 00:10:32,799
error list的工作原理其实是，解析(parse)output窗口，找error关键字，然后从那找信息，放入这个list

119
00:10:32,899 --> 00:10:36,580
是一个不错的概述，你只能把它当概述看

120
00:10:36,649 --> 00:10:42,730
但如果你要根具体的、所有的错误信息，你只能通过output窗口

121
00:10:42,730 --> 00:10:48,500
所以本系列接下来我都只会通过output看error信息，请务必习惯

122
00:10:48,580 --> 00:10:54,669
可以看到这里说有个语法错误，大括号前缺少一个 “;”

123
00:10:54,799 --> 00:11:02,240
它会告诉你error发生在哪一行，如果你双击它，会带你到源码中到错误处 

124
00:11:02,240 --> 00:11:10,700
所以让我们来加个分号改正它，再次按ctrl+F7来build这个文件，然后我们就获得了编译好的文件

125
00:11:11,220 --> 00:11:16,980
当你单独编译一个文件，linking（链接）显然不会发生，因为你是编译单独一个文件

126
00:11:17,240 --> 00:11:21,389
所以linker完全没工作，我们去看看编译器到底生成了啥

127
00:11:21,389 --> 00:11:28,490
如果你右击我们的项目，这里有个Open file in File Explorer选项，这个会打开文件管理器

128
00:11:28,490 --> 00:11:36,299
默认vs会build到这个Debug文件夹，进去可以看到有个main.obj文件

129
00:11:36,299 --> 00:11:43,629
这是编译器生成的obj文件，再说一遍，项目里每个c++文件都会产生这么一个obj

130
00:11:43,879 --> 00:11:51,870
如果我们回到vs，build整个项目，也就是不止编译一个文件,而是整个项目

131
00:11:51,870 --> 00:11:55,419
可以看到我们生成了这个exe

132
00:11:55,500 --> 00:12:01,480
如果我们回到文件管理器，它会在solution目录下，debug文件夹

133
00:12:01,679 --> 00:12:07,799
是的，vs默认地址有点诡异，我一般喜欢改掉，但现在我不打算搞的很复杂

134
00:12:07,799 --> 00:12:13,169
然后就是可以运行的hello world.exe，然后打印出hello world

135
00:12:13,379 --> 00:12:18,330
这是个简单的概观，但如果我们有多个c++文件呢

136
00:12:18,419 --> 00:12:23,399
我们来看个简单的例子，假设我们有打印hello world到控制台

137
00:12:23,519 --> 00:12:27,580
但我不想用这个cout，而想用我自己的logging函数

138
00:12:27,750 --> 00:12:30,149
那个可能会包装这个cout

139
00:12:30,299 --> 00:12:41,750
我们来写个Log函数，会接受一个cstring作为参数,取名为message,并打印该message到控制台

140
00:12:41,970 --> 00:12:49,830
非常简单，如果你现在还不懂什么是const char*，别担心，我们会在今后的视频讲string

141
00:12:50,000 --> 00:12:55,500
暂时你只要知道，const char* 就是存储一个一串字符

142
00:12:55,629 --> 00:12:59,879
所以现在我们可以把我们代码改成用log而非cout，然后打印hello world

143
00:13:00,000 --> 00:13:10,240
调用log函数，传入参数hello world，然后点local windows debugger，确认还可以工作

144
00:13:10,240 --> 00:13:15,240
可以看到成功了，很好，我们写了第一个函数，挺简单的

145
00:13:15,269 --> 00:13:22,200
现在我们把它放入另一个文件，因为我不想main.cpp充斥着许多代码

146
00:13:22,769 --> 00:13:26,629
我想分成多个文件，保持清爽有条理

147
00:13:27,240 --> 00:13:32,169
我们在source files下新建一个文件，右键，add new item

148
00:13:32,350 --> 00:13:37,250
建个cpp，管它叫log.cpp，点add

149
00:13:37,419 --> 00:13:46,269
然后我打算回到main，剪切这个log函数，粘贴到这

150
00:13:46,480 --> 00:13:51,200
现在log.cpp里有个叫log到函数了。我们试着编译下单独这个文件

151
00:13:51,370 --> 00:13:56,649
嘿，看碰到许多errors，如果你看output窗口，你会发现说cout不是STD的member(成员)

152
00:13:56,649 --> 00:14:04,600
这基本上在说它不懂cout到底是啥，原因是我们没有把cout的声明include进来

153
00:14:04,669 --> 00:14:09,149
c++里每个symbol都需要某种形式的声明

154
00:14:09,279 --> 00:14:16,480
cout是在main里include的文件里定义的一个函数，那个文件也就是iostream

155
00:14:16,575 --> 00:14:21,675
让我们把iostream剪切到这个文件上方，从而include iostream

156
00:14:21,940 --> 00:14:25,549
这样做，我们就include了cout的声明

157
00:14:25,649 --> 00:14:29,730
我们再次编译该文件，可以到成功了，很好

158
00:14:29,980 --> 00:14:35,169
回到main，我想调用这个log函数，我们可以吗？按ctrl+F7，不行

159
00:14:35,169 --> 00:14:45,879
因为log找不到，我们也收到一个关于cin的抱怨，我们已经知道这是因为没有include iostream，所以它不知道是啥

160
00:14:46,129 --> 00:14:50,379
我们可以恢复这个include，我们的问题就解决了

161
00:14:50,500 --> 00:14:59,419
然后log还是找不到，为啥呢，我们把一个函数从一个文件移动到了另一个

162
00:14:59,769 --> 00:15:08,230
我们是分别编译它们的，所以main.cpp不知道有个叫log的函数在哪

163
00:15:08,230 --> 00:15:15,980
由于它识别不出，所以向我们报告编译错误，我们可以通过提供一个声明(declaration)来解决

164
00:15:16,750 --> 00:15:22,580
一个声明，就是字面意思，声明一个叫log的东西是存在的

165
00:15:22,629 --> 00:15:31,149
这其实有点像承诺，因为我们可以告诉编译器有个函数叫log，而编译器就真的会相信

166
00:15:31,389 --> 00:15:35,980
这就是编译器的美好之处，编译器会说，是吗，好的，我完全信任你

167
00:15:35,980 --> 00:15:41,000
因为编译器根本不关心resolving（解析）log到底在哪被定义的

168
00:15:41,139 --> 00:15:44,600
所以这里有两个词汇，declaration（声明）和definition（定义）

169
00:15:44,799 --> 00:15:50,330
声明就是说这个symbol这个函数存在

170
00:15:50,500 --> 00:15:57,500
定义则是说这个函数到底是什么，这是这个函数主体

171
00:15:57,500 --> 00:16:00,879
那我们来写个log的声明

172
00:16:00,879 --> 00:16:16,399
声明看起来很像实际的定义，这个就是定义，我们不仅声明了名字log，而且有主体(body),里面含有代码 

173
00:16:16,509 --> 00:16:25,100
回到main，声明很像定义，但缺的是body

174
00:16:25,200 --> 00:16:29,950
你看我只需要在最后打一个分号就完事了

175
00:16:29,950 --> 00:16:35,419
实际上，你都不需要提供参数的名字，因为不需要，这就可以了

176
00:16:35,730 --> 00:16:39,730
但根据经验法则，我还是喜欢给个名字，因为更好理解

177
00:16:39,850 --> 00:16:44,559
我们来编译一下，看，编译器完全信了我们的鬼话

178
00:16:44,559 --> 00:16:55,149
在这个时候，你可能会问，编译器怎么知道我有个log在别的文件里呢，如果我们只是编译这一个文件

179
00:16:55,250 --> 00:17:04,549
回答是它不知道，它信我们，那你的下一个问题就会是它怎么知道运行正确的代码

180
00:17:04,650 --> 00:17:07,119
这就是linker出场的时候了

181
00:17:07,119 --> 00:17:12,599
当我们build整个项目而非单独文件时，如果我右键然后选build

182
00:17:12,750 --> 00:17:21,170
当我们的文件被编译后，linker会去找log的定义，然后跟我们main里调用的联系起来

183
00:17:21,170 --> 00:17:25,700
如果它找不到定义，我们会得到一个linker error

184
00:17:25,829 --> 00:17:33,170
很多人很怕linking error，我们来看看例子

185
00:17:33,450 --> 00:17:39,970
如果我现在run，你可以看到还是可以打印hello world，一切ok

186
00:17:40,170 --> 00:17:46,970
然而，让我们拿掉这个，或者至少改下这个，改成logr，保存

187
00:17:47,450 --> 00:17:50,900
回到main，我会试着单独编译这个文件

188
00:17:51,490 --> 00:17:56,349
可以看到没有任何问题，但右击hello world然后build，

189
00:17:56,349 --> 00:18:03,130
看啊，我们拿到了这个吓人的error信息，在output里看起来很可怕

190
00:18:03,250 --> 00:18:08,670
之所以看起来吓人是因为有一些额外的信息，关于函数签名（signature）的

191
00:18:08,829 --> 00:18:12,799
比如这里，有calling convention以及实际的ID

192
00:18:12,799 --> 00:18:17,920
但它基本上在告诉你，你有一个没有被解析的外部标记(external symbol)叫log

193
00:18:18,200 --> 00:18:24,250
它有这样一个返回类型和这些参数，然后你在main里引用(referencing)它

194
00:18:24,400 --> 00:18:28,900
一个unresolved external symbol意思是linker无法解析一个symbol

195
00:18:29,049 --> 00:18:33,514
记住，linker的工作就是resolve symbols，联通各个函数

196
00:18:33,579 --> 00:18:41,400
而它无法找到log应该跟谁联系起来，因为我们没有log这个函数被定义

197
00:18:41,660 --> 00:18:51,829
我们可以通过更正函数名来解决，我们需要提供log的定义，也就是说提供一个body

198
00:18:52,000 --> 00:18:56,450
没说一定要在这个文件里，也可以在main里，但必须存在于某处

199
00:18:56,529 --> 00:18:59,269
编译它，没有任何错误了

200
00:18:59,269 --> 00:19:04,400
如果我们回到文件管理器，看看在我们的中继(intermediate)目录下有啥

201
00:19:04,400 --> 00:19:11,380
可以看到我们有两个obj，因为编译会为每个cpp生产一个obj

202
00:19:11,400 --> 00:19:14,799
然后linker会拿到它们，串成一个exe

203
00:19:14,920 --> 00:19:24,170
所以在我们这个例子里，我们的log定义在这个log.obj里，main函数在main.obj

204
00:19:24,329 --> 00:19:34,250
然后linker会把log的定义拿到一个公共的binary里，也就是hello world.exe

205
00:19:34,549 --> 00:19:37,799
它包含log和main的定义

206
00:19:37,799 --> 00:19:41,170
这就是一个c++如何工作的概览了

207
00:19:41,500 --> 00:19:46,250
再次强烈推荐大家去看深入解读编译和链接的视频

208
00:19:46,309 --> 00:19:56,200
因为它们相比本视频有更多信息，本视频只是大概讲一下从源文件到binary的管线

209
00:19:56,779 --> 00:20:13,849
别忘记关注我...

