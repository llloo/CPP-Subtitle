1
00:00:00,000 --> 00:00:03,850
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:03,850 --> 00:00:10,449
上次我们讲到虚函数，今天我讲讨论一种特殊的虚函数——纯虚函数，

3
00:00:10,560 --> 00:00:17,769
C++中的纯虚函数的本质上和其他语言(比如java和c#)中的抽象方法和接口相同

4
00:00:17,859 --> 00:00:24,199
原理上来讲，纯虚函数允许我们定义一个在基类中没有实现的函数

5
00:00:24,500 --> 00:00:28,449
然后强制子类中去实现这个函数

6
00:00:28,500 --> 00:00:32,880
如果我们看一下之前关于虚函数的那期视频

7
00:00:33,159 --> 00:00:36,600
你可以看到在Entity类内部我们有一个Getname虚函数

8
00:00:36,625 --> 00:00:40,524
然后我们在Player类中重写那个函数

9
00:00:40,524 --> 00:00:44,424
如果在基类中的虚函数带有实际函数体

10
00:00:44,424 --> 00:00:48,479
这意味着在子类中重写函数（比如player类）是完全可选择的（可写可不写）

11
00:00:48,479 --> 00:00:51,829
如果我们没有重写它，我们仍然可以调用player.GetaNme

12
00:00:51,950 --> 00:00:54,650
但是它会返回”Entity"字符串

13
00:00:54,750 --> 00:00:59,750
然而在某些情况下提供默认实现对我们来说毫无意义

14
00:00:59,920 --> 00:01:04,920
实际上我们可能想强制子类为某个特定的函数提供自己定义

15
00:01:05,030 --> 00:01:14,200
在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的

16
00:01:14,299 --> 00:01:16,900
这通常被称为接口

17
00:01:17,099 --> 00:01:22,310
接口就是一个只包含未实现的方法并作为一个模板的类

18
00:01:22,674 --> 00:01:31,219
并且由于此接口类实际上不包含方法实现，所以我们无法实例化这个类。

19
00:01:31,219 --> 00:01:36,219
接下来让我们看看是否可以将Entity类内的GetName函数设置为纯虚函数

20
00:01:36,219 --> 00:01:40,099
我要删除这个函数体，然后只写上”=0“

21
00:01:40,400 --> 00:01:47,269
请记住，这仍然被定义为虚函数，但是=0实际上将它变成了一个纯虚函数

22
00:01:47,439 --> 00:01:52,900
这意味着如果你想实例化这个类，那么这个函数必须在子类中实现

23
00:01:52,950 --> 00:01:55,625
通过这个改动，有些事情发生了

24
00:01:55,625 --> 00:02:02,420
首先，你看main函数，你可以看到我们不能再去实例化Entity类

25
00:02:02,420 --> 00:02:07,469
在这里我们必须给它一个实际上实现了这个函数的子类

26
00:02:07,525 --> 00:02:12,995
在这种情况下，就拿player来说，当然这里要传入一个字符串Player才能工作

27
00:02:13,000 --> 00:02:17,650
然而这只是因为我们实现了那个GetName函数

28
00:02:17,650 --> 00:02:23,650
如果我将其注释掉 你可以看到我们也不能实例化Player类了

29
00:02:23,900 --> 00:02:29,699
所以很明显你只能实例化一个实现了所有纯虚函数的类

30
00:02:29,810 --> 00:02:31,819
或者类在更深层次的继承中

31
00:02:31,870 --> 00:02:37,250
假如说，Player类就是在另一个实现GetName函数的类的子类

32
00:02:37,310 --> 00:02:46,199
那这样也可以。重点就是纯虚函数必须被实现，然后我们才能创建这个类的实例

33
00:02:46,439 --> 00:02:51,439
好了，让我们看一个更好的例子 ，我先撤销之前做的操作

34
00:02:51,560 --> 00:02:57,550
很好，假设我们想编写一个打印这儿所有类名的函数。

35
00:02:57,689 --> 00:03:00,030
先写上 void Print()

36
00:03:00,199 --> 00:03:05,199
在参数上我想写某种类的类型，然后是obj

37
00:03:05,330 --> 00:03:13,780
然后我要打印类名，所以可能我们有obj->GetClassName

38
00:03:13,819 --> 00:03:20,569
这里我实际需要的是一种类型，该类型保证类内有GetClassname函数

39
00:03:20,740 --> 00:03:25,740
我们需要这种类型能提供GetClassName函数，这就是接口

40
00:03:25,800 --> 00:03:29,550
让我们继续，然后将这个类型命名为Printable，然后来设置它

41
00:03:29,550 --> 00:03:32,974
在最上面，创建一个新类Printable

42
00:03:33,142 --> 00:03:45,449
我唯一要做的就是创建一个 public: virtual std::string GetClassName 函数, 返回一个字符串，它是纯虚函数，要把它设置为=0.

43
00:03:45,449 --> 00:03:50,449
然后我要让Entity实现拿个接口，注意现在Player已经是一个Entity了

44
00:03:50,530 --> 00:03:55,530
所以Player不用去实现Printable接口，但是不管什么原因如果不是Entity的话，

45
00:03:55,530 --> 00:03:58,800
我们还是要添加一个逗号，然后去实现那个接口

46
00:03:58,969 --> 00:04:08,209
注意，我虽然一直把它叫做接口，但实际上它还是一个类
我之所以称它为接口，只是因为它有一个纯虚函数，仅此而已

47
00:04:08,210 --> 00:04:13,210
其他语言在类中的确有”interface“关键字来代替class，但是c++没有

48
00:04:13,209 --> 00:04:15,250
接口就是C++中的类而已

49
00:04:15,349 --> 00:04:20,350
现在所有的类都要实现去GetClassName，不然的话你就不能实例化这个类

50
00:04:20,500 --> 00:04:25,500
让我们继续再Entity中增加GetClassname函数的实现

51
00:04:25,550 --> 00:04:34,350
现在，如果在像之前在Player中那样做，[coding...]会出现一些问题

52
00:04:34,470 --> 00:04:39,680
首先不能实例化的问题解决了，因为我们已经提供了那个函数

53
00:04:39,800 --> 00:04:43,069
但是你会注意到我们还没有为Player提供那个函数

54
00:04:43,199 --> 00:04:50,180
所以如果我们要打印的话，把这里改成指针，然后调用Print，分别传入Player和Entity实例

55
00:04:50,449 --> 00:04:53,425
注释掉PrintName，免得影响到我们

56
00:04:53,425 --> 00:04:59,300
按F5，你可以看到Entity被打印了两次，因为我们还没在Player中提供定义

57
00:04:59,439 --> 00:05:04,439
如果我要这么做，复制GetClassName，当然别忘了这里加上override

58
00:05:04,519 --> 00:05:13,129
把它粘贴到下面，这里改成player，按F5运行代码，你能看到打印了正确的类名

59
00:05:13,360 --> 00:05:19,819
所有的打印都来自于这个Print函数，它接受printable对象，它不关心实际是什么类

60
00:05:19,959 --> 00:05:28,350
我们可以创建一个完全不一样的类，比如一个printable类型的A ，它必须包含GetClassName函数

61
00:05:28,430 --> 00:05:33,430
如果没有的话就不能实例化，

62
00:05:33,540 --> 00:05:40,170
如果我这样做，我就创建了一个全新的类，并且实现了Printable这个接口，也就是实现了这个函数

63
00:05:40,170 --> 00:05:46,074
现在可以这样调用print函数，当然，最好不要这样写代码，可能造成内存泄漏

64
00:05:46,199 --> 00:05:51,750
但是如果是自己测试是没问题的。现在你可以看到我们打印出了A

65
00:05:51,800 --> 00:05:56,800
因为它也是一个Printable，这保证了它有GetClassName函数，这就是整件事的工作原理

66
00:05:56,930 --> 00:06:02,769
因为它知道任何Printable的对象都有一个GetClassName函数可以被调用

67
00:06:02,850 --> 00:06:07,850
如果你没有实现这个函数，那么你就不能实例化这个类

68
00:06:08,100 --> 00:06:14,475
仅此而已，这就是C++中的的接口，这就是C++中的的纯虚函数
非常有用的东西

69
00:06:14,475 --> 00:06:22,225
用在刚刚这种场景下的原因就是为了确保这个类都有个特定的方法

70
00:06:22,345 --> 00:06:28,074
 那么就可以将这个类作为参数传入一个通用的函数，然后我们就可以调用这个函数或者做些其他事

71
00:06:28,074 --> 00:06:37,250
希望大家喜欢这个视频，如果有问题可以在评论区留言...
下次见，GoodBye!

