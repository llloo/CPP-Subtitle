1
00:00:00,000 --> 00:00:03,359
Hey，大家好，我是Cherno，欢迎回到我的C++系列课程

2
00:00:03,359 --> 00:00:08,199
前几集我们学习了static关键字在特定上下文中的含义

3
00:00:08,199 --> 00:00:12,960
今天，我们将要学习另一个可能用到static的情境

4
00:00:12,960 --> 00:00:14,349
就是在局部作用域中

5
00:00:14,349 --> 00:00:17,879
你可以在局部作用域中用static来声明变量

6
00:00:17,879 --> 00:00:21,629
这和我们之前学过的另外两种static的用法不同

7
00:00:21,629 --> 00:00:23,920
只要你理解了声明变量时要考虑的两点

8
00:00:23,920 --> 00:00:27,929
很容易就能理解这种不同

9
00:00:27,929 --> 00:00:31,780
这两点就是变量的生命周期和作用域

10
00:00:31,780 --> 00:00:35,450
生命周期的意思是变量实际的存在时间

11
00:00:35,450 --> 00:00:39,240
也就是变量在被删除之前在内存中停留多久

12
00:00:39,240 --> 00:00:43,039
作用域就是我们可以访问这个变量的范围

13
00:00:43,039 --> 00:00:46,320
比如说我们在一个函数的内部声明了一个变量

14
00:00:46,320 --> 00:00:48,450
那我们就不能在其他函数里访问到这个变量

15
00:00:48,450 --> 00:00:52,579
因为我们声明的变量相对于我们声明的函数是“局部的”

16
00:00:52,579 --> 00:00:56,649
而静态局部(local static)变量允许我们声明一个变量

17
00:00:56,649 --> 00:01:00,420
它的生命周期是整个程序的生存期

18
00:01:00,420 --> 00:01:04,590
但是作用域被限制在这个函数里

19
00:01:04,590 --> 00:01:07,920
其实也不一定是函数

20
00:01:07,920 --> 00:01:09,629
你可以在任何作用域中声明变量

21
00:01:09,629 --> 00:01:11,650
我只是用函数举例

22
00:01:11,650 --> 00:01:14,349
不一定非要是函数

23
00:01:14,530 --> 00:01:17,409
也可以是if语句，或者其他任何地方

24
00:01:17,409 --> 00:01:22,730
这就是为什么 函数作用域中的static 和类作用域中的 static 之间没有太大的区别

25
00:01:22,730 --> 00:01:25,920
因为它们的生命周期是一样的

26
00:01:25,920 --> 00:01:34,460
唯一的区别是类作用域中的静态变量 类内部的任何东西都能访问到它(静态变量)

28
00:01:34,719 --> 00:01:38,810
但是 如果你在函数作用域中声明静态变量 那它就是函数的局部变量

29
00:01:38,810 --> 00:01:40,180
就像类的静态变量对类也是“局部”的

30
00:01:40,319 --> 00:01:41,920
我们看一看示例

31
00:01:41,920 --> 00:01:45,150
最简单的例子 我们创建一个函数

32
00:01:45,400 --> 00:01:47,870
再在里面声明一个静态变量

33
00:01:47,870 --> 00:01:50,530
写上 static int i = 0;

34
00:01:50,859 --> 00:01:54,560
这句的意思是 当我第一次调用这个函数时

35
00:01:54,560 --> 00:01:56,909
它的值被初始化为0

36
00:01:56,909 --> 00:02:02,010
后续调用不会再创建一个新的变量

37
00:02:02,010 --> 00:02:05,760
简单证明如下 我在函数里打印i

38
00:02:05,760 --> 00:02:08,590
同时每次调用函数时让i自增1

39
00:02:08,590 --> 00:02:12,030
如果这里没有static 结果会是

40
00:02:12,030 --> 00:02:15,159
每次调用这个函数 i的值被设为0

41
00:02:15,159 --> 00:02:18,819
然后i自增1 向控制台输出1

42
00:02:18,900 --> 00:02:22,650
我们多调用几次

43
00:02:22,650 --> 00:02:26,030
调用5次 我们向控制台输出5次

44
00:02:26,289 --> 00:02:28,509
你可以看到1被输出了5次

45
00:02:28,509 --> 00:02:31,610
我刚才解释了 每次调用都会创建一个变量

46
00:02:31,610 --> 00:02:33,099
然后将它的值设为0

47
00:02:33,280 --> 00:02:36,449
自增到1 然后输出到控制台

48
00:02:36,449 --> 00:02:39,060
现在如果我们把它设为静态(static)的

49
00:02:39,060 --> 00:02:45,409
就会和 在这里声明（全局变量） 很相似

50
00:02:45,579 --> 00:02:46,979
如果我们运行这段代码

51
00:02:46,979 --> 00:02:49,229
是不是静态变量都没关系

52
00:02:49,229 --> 00:02:50,670
在这里是一样的

53
00:02:50,670 --> 00:02:55,840
如果不知道这里静态变量是什么意思 可以看P21

54
00:02:55,840 --> 00:02:57,659
运行这段代码

55
00:02:57,659 --> 00:03:00,759
一开始i等于0 然后自增5次

56
00:03:00,759 --> 00:03:03,849
会得到1 2 3 4 5

57
00:03:03,849 --> 00:03:06,419
但是这种方法的问题是

58
00:03:06,539 --> 00:03:08,500
我能在任何地方访问到i

59
00:03:08,610 --> 00:03:13,300
我可以在这里 在函数调用之间 把i设为10

60
00:03:13,300 --> 00:03:16,819
这一下就大大改变了程序的结果

61
00:03:17,000 --> 00:03:20,050
所以 在你想要这种效果

62
00:03:20,050 --> 00:03:24,449
又不想要任何人都能访问到这个变量时

63
00:03:24,449 --> 00:03:26,409
你可以在局部作用域下面声明静态变量

64
00:03:26,409 --> 00:03:29,879
现在我们删掉这句 把变量移到函数作用域里

65
00:03:30,319 --> 00:03:32,319
在前面加上static关键字

66
00:03:32,319 --> 00:03:38,650
再解释一遍 我们第一次调用函数时 创建变量 它的值被设为0

67
00:03:38,810 --> 00:03:42,129
接下来的调用 i还是指向原来的变量(初次调用创建的变量)

68
00:03:42,129 --> 00:03:46,009
我现在运行代码 你可以看到 1 2 3 4 5

69
00:03:46,009 --> 00:03:48,050
效果和之前一样

70
00:03:48,050 --> 00:03:52,750
但是i不能在全局被访问到 只能在函数内的局部作用域访问到

71
00:03:52,750 --> 00:03:57,280
至于用法 有些人不喜欢这种用法

72
00:03:57,280 --> 00:04:02,129
理由我也不是很懂 因为我不认为这有什么问题

73
00:04:02,569 --> 00:04:03,969
它当然有它的用处

74
00:04:03,969 --> 00:04:09,280
有些人说 用别的方法和用静态变量效果一样

75
00:04:09,490 --> 00:04:11,810
他们也可以对类这么说

76
00:04:12,259 --> 00:04:15,419
就像你编写程序也不必一定要用类

77
00:04:15,419 --> 00:04:17,050
但是 局部静态变量确实可你让你编程更轻松

78
00:04:17,230 --> 00:04:18,529
就像这里一样

79
00:04:18,529 --> 00:04:21,949
这是可以让你的代码更简洁的一种方法

80
00:04:21,949 --> 00:04:24,730
另一个例子是如果你有一个单例的类

81
00:04:24,730 --> 00:04:29,860
单例类 就是这个类只有一个实例存在

82
00:04:29,860 --> 00:04:34,340
如果我想不适用静态局部作用域(local static scope)来创建一个单例类

83
00:04:34,340 --> 00:04:38,300
我得创建某种静态的单例实例

84
00:04:38,300 --> 00:04:41,449
大概是这里放个指针

85
00:04:41,949 --> 00:04:45,279
还得有... 如果你想返回一个引用

86
00:04:45,279 --> 00:04:50,199
我得有个 返回引用类型的Get静态方法

87
00:04:50,199 --> 00:04:53,939
返回解引用后的实例

88
00:04:53,939 --> 00:04:57,659
当然我还得在这里（全局）声明这个实例

89
00:04:57,779 --> 00:05:00,420
Singleton* Singleton::s_Instance = nullptr;

90
00:05:00,639 --> 00:05:03,240
缺省设为nullptr

91
00:05:03,379 --> 00:05:05,949
现在我可以 删掉这些

92
00:05:06,370 --> 00:05:08,750
我现在有了Singleton这个单例类

93
00:05:08,980 --> 00:05:14,290
Singleton::Get(). 然后就可以做我任何想做的事

94
00:05:14,290 --> 00:05:17,199
比如有个方法 void Hello()

95
00:05:17,199 --> 00:05:19,370
我不知道做什么 这就是个例子

96
00:05:19,370 --> 00:05:21,480
调用Hello()方法 一切顺利

97
00:05:21,480 --> 00:05:23,779
得到一个可用的这个类的实例

98
00:05:23,779 --> 00:05:25,149
我们现在可以静态地使用它

99
00:05:25,149 --> 00:05:29,069
这代码量太多了 你并不需要这样做

100
00:05:29,069 --> 00:05:32,569
另一种实现方法 用我们刚学的静态局部变量

101
00:05:32,569 --> 00:05:35,600
像这样 我们删掉这行代码

102
00:05:36,040 --> 00:05:40,699
然后删掉实例的外部定义

103
00:05:41,079 --> 00:05:43,800
然后拓展一下Get()方法

104
00:05:44,740 --> 00:05:48,540
创建一个静态的Singleton实例

105
00:05:48,810 --> 00:05:51,009
然后返回这个实例

106
00:05:52,060 --> 00:05:56,279
就这样 我们有完全相同的效果 一切都保持不变

107
00:05:56,279 --> 00:05:58,040
我们也可以正确执行代码

108
00:05:58,040 --> 00:06:00,339
当然现在这代码没做任何事

109
00:06:00,420 --> 00:06:02,529
你看程序成功执行 没有崩溃

110
00:06:02,529 --> 00:06:07,439
问题解决了 代码也干净了很多

111
00:06:07,819 --> 00:06:11,360
当然如果这里没有static关键字

112
00:06:11,560 --> 00:06:15,019
这个Singleton实例会在栈上创建

113
00:06:15,300 --> 00:06:20,459
运行到这个花括号跳出函数作用域是时就会被销毁

114
00:06:20,610 --> 00:06:23,540
这将会是一个严重错误 特别是这里还是它的引用

115
00:06:23,540 --> 00:06:26,100
如果是返回一个复制 那没什么问题

116
00:06:26,100 --> 00:06:28,379
但是因为我们在这里返回一个引用

117
00:06:28,610 --> 00:06:30,889
这就是一个大问题

118
00:06:30,889 --> 00:06:32,100
但是加上static关键字后

119
00:06:32,100 --> 00:06:35,879
这就把它的生命周期变成了永久

120
00:06:36,159 --> 00:06:40,779
第一次我我调用Get() 将会创建一个Singleton类的实例

121
00:06:41,019 --> 00:06:44,899
之后所有的调用都会返回这个存在的实例

122
00:06:45,259 --> 00:06:48,139
这是一个当你想用的(local static)时的很好的示例

123
00:06:48,139 --> 00:06:50,019
也不一定局限于单例

124
00:06:50,019 --> 00:06:53,519
它们可以帮你 替换初始化函数

125
00:06:53,519 --> 00:06:59,529
比如你要调用一个静态初始化函数

126
00:06:59,529 --> 00:07:02,160
在程序的某个位置来创建所有的对象

127
00:07:02,160 --> 00:07:05,160
这样你可以用静态的Get()方法之类的东西

128
00:07:05,160 --> 00:07:09,050
很多情况下你可以用它来简化代码

129
00:07:09,199 --> 00:07:12,680
你看 它很有用 没有某些人说得那么差

130
00:07:12,680 --> 00:07:15,860
所以 随便用 个人观点

131
00:07:15,860 --> 00:07:19,939
在评论写下你对静态局部变量的看法

132
00:07:19,939 --> 00:07:22,040
下个视频见 再见

