1
00:00:00,000 --> 00:00:03,850
Hey 大家好，我是Cherno，欢迎回到c++系列

2
00:00:03,850 --> 00:00:08,199
今天我们来简单讲讲c++中的static关键字

3
00:00:08,199 --> 00:00:11,970
c++中的static根据上下文有两种意思

4
00:00:11,970 --> 00:00:16,300
一种是在类class或者结构体struct外使用static

5
00:00:16,300 --> 00:00:20,030
另一种是在类class或者结构体struct内

6
00:00:20,059 --> 00:00:21,079
总结一下

7
00:00:21,079 --> 00:00:27,489
类外的static修饰的符号在link阶段是局部的

8
00:00:27,489 --> 00:00:30,730
也就是它只对定义它的编译单元(.obj)可见

9
00:00:30,730 --> 00:00:33,500
而类或者结构体里面的static

10
00:00:33,500 --> 00:00:38,570
表示这部分内存是这个类的所有实例共享的

11
00:00:38,570 --> 00:00:43,439
简单来说，就算你实例化了很多次这个类或结构体

12
00:00:43,439 --> 00:00:46,679
但那个静态(static)变量只会有一个实例

13
00:00:46,679 --> 00:00:49,350
类里面的静态(static)方法也是一样

14
00:00:49,350 --> 00:00:52,679
静态方法里没有该实例的指针(this)

15
00:00:52,679 --> 00:00:57,759
之后会更详细的讲static在类或结构体里的意思——作用域(scope)

16
00:00:57,759 --> 00:01:01,729
详见第43P

17
00:01:01,729 --> 00:01:06,140
但我们今天就只讲类或结构体外面的static

18
00:01:06,140 --> 00:01:07,620
来看代码吧

19
00:01:07,620 --> 00:01:12,760
在这个空的cpp文件里，我们来定义一个static变量

20
00:01:12,760 --> 00:01:17,260
我习惯用s_开头的命名表示这个变量是static的

21
00:01:17,260 --> 00:01:18,909
让它等于5

22
00:01:18,909 --> 00:01:22,969
除了前面的static，它看起来就跟普通的变量一样

23
00:01:22,969 --> 00:01:24,299
这个static是什么意思呢？

24
00:01:24,299 --> 00:01:30,260
它表示这个变量在link的时候只在这个编译单元(.obj)里可见

25
00:01:30,260 --> 00:01:32,930
如果你不清楚c++的编译compile和链接link的原理

26
00:01:32,930 --> 00:01:37,480
请看这个系列的P6(compiler)和P7(linker)

27
00:01:37,480 --> 00:01:41,099
因为你必须搞懂了前面的才能弄懂这个视频的内容

28
00:01:41,099 --> 00:01:48,099
static变量或函数表示在link到它实际的定义时

29
00:01:48,099 --> 00:01:53,159
linker不会在这个编译单元.obj外面找它的定义

30
00:01:53,159 --> 00:01:57,239
同样，这个也最好来看个示例

31
00:01:57,239 --> 00:02:01,489
这里定义了一个等于5的静态变量，我们来看另一个cpp文件

32
00:02:01,489 --> 00:02:03,120
也就是另一个编译单元

33
00:02:03,120 --> 00:02:05,730
这就是个有main函数的cpp文件

34
00:02:05,730 --> 00:02:10,960
我们创建一个跟前面静态变量名字一样的全局变量

35
00:02:10,960 --> 00:02:13,759
让它等于10

36
00:02:13,759 --> 00:02:15,780
打印出来看一下

37
00:02:15,780 --> 00:02:19,360
可以发现编译没问题

38
00:02:19,360 --> 00:02:22,610
运行一下，结果是10

39
00:02:22,610 --> 00:02:27,000
但是回去把static去掉

40
00:02:27,000 --> 00:02:28,680
再编译

41
00:02:28,680 --> 00:02:31,840
可以看到在linking阶段有个link错误

42
00:02:31,840 --> 00:02:36,689
因为s_Variable已经在另一个编译单元里定义了

43
00:02:36,689 --> 00:02:39,729
所以两个全局变量的名字不能一样

44
00:02:39,729 --> 00:02:41,259
一种解决方法是

45
00:02:41,259 --> 00:02:45,090
把这个变成另一个的引用

46
00:02:45,090 --> 00:02:48,409
也就是去掉这里的赋值

47
00:02:48,409 --> 00:02:51,240
再加上extern关键字

48
00:02:51,240 --> 00:02:55,150
它就会在另外的编译单元里找s_Variable的定义

49
00:02:55,150 --> 00:02:57,780
这被称为 external linkage 或者 external linking

50
00:02:57,780 --> 00:02:59,240
如果现在运行代码

51
00:02:59,240 --> 00:03:01,139
可以看到结果是5

52
00:03:01,139 --> 00:03:04,439
因为它是这个s_Variable的引用

53
00:03:04,439 --> 00:03:07,550
但是，假如我把这个变成static

54
00:03:07,550 --> 00:03:11,069
这有点像在class里面声明私有(private)成员

55
00:03:11,069 --> 00:03:14,620
其他的编译单元不能访问s_Variable

56
00:03:14,620 --> 00:03:17,069
linker在全局作用域下找不到它

57
00:03:17,069 --> 00:03:20,210
回到这里编译代码会看到

58
00:03:20,210 --> 00:03:24,150
有个未知外部符号(unresolved external symbol)错误

59
00:03:24,150 --> 00:03:27,479
因为linker在任何地方都找不到s_Variable的定义

60
00:03:27,479 --> 00:03:30,840
因为我们把这个变量标记成了“私有”的

61
00:03:30,840 --> 00:03:37,680
和之前一样，我们来声明一个函数

62
00:03:37,680 --> 00:03:42,620
main里面也声明了个有同样签名、没有返回(返回void)的函数

63
00:03:42,620 --> 00:03:44,620
如果我尝试编译

64
00:03:44,620 --> 00:03:47,330
在连接阶段就出现一个link错误——重复定义

65
00:03:47,330 --> 00:03:49,150
因为有两个一样的函数

66
00:03:49,150 --> 00:03:52,689
假如回到static.cpp把这个函数变成static的

67
00:03:52,689 --> 00:03:59,090
那linker就看不到这个static的，也就没有错误

68
00:03:59,090 --> 00:04:04,479
试着变一下，可以看到函数没有错误，但变量还有，删除s_Variable和打印

69
00:04:04,479 --> 00:04:06,240


70
00:04:06,240 --> 00:04:08,479
编译一下，没有任何问题

71
00:04:08,490 --> 00:04:12,639
这就是c++里在类或结构体外的static关键字的全部含义

72
00:04:12,639 --> 00:04:15,659
当你在类或结构体外定义一个静态函数

73
00:04:15,659 --> 00:04:17,069
或者静态变量

74
00:04:17,069 --> 00:04:21,259
这意味着 你定义的函数和变量只对它的声明所在的cpp文件(编译单元)是“可见”的

75
00:04:21,259 --> 00:04:27,480
假如你在头文件中定义了静态变量，然后在两个cpp文件里包含了该头文件

76
00:04:27,480 --> 00:04:31,100
其实跟我这里举的例子差不多

77
00:04:31,100 --> 00:04:36,209
s_Variable在两个编译单元里都声明为静态变量

78
00:04:36,209 --> 00:04:38,810
因为#include头文件

79
00:04:38,810 --> 00:04:43,129
就是把头文件里的所有东西复制粘贴到cpp文件中

80
00:04:43,129 --> 00:04:46,480
所以，其实你就是在两个编译单元都创造了static变量

81
00:04:46,480 --> 00:04:51,149
什么时候用static?想想什么时候对class成员用private吧

82
00:04:51,149 --> 00:04:54,579
基本上static用的越多越好

83
00:04:54,579 --> 00:04:56,959
如果你不想变量是全局可见的

84
00:04:56,959 --> 00:05:01,629
因为你不带static关键字定义全局变量的话

85
00:05:01,629 --> 00:05:04,100
你会发现链接器

86
00:05:04,100 --> 00:05:08,519
会跨编译单元进行链接，因为你创建的是全局变量

87
00:05:08,519 --> 00:05:11,810
假如我有个全局变量variable

88
00:05:11,810 --> 00:05:13,810
突然之间

89
00:05:13,810 --> 00:05:18,029
variable这个名字就全局可用了(注：跟关键字差不多？)

90
00:05:18,029 --> 00:05:20,069
就可能会有奇形怪状的bug

91
00:05:20,069 --> 00:05:22,300
归根到底

92
00:05:22,300 --> 00:05:24,300
全局变量很糟糕

93
00:05:24,300 --> 00:05:27,300
我不太赞同使用全局变量，后面会讲到

94
00:05:27,300 --> 00:05:31,220
重点是：尽量让全局函数和变量用static标记

95
00:05:31,220 --> 00:05:34,730
除非它们必须要用在其他的编译单元里

96
00:05:34,730 --> 00:05:41,819
之前讲到，static在类和结构体中的应用请看P43

97
00:05:41,819 --> 00:05:46,050
如果你喜欢这个视频请点赞 或者在推特和Ins上面关注我

