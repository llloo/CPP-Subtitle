1
00:00:00,070 --> 00:00:04,080
Hey，大家好！我是Cherno，欢迎回到我的C++系列课程

2
00:00:04,080 --> 00:00:07,530
这期视频很短，主要是为了回答下面这一个问题

3
00:00:07,540 --> 00:00:11,050
在C++中结构体和类的有什么区别？

4
00:00:11,070 --> 00:00:13,570
上次我们大概的讨论了一下类

5
00:00:13,619 --> 00:00:18,600
我们对类有了一些基础的介绍，如果你还没看过那期视频，就快去看吧

6
00:00:18,679 --> 00:00:22,410
在视频下方描述里会有相应的链接或者是一些奇怪的注释

7
00:00:22,420 --> 00:00:25,269
我想或许叫它们为卡片？它们应该是屏幕上某处的一个卡片

8
00:00:25,359 --> 00:00:31,449
但是我们在C++中有这两个术语，结构（structure）的缩写struct和class

9
00:00:31,480 --> 00:00:37,630
它们或许看起来有些相似，很多人对它们之间的区别感到困惑

10
00:00:37,750 --> 00:00:42,600
什么时候你应当使用struct，什么时候又应当用class，这个视频将会解决这个问题

11
00:00:42,630 --> 00:00:45,299
所以区别是这个

12
00:00:45,409 --> 00:00:46,950
基本上没有区别

13
00:00:46,969 --> 00:00:51,520
只有一个非常小的区别，上个视频中我讲过

14
00:00:51,549 --> 00:00:57,549
一个类(class)的成员默认情况下是私有(private)的，这意味着如果我这样做...

15
00:00:57,579 --> 00:00:59,549
如果我没有显式地

16
00:00:59,600 --> 00:01:01,200
声明它是公有(public)的

17
00:01:01,359 --> 00:01:07,420
然后我们会得到一个错误，我们会看到vs报错说 在Player类里的Move是无法直接访问的

18
00:01:07,439 --> 00:01:14,299
因为Move方法默认是私有，这意味着只有在这个类内部的其他方法才能访问Move

19
00:01:14,359 --> 00:01:19,780
这就是为什么我们执行这段代码在Player类外部调用Move时，一定要在这里写上public

20
00:01:19,849 --> 00:01:24,549
这就是本质上的区别

21
00:01:24,890 --> 00:01:27,280
默认情况下，类是私有的

22
00:01:27,290 --> 00:01:32,920
所以如果你没有指定任何类型的可见修饰符，类的成员是不可见的

23
00:01:32,920 --> 00:01:37,299
或者你没有指定任何内容，默认就会是私有的

24
00:01:37,329 --> 00:01:42,849
然而struct默认是公有(public)的，这就是struct和class的唯一区别

25
00:01:42,879 --> 00:01:48,200
你可以在这里看到代码中有一个错误，是因为Move是不可访问的

26
00:01:48,209 --> 00:01:54,250
如果我将这里改成为struct Player，也就是说，我只是将class改成了struct

27
00:01:54,250 --> 00:01:58,150
现在一切正常。如果我想要一些成员变成private

28
00:01:58,200 --> 00:02:00,599
我需要明确的写上private

29
00:02:00,640 --> 00:02:05,530
然后我们会得到一个刚刚使用类时相同的错误，这就是它们的区别

30
00:02:05,540 --> 00:02:06,920
这很简单

31
00:02:07,040 --> 00:02:11,569
这就是全部。但是，与其仅仅发布一个两分钟的视频

32
00:02:11,599 --> 00:02:18,569
我想谈谈我们如何定义这两个词之间的差别

33
00:02:18,599 --> 00:02:26,900
因为作用上说它们确实没有太大区别，但是在代码实际使用时确实有所不同

34
00:02:27,000 --> 00:02:30,349
在C++中结构体存在的唯一原因

35
00:02:30,509 --> 00:02:37,000
是因为它想要维持与C之间的兼容性，因为C中没有类

36
00:02:37,069 --> 00:02:42,039
然而它有结构体，如果我们突然彻底删除struct这个关键字

37
00:02:42,039 --> 00:02:44,949
那样我们就会降低它们的兼容性

38
00:02:45,050 --> 00:02:51,849
因为C++的编译器不知道什么是struct，当然你可以通过使用“#”来很容易的修复它

39
00:02:52,080 --> 00:02:56,430
我们可以写上一些类似#define struct class的语句，对吧？

40
00:02:56,530 --> 00:03:01,449
然后它瞬间把所有的struct替换成了class

41
00:03:01,449 --> 00:03:04,469
所以在这种情况下，即使代码看起来相当

42
00:03:04,569 --> 00:03:09,199
相当简洁，如果我编译它，你会发现我们我们得到了同样编译错误

43
00:03:09,300 --> 00:03:17,110
说不能直接访问类内部的Move，即使我们在这里用struct替换了class

44
00:03:17,110 --> 00:03:20,569
尽管这么做 可以在C代码与C++代码之间获得某种兼容性

45
00:03:20,699 --> 00:03:24,199
因为理想情况下你应该已经能够使用C代码

46
00:03:24,240 --> 00:03:26,629
然后用类来替换结构并使其变为公有

47
00:03:26,650 --> 00:03:31,849
然后就是这样，这就是最终结果，在实际情况中不会有更多的区别

48
00:03:31,990 --> 00:03:34,099
所以语义上的差别和人们如何看待它，这或多或少取决于用法

49
00:03:34,139 --> 00:03:39,259
如果它们没有区别，那什么时候用struct或者class

50
00:03:39,259 --> 00:03:46,050
如果我想要我的成员全部公开，而我不想要写public这个单词

51
00:03:46,050 --> 00:03:47,500
我应该使用struct吗？

52
00:03:47,500 --> 00:03:50,099
真的就是这样吗？ 确实，就是这样

53
00:03:50,310 --> 00:03:52,750
说实话，就是这样

54
00:03:52,750 --> 00:03:55,469
正因为这样，人们对struct和class都有自己的理解

55
00:03:55,530 --> 00:04:00,050
我认为struce应该这么用，我认为class应该那样。

56
00:04:00,139 --> 00:04:00,819
然而

57
00:04:01,050 --> 00:04:05,069
没有什么正确或者错误的答案

58
00:04:05,259 --> 00:04:08,900
这是个人编程的风格，所以既然在我的视频里

59
00:04:09,060 --> 00:04:14,030
让我们来谈论一下我编程的风格，我会在哪里使用哪种类型

60
00:04:14,229 --> 00:04:26,069
当我谈论一些plain old data（pod）或者只是包含一些变量的结构时，我喜欢用struct。

61
00:04:26,259 --> 00:04:32,199
一个很好的例子可能是数学中的向量类

62
00:04:32,310 --> 00:04:33,379
如果我在这里

63
00:04:33,379 --> 00:04:40,129
我想要定义一个结构，将两个浮点数放在一起，比如说Vec2

64
00:04:40,240 --> 00:04:45,350
我把它定义为一个struct，里面只有两个浮点数x和y

65
00:04:45,350 --> 00:04:55,730
从根本上说这个Vec2不管是用struct还是class又或者其他类型，都只是代表两个浮点数的一种数据结构

66
00:04:55,930 --> 00:04:56,769
这就是它的核心内容

67
00:04:56,959 --> 00:05:02,269
它不应该像player类那样包含大量的功能

68
00:05:02,310 --> 00:05:05,930
一个player类，可能有一个3D模型

69
00:05:05,930 --> 00:05:07,480
它可能会为这个3D模型里处理渲染代码

70
00:05:07,670 --> 00:05:13,399
它可能处理一些，像玩家在地图上如何移动、接受键盘的输入等

71
00:05:13,529 --> 00:05:21,069
这有太多的功能。然而我们这是什么，它仅仅是将两个变量组合起来

72
00:05:21,149 --> 00:05:23,879
只是为了

73
00:05:24,009 --> 00:05:28,379
使我们的代码更易于使用。这就是我们做的全部

74
00:05:28,379 --> 00:05:31,819
当然这不是说我不打算在里面添加方法

75
00:05:31,819 --> 00:05:33,199
我绝对会的

76
00:05:33,279 --> 00:05:41,350
我可能会添加一个叫做add的方法，该方法接受另外一个Vec2，然后像这样将它和目前的向量相加

77
00:05:41,560 --> 00:05:44,180
但是我在这里做的就是

78
00:05:44,180 --> 00:05:51,569
操纵这些变量，我只是添加了一个可以操作这些变量的函数

79
00:05:51,589 --> 00:05:56,230
到最后我还是在讨论这两个变量，当然，如果你非要较真的话

80
00:05:56,399 --> 00:05:59,000
你可能会反驳说

81
00:05:59,339 --> 00:06:03,850
player类不也也只是在操纵这些变量吗？

82
00:06:03,990 --> 00:06:06,930
然而，它们确实在设计上有点不同

83
00:06:07,040 --> 00:06:11,730
因为我们讨论的东西要复杂的多。

84
00:06:11,730 --> 00:06:13,420
另外的功能是继承

85
00:06:13,500 --> 00:06:17,000
我绝对不会对struct使用继承

86
00:06:17,110 --> 00:06:22,980
如果我真的要用一个完整的类层次或某种继承层次的结构

87
00:06:23,129 --> 00:06:25,269
我将会使用class

88
00:06:25,529 --> 00:06:31,850
因为继承又增加了另一层复杂性，而我希望我的结构体仅仅是数据的结构体

89
00:06:32,170 --> 00:06:34,980
就是这样。另外，如果你想要尝试并混合它们

90
00:06:35,019 --> 00:06:38,379
举个例子，你有一个类叫做A，有一个结构体叫做B

91
00:06:38,430 --> 00:06:43,430
它从A处继承，一些编译器会向你发出警告，警告你正在从一个类继承

92
00:06:43,589 --> 00:06:49,550
但是你是一个结构体，还有一些细微的差别，但是，它们只是警告你，你的代码仍然可以运行

93
00:06:49,610 --> 00:06:55,879
这只是语义上的差别，这些就是我使用struct而不是class的原因。

94
00:06:56,100 --> 00:06:59,519
如果我只是想用结构体来表示一些数据

95
00:06:59,839 --> 00:07:00,649
我会使用struct

96
00:07:00,889 --> 00:07:03,500
如果我想要一个有很多功能的类

97
00:07:03,759 --> 00:07:10,850
像在游戏世界里，一个玩家，或者是其他可能继承的东西

98
00:07:10,889 --> 00:07:15,850
我会使用class。这就是我个人如何区分这两个类型的

99
00:07:15,930 --> 00:07:20,269
我在行业内见到很多人就是这么区分这两种类型的

100
00:07:20,350 --> 00:07:27,730
但是如果如技术上来讲，如果两者除了可见性之外没有什么区别，你可以在任何你使用class的地方使用struct

101
00:07:27,870 --> 00:07:29,569
它们将以相同方式工作

102
00:07:29,800 --> 00:07:35,730
希望你们喜欢这个视频，如果你喜欢的话，点赞或者你可以在Twitter和Instagram关注我

103
00:07:35,829 --> 00:07:41,319
如果您真的喜欢这些视频，并且希望支持本系列并查看更多内容，下面的说明中提供的有相关链接

104
00:07:41,670 --> 00:07:44,649
然后可以在patreon.com/thecherno关注我

105
00:07:44,779 --> 00:07:47,629
此外，你还可以支持我并激励我可以制作更多的视频

106
00:07:47,939 --> 00:07:53,519
您还可以访问早期草稿和讨论板，我们在其中讨论这些视频的内容

107
00:07:53,639 --> 00:07:56,569
如果你对此感兴趣，请查看简介中的链接

108
00:07:58,180 --> 00:08:00,949
下次我们继续我们的旅程

109
00:08:00,949 --> 00:08:06,230
至于哪种类会涉及继承的内容和查看一些现有代码的示例

110
00:08:06,459 --> 00:08:09,399
以了解应该如何构造你的类

111
00:08:09,720 --> 00:08:13,500
怎么编写它们和怎么在代码中使用它们，下次见，再见！

