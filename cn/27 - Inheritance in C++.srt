1
00:00:00,000 --> 00:00:04,080
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:04,080 --> 00:00:09,880
今天我们继续讲解面向对象编程并讨论C++中的继承

3
00:00:09,919 --> 00:00:17,350
面向对象是一个非常非常大的编程范式，类的继承是其中最基本的一个概念

4
00:00:17,350 --> 00:00:19,890
是我们可以利用的最强大的特性之一

5
00:00:19,890 --> 00:00:24,350
继承使类之间有了相互关联的层级关系

6
00:00:24,350 --> 00:00:28,899
换句话说，它使我们拥有一个包含通用功能的积累

7
00:00:28,899 --> 00:00:35,159
然后从这个最开始的父类中可以创建出很多的派生类

8
00:00:35,170 --> 00:00:41,119
这就是继承为什么非常有用，因为它可以帮助我们避免写很多重复的代码

9
00:00:41,119 --> 00:00:45,329
代码重复(code duplication)是指我们必须多次地写相同的代码

10
00:00:45,329 --> 00:00:50,460
或者代码略微不同但实际上是在做同样的事

11
00:00:50,549 --> 00:00:58,049
为了避免一次次地重复，我们可以把所有通用的功能放在一个父类中

12
00:00:58,070 --> 00:01:01,219
然后很容易地从基类中创建派生类

13
00:01:01,219 --> 00:01:06,019
稍微改变一些功能或者引入全新的功能

14
00:01:06,019 --> 00:01:12,819
继承给我们提供了这样的一种方式：把一系列类的所有通用的代码(功能)放到基类中

15
00:01:12,819 --> 00:01:15,569
这样我们就不用像写模板那样不断重复了

16
00:01:15,569 --> 00:01:18,620
好了，让我们在代码里看看要怎样做。

17
00:01:18,620 --> 00:01:24,909
假如我有一个Entity类，然后它将控制游戏里的所有Entity实例

18
00:01:24,909 --> 00:01:30,959
在游戏里有很多非常非常具体的Entity, 但是在某些方面它们会共享功能。

19
00:01:30,959 --> 00:01:37,549
比如说，可能游戏里每个Entity都有用2个浮点数来表示位置属性

20
00:01:37,549 --> 00:01:39,120
所以我们有浮点数X和Y。

21
00:01:39,120 --> 00:01:43,560
然后，我们可能想给每个Entity移动的能力，也许叫Move方法

22
00:01:43,560 --> 00:01:47,769
参数为xa和ya,用来表示我们想要移动的量

23
00:01:47,769 --> 00:01:54,030
好了，我们有了一个Entity基类，我们可以说游戏里创建的每个Entity实例都具有这些特性

24
00:01:54,030 --> 00:01:57,150
让我们创建一个新类型的Entity, 比如说Player

25
00:01:57,150 --> 00:02:00,159
编写我们的Player类，目前为止还没用到继承的概念

26
00:02:00,159 --> 00:02:05,200
通常如果我们从头开始的话，我们会想要Player也有一个位置属性

27
00:02:05,200 --> 00:02:08,750
因为Player也是一个实体(Entity), 让它也有一个位置也是说的通的。

28
00:02:08,750 --> 00:02:13,210
我们也想让Player可以移动，因此我们需要一个Move函数

29
00:02:13,210 --> 00:02:16,759
我们最终写的这些和Entity看起来很像

30
00:02:16,759 --> 00:02:21,300
Player类可能会包含一些其他的数据，比如说名字等

31
00:02:21,300 --> 00:02:24,759
把名字加上，你可以说它们(Entity, Player)其实是不同的类

32
00:02:24,759 --> 00:02:28,939
但是有很多的代码其实就是复制和粘贴的，就像这些

33
00:02:28,939 --> 00:02:31,900
在这里我们就可以用继承了

34
00:02:31,900 --> 00:02:39,069
我们可以扩展Entity类来创建一个新的叫Player的类，而且它还可以存储新的数据比如说name

35
00:02:39,199 --> 00:02:44,280
另外还要提供额外的功能，比如说基类里不存在的函数

36
00:02:44,280 --> 00:02:48,659
现在我们把Player编程Entity的派生类，要这么做

37
00:02:48,659 --> 00:02:54,340
在类型声明 class Player后面写上冒号，然后写上 public Entity

38
00:02:54,599 --> 00:02:58,379
好了，我们写下这行代码之后，发生了一些事情

39
00:02:58,379 --> 00:03:05,349
这个Player类不再仅仅只是Player类型，它也是Entity类型，就是说它同时是这两种类型

40
00:03:05,349 --> 00:03:12,599
C++里的类型是个很复杂的话题，因为一方面它们并不真实存在，另一方面它们又确实很重要

41
00:03:12,599 --> 00:03:15,530
特别是你如果激活了某些运行时标志。
(?)

42
00:03:15,530 --> 00:03:21,449
我们先不会去深入了解整个过程是如何工作的，以后会的。

43
00:03:21,449 --> 00:03:26,080
另外一件发生的事情就是Player现在拥有了Entity的一切

44
00:03:26,080 --> 00:03:32,580
所有的类成员比如说X和Y，这两个浮点数，同样也包含在Player里

45
00:03:32,580 --> 00:03:35,590
所以目前为止Player中实际上有4个浮点数了

46
00:03:35,590 --> 00:03:40,419
这里的两个数是我们从Entity里复制粘贴过来的

47
00:03:40,419 --> 00:03:45,659
把这些重复代码删除，然后我们就只有新的东西了

48
00:03:45,659 --> 00:03:51,520
比如name, 它是 const char*类型的，还有PrintName函数，这是我们的附加功能示例

49
00:03:51,520 --> 00:03:54,569
Cool, 现在这个Player类看起来很干净了

50
00:03:54,569 --> 00:03:59,819
但是这其实还是Entity, 这意味着只看这个类我们并不能了解全貌

51
00:03:59,819 --> 00:04:02,990
我们必须要往上到Entity类里去看看它有什么

52
00:04:02,990 --> 00:04:09,659
因为对于Player来说，在Entity中任何不是私有的(private)成员，Player都可以访问到

53
00:04:09,659 --> 00:04:10,949
让我们来试下。

54
00:04:10,949 --> 00:04:18,540
假设我在这里创建一个Player实例，我不但可以调用在Player中定义的PrintName函数

55
00:04:18,540 --> 00:04:24,839
我也能调用Move函数，还有可以像这样访问X和Y，就像我在使用一个Entity的实例一样

56
00:04:24,839 --> 00:04:27,800
我可以传入我要移动的参数

57
00:04:27,800 --> 00:04:34,350
我可以访问X和Y,就像它是一个Entity实例一样，因为它继承了Entity所有的功能

58
00:04:34,350 --> 00:04:40,189
另一个我们可以应用的概念叫”多态“，我们会在以后的视频中讲到

59
00:04:40,189 --> 00:04:45,699
基本上来说，多态就是使用一个单一的符号来表示多个不同的类型

60
00:04:45,699 --> 00:04:50,449
你应该记得我之前提到过Player不仅仅只是Player类型，它还是一个Entity(类型)

61
00:04:50,449 --> 00:04:55,120
我的意思是我们可以在任何想要用Entity的地方使用Player

62
00:04:55,120 --> 00:05:00,629
这是因为Player拥有Entity的所有内容，甚至更多

63
00:05:00,629 --> 00:05:04,220
它也不必一定要有更多的内容，就像我们增加的那些。

64
00:05:04,220 --> 00:05:11,220
它们可以是完全一样的，但是Player总是Entity的一个超集

65
00:05:11,220 --> 00:05:16,560
就是说Player重视拥有Entity的一切，并且除此之外可以有更多的内容

66
00:05:16,560 --> 00:05:21,149
如果我想创建一个打印Entity对象的独立功能

67
00:05:21,149 --> 00:05:25,149
访问X和Y变量然后把它们打印到控制台上

68
00:05:25,149 --> 00:05:31,160
我可以给这个函数传入一个Player对象尽管它是接受一个Entity作为参数的

69
00:05:31,160 --> 00:05:37,790
可以这么做的原因是，一个Player类型或者Player类保证会有X和Y变量，因为它肯定有

70
00:05:37,889 --> 00:05:41,629
它是Entity的派生类，就是说它拥有Entity的所有内容。

71
00:05:41,629 --> 00:05:46,300
因为这些多态特征，我们可以做很多很多的事情

72
00:05:46,300 --> 00:05:53,139
我们可以改变超类或者基类的行为，比如说，通过重写一个方法并给它新的代码来替代(父类方法)

73
00:05:53,250 --> 00:05:58,600
但是今天要讲的是 继承是我们一直在使用的东西

74
00:05:58,600 --> 00:06:04,680
是用来扩展现有的类和为基类提供新功能的一种方式

75
00:06:04,680 --> 00:06:07,050
它是是面向对象编程的一个最重要的东西

76
00:06:07,050 --> 00:06:11,279
记住，当你创建了一个子类，它会包含父类的一切。

77
00:06:11,399 --> 00:06:16,540
另外一个证明这些的好方法就是，记得我们在Entity中有两个浮点数 X和Y

78
00:06:16,540 --> 00:06:22,920
让我们接着把Entity对象的size打印到控制台，可以使用 sizeof(Entity)

79
00:06:22,920 --> 00:06:26,129
按F5运行代码，你会看到size是8

80
00:06:26,129 --> 00:06:30,329
你应该能猜到结果，因为在Entity里我们有两个Float变量X和Y

81
00:06:30,329 --> 00:06:32,790
然后让我们接着打印 sizeof(Player)

82
00:06:32,790 --> 00:06:37,560
如果Player不是从Entity扩展来的，如果Player只有它自己的内容

83
00:06:37,560 --> 00:06:43,920
那它应该只有这个 const char*, 在32位应用中这应该占4个字节内存

84
00:06:43,920 --> 00:06:49,699
但是既然我们是从Entity扩展来的, 意味着它继承了Entity类的所有变量
However, since we are ??ascending?? Entity, means that
 it inherits all of the variables that inside that Entity class.

85
00:06:49,699 --> 00:06:52,949
所以它应该是 4+4+4，占了12个字节

86
00:06:52,949 --> 00:06:56,699
让我们按F5运行看看是不是这样，你看确实是12

87
00:06:56,699 --> 00:06:59,370
我们确实是继承了Entity的一切

88
00:06:59,370 --> 00:07:03,040
这好像就是我们从Entity里复制了所有东西然后粘贴到Player类里。

89
00:07:03,040 --> 00:07:08,129
Player类就是增加了额外功能的Entity

90
00:07:08,250 --> 00:07:11,610
记住这些类的大小和内存实际上是可以变化的

91
00:07:11,610 --> 00:07:16,100
如果我们重写Player里的函数，那么我们就要去维护一个 vtable(虚函数表)

92
00:07:16,100 --> 00:07:18,800
这也需要占用额外的内存

93
00:07:18,930 --> 00:07:22,939
现在先不讲这个。 这些就是C++中继承如何工作的要点

94
00:07:22,939 --> 00:07:26,689
在整个系列的课程中，我们将拆分关于面向对象编程的独立概念

95
00:07:26,689 --> 00:07:31,449
多态，继承，所有这些东西都是单独和深入的。

96
00:07:31,449 --> 00:07:34,240
我们现在还只是接触了表面

97
00:07:34,240 --> 00:07:36,120
下次见，Goodbye！

98
00:07:38,129 --> 00:07:42,540
Oh, man! 今天的头发...is just...just Perfect.

