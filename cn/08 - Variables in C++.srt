1
00:00:00,075 --> 00:00:01,600
Hey 大家好 我是cherno

2
00:00:01,800 --> 00:00:03,629
欢迎收看另一个视频

3
00:00:03,629 --> 00:00:04,169
所以

4
00:00:04,169 --> 00:00:06,839
经过漫长的一天的工作，我现在坐在沙发上

5
00:00:06,839 --> 00:00:08,699
我以为我弄混了 

6
00:00:08,699 --> 00:00:10,890
让我们来谈谈C++中的变量吧

7
00:00:10,890 --> 00:00:14,429
所以当我们用C++写一个程序时

8
00:00:14,429 --> 00:00:16,769
我们希望能够使用数据

9
00:00:16,769 --> 00:00:20,519
大多数编程的内容都是使用数据

10
00:00:20,519 --> 00:00:22,739
我们操纵数据

11
00:00:22,739 --> 00:00:25,679
这就是我们所做的，所以，任何我们在程序中使用的数据

12
00:00:25,679 --> 00:00:27,059
我们想要改变

13
00:00:27,059 --> 00:00:28,140
我们想要修改

14
00:00:28,140 --> 00:00:30,089
我们想要读和写

15
00:00:30,089 --> 00:00:33,000
我们需要将这些数据存储在一个叫做变量（variable）的东西中

16
00:00:33,000 --> 00:00:40,350
所以变量基本上允许我们给一个存储在内存中的数据一个名字，这样我们就可以继续使用它，打个比方

17
00:00:40,350 --> 00:00:48,960
假装你在做一个游戏，你的游戏中有一个玩家，然后他的角色在地图上有一个位置信息，角色可以移动

18
00:00:48,960 --> 00:00:53,009
所以我们需要把玩家的位置储存在我们的内存里，作为一个变量

19
00:00:53,009 --> 00:00:58,829
因此当需要在屏幕上显示玩家或者跟场景互动的时候，我们得能看到

20
00:00:58,829 --> 00:00:59,159
嘿

21
00:00:59,159 --> 00:01:02,460
玩家到底在哪里！所以我们想要把玩家的位置存在一个变量里

22
00:01:02,460 --> 00:01:03,240
在一个变量中

23
00:01:03,240 --> 00:01:07,799
这基本上是用任何语言编程的根本之一

24
00:01:07,799 --> 00:01:11,400
我们需要能够玩弄数据并存储这些数据

25
00:01:11,400 --> 00:01:16,290
当我们创建一个变量时，它会被存储在内存中的两个地方之一

26
00:01:16,290 --> 00:01:17,430
栈或堆

27
00:01:17,430 --> 00:01:17,909
别担心

28
00:01:17,909 --> 00:01:22,079
我们将会有很多视频讨论内存是如何工作的

29
00:01:22,079 --> 00:01:25,409
所以如果你想找一个更深入的解释

30
00:01:25,409 --> 00:01:26,519
绝对会有的

31
00:01:26,519 --> 00:01:27,030
但现在

32
00:01:27,030 --> 00:01:29,280
只要知道变量确实占据了内存

33
00:01:29,280 --> 00:01:32,250
也就是我们在电脑中存储数据的地方

34
00:01:32,250 --> 00:01:36,629
在C++中，我们有一些原始数据类型

35
00:01:36,629 --> 00:01:43,230
这些原始数据类型基本上构成了我们在程序中存储的任何类型的数据的基础

36
00:01:43,230 --> 00:01:46,819
C++给我们提供的每个数据类型都有特定的目的

37
00:01:46,819 --> 00:01:46,920
 

38
00:01:46,920 --> 00:01:49,019
虽然它有一个特定的目的

39
00:01:50,280 --> 00:01:52,890
但其实你并不非要将它用于那个目的

40
00:01:52,890 --> 00:01:55,739
这很有趣，因为C++是一种非常强大的语言

41
00:01:55,739 --> 00:02:00,959
这意味着当你真正理解它的时候，它实际上限制很少

42
00:02:00,959 --> 00:02:02,969
所以当我在解释变量时

43
00:02:02,969 --> 00:02:04,319
我真正想说的是

44
00:02:04,319 --> 00:02:09,840
在C++中，不同的变量类型之间的唯一区别就是大小

45
00:02:09,840 --> 00:02:14,069
这个变量占用多少内存，

46
00:02:14,069 --> 00:02:17,250
这真的是这些原始数据类型之间的唯一区别

47
00:02:17,250 --> 00:02:18,150
它们有多大

48
00:02:18,150 --> 00:02:21,120
让我们进入vs看看一些例子

49
00:02:21,120 --> 00:02:24,360
实际上我们已经有了一个在使用的变量类型

50
00:02:24,360 --> 00:02:29,969
它代表整数，它允许我们在给定的范围内储存了一个整形数字

51
00:02:29,969 --> 00:02:31,889
如果我们想要声明一个新的变量

52
00:02:31,889 --> 00:02:34,830
我们可以通过输入变量的类型来实现

53
00:02:34,830 --> 00:02:36,509
给它起个什么名字

54
00:02:36,509 --> 00:02:37,050
例如

55
00:02:37,050 --> 00:02:39,569
叫variable，然后给它一个值

56
00:02:39,569 --> 00:02:41,280
最后一步是可选的

57
00:02:41,280 --> 00:02:43,650
你不需要马上给它一个值

58
00:02:43,650 --> 00:02:45,300
但现在让我们给它一个值

59
00:02:45,300 --> 00:02:45,719
8

60
00:02:45,719 --> 00:02:49,469
传统上，整形是4字节（byte）大小的数据类型

61
00:02:49,469 --> 00:02:52,139
数据类型的实际大小取决于编译器

62
00:02:52,139 --> 00:02:55,289
所以它可能会不同，取决于你使用的是什么编译器

63
00:02:55,289 --> 00:02:55,830
最终

64
00:02:55,830 --> 00:02:59,159
告诉你一个数据会有多大，是编译器的选择

65
00:02:59,159 --> 00:03:05,580
int类型是为了在一定范围内存储整数，因为它大小是4个字节

66
00:03:05,580 --> 00:03:09,479
我们被限制在它能存储什么样的数字上

67
00:03:09,479 --> 00:03:10,050
具体来说

68
00:03:10,050 --> 00:03:16,620
这是一个带符号整数(signed int)，它可以存储的数字范围是负二十亿到正二十亿

69
00:03:16,620 --> 00:03:22,979
存储比这更大或更小的东西需要更多的数据来存储，而这个类型是没法支持的

70
00:03:22,979 --> 00:03:24,330
用四个字节的数据

71
00:03:24,330 --> 00:03:27,150
我们可以在这个范围内存储一个值

72
00:03:27,150 --> 00:03:31,349
让我们试着把我们的变量打印到控制台，看看它到底是什么

73
00:03:31,349 --> 00:03:32,789
我将用这个实际的变量

74
00:03:32,789 --> 00:03:34,650
替换这个Helloworld

75
00:03:34,650 --> 00:03:37,020
这就是我们如何将一个变量log到控制台的方法

76
00:03:37,020 --> 00:03:41,789
让我们按F5来运行程序，你可以看到它打印出了数字8，太好了

77
00:03:41,789 --> 00:03:43,620
我们可以继续修改变量

78
00:03:43,620 --> 00:03:47,849
例如，把它重新赋值到比如说20

79
00:03:47,849 --> 00:03:49,889
让我们继续打印，看看会发生什么

80
00:03:49,889 --> 00:03:52,500
所以在这里打印一次，然后这里打印一次

81
00:03:52,500 --> 00:03:53,550
所以它应该先打印出8，再打印出20

82
00:03:53,550 --> 00:03:57,030
你可以看到，如果我们运行我们的程序

83
00:03:57,030 --> 00:03:58,620
这正是我们得到的，酷

84
00:03:58,620 --> 00:03:58,860
所以

85
00:03:58,860 --> 00:03:59,699
就像我说的

86
00:03:59,699 --> 00:04:00,900
一个INT型数据类型

87
00:04:00,900 --> 00:04:04,409
你可以存储一个负二十亿和正二十亿之间的值

88
00:04:04,409 --> 00:04:05,310
所以你可能会问

89
00:04:05,310 --> 00:04:06,060
为什么

90
00:04:06,060 --> 00:04:07,139
它是负的

91
00:04:07,139 --> 00:04:08,819
二十亿到正二十亿之间？

92
00:04:08,819 --> 00:04:09,900
顺便说一下，也不是正好二十亿

93
00:04:09,900 --> 00:04:11,939
大概是20几亿

94
00:04:11,939 --> 00:04:13,830
这些限制从何而来

95
00:04:13,830 --> 00:04:15,300
他们能说得通吗？

96
00:04:15,300 --> 00:04:16,470
答案是肯定的

97
00:04:16,470 --> 00:04:17,160
他们说得通

98
00:04:17,160 --> 00:04:20,310
它们与变量的大小直接相关

99
00:04:20,310 --> 00:04:22,379
这就是在它们里允许存储的数据量

100
00:04:22,379 --> 00:04:23,129
in it.

101
00:04:23,129 --> 00:04:24,779
一个整数是4个字节

102
00:04:24,779 --> 00:04:26,009
在四个字节的数据

103
00:04:26,009 --> 00:04:27,959
我们可以存一个在那个范围内的值

104
00:04:27,959 --> 00:04:29,220
让我们把这个剖析一下

105
00:04:29,220 --> 00:04:31,889
一个字节是8比特（bit）的数据

106
00:04:31,889 --> 00:04:34,699
也就是说，4个字节就是32 bits的数据

107
00:04:34,889 --> 00:04:36,839
因为这个变量是带符号的

108
00:04:36,839 --> 00:04:38,459
也就是说它可以是负的

109
00:04:38,459 --> 00:04:41,189
它包含了一个符号，也就是一个负号

110
00:04:41,189 --> 00:04:42,899
因为这个变量是带符号的（signed）

111
00:04:42,899 --> 00:04:44,100
32bits中的一个bit

112
00:04:44,100 --> 00:04:47,519
必须是符号

113
00:04:47,519 --> 00:04:49,620
那样我们才知道它是正的还是负的

114
00:04:49,620 --> 00:04:52,529
只剩下31个位留给实际的数字

115
00:04:52,529 --> 00:04:54,449
现在，每个bit可以是0或1

116
00:04:54,449 --> 00:04:57,149
所以1 bit数据有两种可能的值

117
00:04:57,149 --> 00:04:59,009
所以做一点算术的话

118
00:04:59,009 --> 00:05:02,430
我们可以说，我们有31个bits，每个bit有两个可能的值

119
00:05:02,430 --> 00:05:04,800
那么2的31次方是多少呢？

120
00:05:04,800 --> 00:05:09,240
如果我们在这里打开一个计算器，输入2的31次方

121
00:05:09,240 --> 00:05:13,620
我们会得到大概20亿这个值，这个值，这个21亿的值

122
00:05:13,620 --> 00:05:17,250
是我们可以在int里存储的最大数字 （画面中的文字：其实最大值应该比算出来的少1，因为我们还需要地方存0）

123
00:05:17,250 --> 00:05:17,670
记住

124
00:05:17,670 --> 00:05:21,600
我们还有预留一个bit用于决定该数是否为负

125
00:05:21,600 --> 00:05:24,120
正因为如此，我们从0开始算可以存储到最大21亿

126
00:05:24,120 --> 00:05:29,339
但是我们也可以从另一边开始算，也就是从0往下可以存到-21亿

127
00:05:29,339 --> 00:05:31,019
”但我不想要负值呀“

128
00:05:31,019 --> 00:05:32,250
我听到你这么说

129
00:05:32,250 --> 00:05:37,379
有没有一种方法可以把那个用来存负号的bit去掉，也用来存我们的数呢?

130
00:05:37,379 --> 00:05:37,709
额

131
00:05:37,709 --> 00:05:38,459
是的

132
00:05:38,459 --> 00:05:39,000
是的

133
00:05:39,000 --> 00:05:39,899
有的！

134
00:05:39,899 --> 00:05:42,149
这就是我们所说的无符号数（unsigned）

135
00:05:42,149 --> 00:05:44,639
这意味着它是一个没有符号的数字

136
00:05:44,639 --> 00:05:46,529
意思是它总是正的

137
00:05:46,529 --> 00:05:47,470
在C++中

138
00:05:47,470 --> 00:05:47,480
Plus.

139
00:05:47,480 --> 00:05:47,490
Plus,

140
00:05:47,490 --> 00:05:51,540
我们可以通过在int前面输入unsigned来获得

141
00:05:51,540 --> 00:05:56,160
现在我们所做的是，我们有32个bits，那2的32次方

142
00:05:56,160 --> 00:05:56,670
当然

143
00:05:56,670 --> 00:06:01,019
也就是这里的两倍，42.9亿

144
00:06:01,019 --> 00:06:04,819
这基本就是unsigned这个关键字在C++中所做的

145
00:06:04,819 --> 00:06:04,829
 

146
00:06:04,829 --> 00:06:08,670
它允许我们定义一个没有符号位的整数

147
00:06:08,670 --> 00:06:08,970
好的

148
00:06:08,970 --> 00:06:11,160
那么我们还有哪些其他数据类型呢

149
00:06:11,160 --> 00:06:12,540
如果我不想要一个4字节的整数呢

150
00:06:12,540 --> 00:06:14,100
还有其他类型的吗

151
00:06:14,100 --> 00:06:14,279
所以

152
00:06:14,279 --> 00:06:15,720
就整数值而言

153
00:06:15,720 --> 00:06:17,220
我们实际上有很多

154
00:06:17,220 --> 00:06:18,209
我们有char

155
00:06:18,209 --> 00:06:19,680
这是一个byte的数据

156
00:06:19,680 --> 00:06:20,579
我们有short

157
00:06:20,579 --> 00:06:25,740
这是两个字节的数据，我们有int，4个字节，我们有long

158
00:06:25,740 --> 00:06:28,170
也通常是4字节的数据

159
00:06:28,170 --> 00:06:29,759
具体根据编译器可能有不同

160
00:06:29,759 --> 00:06:31,110
然后我们有long long

161
00:06:31,110 --> 00:06:33,540
通常是8字节的数据

162
00:06:33,540 --> 00:06:35,009
还有其他类型 比如long int

163
00:06:35,009 --> 00:06:36,750
这里有一些不同的变形

164
00:06:36,750 --> 00:06:38,430
我不打算把所有都讲到

165
00:06:38,430 --> 00:06:41,279
但最基本的是这五个

166
00:06:41,279 --> 00:06:43,769
你也可以在它们前面添加unsigned

167
00:06:43,769 --> 00:06:46,889
它会移除那个符号位，让你设置一个更大的数字

168
00:06:46,889 --> 00:06:47,220
Char

169
00:06:47,220 --> 00:06:49,860
传统上是用来存储字符（character）的

170
00:06:49,860 --> 00:06:50,819
而不仅仅是数字

171
00:06:50,819 --> 00:06:53,220
不仅可以给它赋值数字比如说50

172
00:06:53,220 --> 00:06:55,800
你也可以给它赋值一个字符，比如'A'

173
00:06:55,800 --> 00:06:59,100
这并不是说你不能给其他整数赋值一个字符，你可以的

174
00:06:59,100 --> 00:07:00,180
因为到头来

175
00:07:00,180 --> 00:07:01,740
我输入的这个字符，这个A

176
00:07:01,740 --> 00:07:02,339
a

177
00:07:02,339 --> 00:07:03,810
它只是一个数字

178
00:07:03,810 --> 00:07:04,259
事实上

179
00:07:04,259 --> 00:07:07,769
这个数字————这个与该字符绑定的数字

180
00:07:07,769 --> 00:07:10,079
也就是字符A的数字是65

181
00:07:10,079 --> 00:07:10,290
现在

182
00:07:10,290 --> 00:07:13,139
如果数字只是字符，而字符只是数字

183
00:07:13,139 --> 00:07:16,170
那么为什么我们会有这种区别呢

184
00:07:16,170 --> 00:07:19,620
为什么我说char是专门用于字符的，

185
00:07:19,620 --> 00:07:20,790
而实际上它并不是呢？

186
00:07:20,790 --> 00:07:22,410
这是因为我们经常

187
00:07:22,410 --> 00:07:25,500
作为程序员，对某些数据类型做出假设

188
00:07:25,500 --> 00:07:28,860
如果我传入一个char，并将其命名为character

189
00:07:28,860 --> 00:07:31,290
我通常是希望你能真的给它赋值一个字符

190
00:07:31,290 --> 00:07:35,189
一个很好的例子是，如果你试着打印一个字符

191
00:07:35,189 --> 00:07:36,990
如果我打印这个变量

192
00:07:36,990 --> 00:07:37,230
a

193
00:07:37,230 --> 00:07:38,069
比如说

194
00:07:38,069 --> 00:07:39,240
我按F5

195
00:07:39,240 --> 00:07:41,399
我不会得到与之相联系的数字

196
00:07:41,399 --> 00:07:43,589
这个字符A会打印出来

197
00:07:43,589 --> 00:07:45,959
如果我用它的实际数值来替换它

198
00:07:45,959 --> 00:07:47,040
像65

199
00:07:47,040 --> 00:07:49,319
我还会得到一个打印出来的A

200
00:07:49,319 --> 00:07:54,569
如你所见，因为cout，如果我把一个字符传递到cout里

201
00:07:54,569 --> 00:07:56,519
它会把它当作一个字符

202
00:07:56,519 --> 00:07:57,629
而不是数字

203
00:07:57,629 --> 00:07:59,879
如果我把它改成另一种类型 比如说像short

204
00:08:00,930 --> 00:08:02,009
并按F5

205
00:08:02,009 --> 00:08:04,860
你可以看到cout不再把它当一个字符

206
00:08:04,860 --> 00:08:07,290
而打印出了实际的数字

207
00:08:07,290 --> 00:08:09,089
甚至我在这里给它赋值一个字符

208
00:08:09,089 --> 00:08:11,699
其实就是把65赋值给它

209
00:08:11,699 --> 00:08:13,019
如果我再运行一次

210
00:08:13,019 --> 00:08:14,970
你可以看到，我们得到了65

211
00:08:14,970 --> 00:08:18,870
我告诉你们这些的原因是，我想让你们理解数据类型

212
00:08:18,870 --> 00:08:23,009
数据类型的使用完全取决于程序员

213
00:08:23,850 --> 00:08:26,279
我们已经有了一些约定

214
00:08:26,279 --> 00:08:29,670
但是没有任何东西是固定的、你必须遵循的

215
00:08:29,670 --> 00:08:32,460
毕竟C++里的规则非常少

216
00:08:32,460 --> 00:08:33,360
正因为如此

217
00:08:33,360 --> 00:08:42,509
我希望您意识到，这些数据类型之间唯一的真正区别是，当您用该数据类型创建一个变量时，将分配多少内存

218
00:08:42,509 --> 00:08:44,190
所以不考虑整数类型的话

219
00:08:44,190 --> 00:08:46,590
如果我想要存储一个小数呢？

220
00:08:46,590 --> 00:08:47,070
例如

221
00:08:47,070 --> 00:08:48,149
5.5

222
00:08:48,149 --> 00:08:49,049
我该怎么做呢

223
00:08:49,049 --> 00:08:49,200
嗯

224
00:08:49,200 --> 00:08:52,529
我们有两种类型的数据类型可以用，float和double

225
00:08:52,529 --> 00:08:55,440
也有一些修饰符可以用，比如long double

226
00:08:55,440 --> 00:08:56,490
我们不打算讲这些

227
00:08:56,490 --> 00:09:02,820
所以float基本上是一个小数，占用4个字节

228
00:09:02,820 --> 00:09:04,350
我们来定义一个变量

229
00:09:04,350 --> 00:09:05,580
比如五点五

230
00:09:05,580 --> 00:09:06,480
我们怎么做呢

231
00:09:06,480 --> 00:09:07,889
我们也来把这个a换成这个变量

232
00:09:07,889 --> 00:09:11,039
从而把我们的float变量打印出来，编译我们的文件

233
00:09:11,039 --> 00:09:12,690
让我们F5来运行我们的程序

234
00:09:12,690 --> 00:09:13,919
你可以看到我们得到了5.5

235
00:09:13,919 --> 00:09:15,450
非常好

236
00:09:15,450 --> 00:09:18,509
现在你可能认为你已经定义了一个浮点数（float）

237
00:09:18,509 --> 00:09:19,799
但实际上你没有

238
00:09:19,799 --> 00:09:22,169
你定义的其实是一个双精度（double）

239
00:09:22,169 --> 00:09:24,929
如果我们回到vs，并将鼠标悬停在这个值上

240
00:09:24,929 --> 00:09:25,860
你可以在括号里看到

241
00:09:25,860 --> 00:09:26,669
它是double的

242
00:09:26,669 --> 00:09:27,720
正如我刚才提到的

243
00:09:27,720 --> 00:09:31,740
我们有两个不同的变量可以用来存放小数

244
00:09:31,740 --> 00:09:33,450
float和double

245
00:09:33,450 --> 00:09:36,809
那么我们如何区分double和float呢

246
00:09:36,809 --> 00:09:37,350
我们的方法是

247
00:09:37,350 --> 00:09:41,340
基本上就是在float变量后附上一个f

248
00:09:41,340 --> 00:09:43,110
它可以是小写的或大写的

249
00:09:43,110 --> 00:09:43,980
无所谓

250
00:09:43,980 --> 00:09:44,700
但关键是

251
00:09:44,700 --> 00:09:45,899
如果我们有一个F

252
00:09:45,899 --> 00:09:48,389
你可以说我们实际上已经声明了一个float

253
00:09:48,389 --> 00:09:50,340
float基本上是四个字节大小

254
00:09:50,340 --> 00:09:53,460
而double是8个字节大小

255
00:09:53,460 --> 00:09:53,909
最后

256
00:09:53,909 --> 00:09:56,669
我们还有一个原始的数据类型可以用

257
00:09:56,669 --> 00:09:58,110
也就是bool（布尔型）

258
00:09:58,110 --> 00:09:59,610
bool代表boolean

259
00:09:59,610 --> 00:10:02,759
它要么是真(true)，要么是假(false)

260
00:10:02,759 --> 00:10:05,820
如果我们试着打印到控制台，按F5

261
00:10:05,820 --> 00:10:09,419
你可以看到，我们其实得到了一个数值———1，因为当然了

262
00:10:09,419 --> 00:10:12,149
没有真或假这种东西

263
00:10:12,149 --> 00:10:15,059
那只是英语单词而已，计算机只处理数字

264
00:10:15,059 --> 00:10:19,110
所以基本上零意味着0代表false，0以外的任何东西

265
00:10:19,110 --> 00:10:21,929
任何其他数字，都是true

266
00:10:21,929 --> 00:10:22,529
在我们这种情况下

267
00:10:22,529 --> 00:10:24,450
我们有一个1被打印到控制台

268
00:10:24,450 --> 00:10:26,129
表明它是true

269
00:10:26,129 --> 00:10:29,070
如果我们把这个改成false并运行我们的程序

270
00:10:29,070 --> 00:10:30,210
我们会得到0

271
00:10:30,210 --> 00:10:31,049
意思是false

272
00:10:31,049 --> 00:10:34,139
bool数据类型占一个字节的内存

273
00:10:34,139 --> 00:10:35,129
现在你可能会想

274
00:10:35,129 --> 00:10:39,299
“1个字节？为啥呀？一个bool只能是true或者false，

275
00:10:39,299 --> 00:10:43,139
显然只需要1个bit来表示啊！” 你是对的！！

276
00:10:43,139 --> 00:10:45,090
它确实只需要1个bit来表示

277
00:10:45,090 --> 00:10:45,659
然而

278
00:10:45,659 --> 00:10:47,460
当我们在处理内存寻址时

279
00:10:47,460 --> 00:10:47,700
也就是说

280
00:10:47,700 --> 00:10:51,509
当我们需要从内存中获取或者存储我们的bool时

281
00:10:51,509 --> 00:10:54,720
我们没有办法寻址到每个bit

282
00:10:54,720 --> 00:10:56,610
我们只能寻址到bytes

283
00:10:56,610 --> 00:10:58,799
正因为如此，我们无法创建一个大小只有1bit的变量类型

284
00:10:58,799 --> 00:11:03,690
因为我们需要能够访问它，而我们不能

285
00:11:03,690 --> 00:11:05,549
我们现在只能访问bytes

286
00:11:05,549 --> 00:11:05,970
当然

287
00:11:07,230 --> 00:11:07,830
你可以做的是，

288
00:11:07,830 --> 00:11:13,230
巧妙的将8个bools存在1个byte里面

289
00:11:13,230 --> 00:11:14,669
这完全没问题

290
00:11:14,669 --> 00:11:15,899
每个bool占一个bit

291
00:11:15,899 --> 00:11:22,919
但是你仍然只需那一个byte的内存，我们可能会在未来谈论一些高级的、有趣的技巧

292
00:11:22,919 --> 00:11:25,769
但就目前而言，bool占一个字节

293
00:11:25,769 --> 00:11:29,100
所以所有这些关于大小、bytes

294
00:11:29,100 --> 00:11:31,350
、以及所有东西占多少内存的讨论

295
00:11:31,350 --> 00:11:32,129
那如何

296
00:11:32,129 --> 00:11:35,309
我们到底如何知道数据类型有多大呢？

297
00:11:35,309 --> 00:11:36,600
毕竟这取决于于编译器

298
00:11:36,600 --> 00:11:37,019
After all,

299
00:11:37,019 --> 00:11:38,220
那我们有办法可以检查一下吗

300
00:11:38,220 --> 00:11:38,909
是的

301
00:11:38,909 --> 00:11:39,269
是的

302
00:11:39,269 --> 00:11:40,289
有的

303
00:11:40,289 --> 00:11:43,950
这C++里我们可以用一个叫sizeof的操作符

304
00:11:43,950 --> 00:11:45,000
如果我们来到这里

305
00:11:45,000 --> 00:11:47,100
比如说我们打印sizeof(bool)

306
00:11:47,100 --> 00:11:48,029
for example,

307
00:11:48,029 --> 00:11:53,220
我们基本上只需要输入sizeof，然后在括号里或者不要括号，没关系的

308
00:11:53,220 --> 00:11:56,309
不过我更喜欢用括号，或者我该说圆括号

309
00:11:56,309 --> 00:11:58,320
然后我们输入我们的数据类型

310
00:11:58,320 --> 00:12:01,649
按F5，你可以看到我们的bool是1 byte

311
00:12:01,649 --> 00:12:04,350
如果我用int替换它 按F5

312
00:12:04,350 --> 00:12:05,460
我们得到4

313
00:12:05,460 --> 00:12:07,980
如果我填double 按F5

314
00:12:07,980 --> 00:12:11,309
我们得到8，挺酷的

315
00:12:11,309 --> 00:12:14,009
这基本上就是变量的全部

316
00:12:14,009 --> 00:12:15,960
或者至少是我讲过的原始类型

317
00:12:15,960 --> 00:12:19,500
你其实可以在c++中创造出很多不同的类型

318
00:12:19,500 --> 00:12:21,269
以及很多已经为你创造了的

319
00:12:21,269 --> 00:12:21,600
然而

320
00:12:21,600 --> 00:12:25,259
它们都是基于这些基本类型的定制类型

321
00:12:25,259 --> 00:12:31,590
这些是我们用来定义和存储我们可能创建的任何类型的数据的基础

322
00:12:31,590 --> 00:12:33,539
现在 有了这些原始数据类型

323
00:12:33,539 --> 00:12:37,289
我们也可以将它们转换为指针（pointer）或引用（reference）

324
00:12:37,289 --> 00:12:45,389
指针可以通过在你的类型旁边写一个星号来声明，而引用是你的类型旁边加上一个&符号

325
00:12:45,389 --> 00:12:52,799
指针和引用是一个很大很复杂也很重要的话题，我真的想把它们保存在单独的视频中

326
00:12:52,799 --> 00:12:54,389
这样你们就能正确地理解了

327
00:12:54,389 --> 00:12:55,500
所以现在在这个视频中

328
00:12:55,500 --> 00:12:57,179
我们只会讨论这些原始类型

329
00:12:57,179 --> 00:12:58,889
确保你理解它们

330
00:12:58,889 --> 00:13:02,580
它们将成为你所写的任何东西的基础

331
00:13:02,580 --> 00:13:03,809
所以它们真的很重要

332
00:13:03,809 --> 00:13:04,409
但无论如何

333
00:13:04,409 --> 00:13:05,820
我希望你们喜欢这个视频 

334
00:13:05,820 --> 00:13:06,330
如果你这样做了

335
00:13:06,330 --> 00:13:07,860
请按这个按钮

336
00:13:07,860 --> 00:13:10,559
你也可以在Twitter和Instagram上关注我

337
00:13:10,559 --> 00:13:15,240
如果你真的喜欢这个视频你想成为未来视频制作的一部分

338
00:13:15,240 --> 00:13:17,909
你想为这些视频的计划做贡献

339
00:13:17,909 --> 00:13:21,549
以及收到我制作的早期视频草稿

340
00:13:21,720 --> 00:13:26,129
那请支持我的Patreon
链接将会在你这个视频的描述中

341
00:13:26,129 --> 00:13:29,190
你的支持让这些视频成为可能 感谢观看了这些视频

342
00:13:29,190 --> 00:13:30,149
我们下次再见

343
00:13:30,149 --> 00:13:30,779
Good Bye!

344
00:13:34,679 --> 00:13:34,740
是的

