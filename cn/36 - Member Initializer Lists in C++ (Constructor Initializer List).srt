1
00:00:00,000 --> 00:00:04,174
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:04,232 --> 00:00:10,199
今天我们要讲的是构造函数初始化列表， 这是一个很好的句子

3
00:00:10,199 --> 00:00:11,824
这基本上是什么意思呢？

4
00:00:11,826 --> 00:00:17,649
就是我们在构造函数中初始化类成员的一种方式

5
00:00:17,879 --> 00:00:23,225
当我们编写类并向这个类添加成员的时候，通常需要用某种方式对这些成员进行初始化

6
00:00:23,225 --> 00:00:29,300
一般这发生在构造函数中，我们有两种方法可以在构造函数中初始化类成员

7
00:00:29,300 --> 00:00:30,449
让我们来看下

8
00:00:30,488 --> 00:00:33,549
我在这里有个Entity类，他有一个字符串成员m_Name

9
00:00:33,549 --> 00:00:38,549
它还没有构造函数，我们来添加下，其中一个构造函数接受name作为参数

10
00:00:38,881 --> 00:00:44,125
我还要创建一个默认构造函数，它没有任何参数

11
00:00:44,471 --> 00:00:53,174
在这种情况下，我想把传入的name的值赋值给m_Name，因为我想通过传入参数设置Entity的name

12
00:00:53,528 --> 00:00:59,024
在这里，我们简单地把name设置为"Unknown",这也许看起来不错

13
00:00:59,238 --> 00:01:04,924
你可能在其他的语言中一直都是这么做的，但实际上C++中还有另一种方式

14
00:01:05,060 --> 00:01:07,049
这就是初始化成员列表

15
00:01:07,180 --> 00:01:12,900
先来看下这些代码运行是什么样子的，为了确保他能工作，我要在这里创建一个Entity

16
00:01:12,900 --> 00:01:15,875
然后要打印出这个Entity的name

17
00:01:16,138 --> 00:01:23,700
我叫他e0，代表这是第一个例子, 然后是e1，给它一个名字 Cherno

18
00:01:23,851 --> 00:01:28,250
按F5,你可以看到这种情况下先后打印出了"Unknown" 和 "Cherno"

19
00:01:28,526 --> 00:01:32,075
看起来一切顺利，然我们来看看第二种初始化方法

20
00:01:32,274 --> 00:01:37,474
不像是在这里直接设置m_Name的值，我们可以像这样使用成员初始化列表

21
00:01:37,545 --> 00:01:43,125
在构造函数或者构造函数和参数的后面，添加一个冒号

22
00:01:43,325 --> 00:01:49,090
这个可以和构造函数在同一行，这没什么影响，通常我喜欢写在另一行，像这样缩进

23
00:01:49,244 --> 00:01:52,525
然后开始列出你想要初始化的成员

24
00:01:52,738 --> 00:01:59,849
在这里我们有m_Name, 所以我们要做的就是写m_Name,然后给它一个值，这里是"Unknown"

25
00:02:00,046 --> 00:02:05,299
这样写就代替了这个，这就是成员初始化列表的使用方式了

26
00:02:05,585 --> 00:02:09,474
如果我们还有另一个成员，比如说m_Score

27
00:02:09,474 --> 00:02:14,050
我们只需要加一个逗号，然后是另一个成员，在这里，我把它初始化为0

28
00:02:14,155 --> 00:02:19,925
还有件事你需要知道，如果你像这样定义这些变量，那么你再成员初始化列表中

29
00:02:19,925 --> 00:02:22,175
要按照和上面相同的顺序写

30
00:02:22,308 --> 00:02:25,925
如果你不按顺序写，有些编译器会警告你

31
00:02:26,097 --> 00:02:30,150
这真的很重要，因为不管你怎么写初始化列表

32
00:02:30,266 --> 00:02:35,266
他都会按照类成员的定义顺序进行初始化

33
00:02:35,349 --> 00:02:39,199
所以在这里它会先初始化整形，然后再初始化字符串

34
00:02:39,474 --> 00:02:44,175
即使你在写初始化列表的时候，用另一种顺序来写，比如先初始化字符串，然后在初始化整形

35
00:02:44,264 --> 00:02:48,250
如果你打破这个顺序，就会导致各种依赖问题

36
00:02:48,480 --> 00:02:54,449
所以你要确保在写成员初始化列表的时候，要保持和成员变量的声明顺序一样

37
00:02:54,763 --> 00:03:03,349
在这里它是这样的，我们有m_Name，然后像这样把要复制的值放在这里，这就是赋值的方式

38
00:03:03,528 --> 00:03:07,650
基本上就是用括号替换等号，然后把它移动到这个列表里

39
00:03:07,772 --> 00:03:10,699
如果我们运行代码，你会看到我们得到了完全相同的结果

40
00:03:10,902 --> 00:03:14,525
好了，这就是成员初始化列表，很简单

41
00:03:14,702 --> 00:03:19,949
最大的问题是，Why? 为什么我们要用这个？只是因为代码风格的问题嘛？

42
00:03:20,149 --> 00:03:23,550
答案是：是 也不是。

43
00:03:23,800 --> 00:03:25,275
不是，可能是个更正确的答案

44
00:03:25,531 --> 00:03:30,775
我喜欢这样写代码，因为如果你有很多的成员变量

45
00:03:31,019 --> 00:03:38,525
在这里对他们进行初始化，可能会非常杂乱， 很难看出构造函数在做什么

46
00:03:38,794 --> 00:03:42,974
因为你可能在后面还有很多代码在做其他的事情

47
00:03:43,050 --> 00:03:48,349
但是你的构造函数大部分内容都是在做初始化变量这样琐碎无聊的事情

48
00:03:48,574 --> 00:03:54,686
你可能不想显示它们，你想隐藏他们，这就是为什么我喜欢把他们放在成员初始化列表里

49
00:03:54,816 --> 00:03:57,525
因为即使是从代码风格来看，我也更喜欢这么写

50
00:03:57,716 --> 00:04:01,250
他让我的构造函数的代码非常非常干净而且容易阅读

51
00:04:01,375 --> 00:04:06,954
实际上还有一个功能上的区别，这个区别特定的作用在类上

52
00:04:07,212 --> 00:04:15,925
如果你想这样写代码，在这里给m_Name赋值等于Unknown, 然后去掉成员初始化列表中的赋值

53
00:04:16,292 --> 00:04:20,449
实际上会发生的事，这个m_Name会被构造两次

54
00:04:20,610 --> 00:04:28,824
一次是默认构造函数，然后是再用这个Unknown参数，因为这里实际上发生的是这个

55
00:04:29,024 --> 00:04:35,574
所以你创建了两个字符串，其中一个被直接抛弃了，这是性能浪费对吧？

56
00:04:35,798 --> 00:04:39,625
让我们来演示一下，我要在这里创建一个非常非常简单的Example类

57
00:04:39,845 --> 00:04:44,225
他只有一个public的构造函数，让这个例子更真实一点

58
00:04:44,460 --> 00:04:52,600
我在这里打印 "Create Entity", 然后再创建一个构造函数，它接受一个参数x

59
00:04:52,911 --> 00:04:57,074
我要打印出 "Create Entity With" 和变量x

60
00:04:57,346 --> 00:05:01,149
删除下面这些代码

61
00:05:01,899 --> 00:05:08,875
我要把Entity类作为Entity的一个类成员，以我的习惯，叫他m_Example

62
00:05:09,390 --> 00:05:14,824
这是整个类，他有两个构造函数，一个没有参数一个有个参数x

63
00:05:15,131 --> 00:05:20,131
我想做的是在Entity的默认构造函数，不带参数的这个

64
00:05:20,255 --> 00:05:26,800
我想把m_Example设置为Example类的对象，它带有一个参数8

65
00:05:27,053 --> 00:05:33,524
到下面这里，确保我创建了Entity对象，先删除其他，删除这个GetName的打印

66
00:05:33,929 --> 00:05:38,929
这里我所的就是使用这个默认构造函数创建了一个Entity对象

67
00:05:38,929 --> 00:05:43,600
按F5,看这里，我们创建了两个Entity

68
00:05:43,816 --> 00:05:49,100
一个是默认构造函数，是没有参数的；一个是有个整形参数的构造函数

69
00:05:49,261 --> 00:05:52,125
所以我们实际上创建了两个Entity，对吧？

70
00:05:52,384 --> 00:05:56,699
一个实在这里创建的，就像这样写一样

71
00:05:57,175 --> 00:06:01,949
我的意思是如果他在这里创建了一个Entity对象，这里就会创建个Example对象

72
00:06:01,949 --> 00:06:07,399
他在这种成员区域，并不意味着就不会运行代码进行创建实例

73
00:06:07,399 --> 00:06:13,375
然后我们还在这里创建了一个新的Example对象，然后把它赋值给m_Example(old one)

74
00:06:14,199 --> 00:06:18,500
我们创建了一个Example实例，扔掉它，然后用新的实例覆盖掉它

75
00:06:18,697 --> 00:06:20,649
我们创建了两个对象而不是一个

76
00:06:20,872 --> 00:06:28,050
但是如果我们把它移动到初始化列表中，我们有两种选择

77
00:06:28,237 --> 00:06:33,237
可以像以前那样写，就像这样，如果按F5

78
00:06:33,237 --> 00:06:37,625
你会看到我们运行了构造函数，只创建了一个实例

79
00:06:37,786 --> 00:06:44,175
或者我可以删掉这个，然后传入参数，然后按F5，你会看到这是一样的结果

80
00:06:44,377 --> 00:06:53,399
这就是区别，对吧？你应该到处使用成员初始化列表。绝对没有不使用它们的理由。

81
00:06:53,580 --> 00:06:59,125
如果你不喜欢这种代码风格，你要习惯它们，因为这不仅仅是代码风格问题，它实际上还有功能上的区别

82
00:06:59,320 --> 00:07:02,800
如果你不使用它们，就会造成性能上的浪费

83
00:07:03,071 --> 00:07:09,925
当然并非所有情况都是这样，对于整形这样的基本类型，
他不会被初始化，直到你通过显式赋值来初始化它们

84
00:07:09,925 --> 00:07:13,824
我总是使用它们，我不会区分原始类型和类类型

85
00:07:13,824 --> 00:07:16,949
你应该在所有地方使用成员初始化列表

86
00:07:17,122 --> 00:07:19,000
好了，今天的视频就到这里了。

87
00:07:19,110 --> 00:07:24,110
...

