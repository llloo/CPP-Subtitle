1
00:00:00,040 --> 00:00:03,520
Hey 大家好，我是 Cherno，欢迎回到我的c + +系列。

2
00:00:03,520 --> 00:00:08,130
今天我们要讲的C++中的枚举(enums)  enum是enumeration的缩写

3
00:00:08,130 --> 00:00:11,099
基本上就是一些值的集合

4
00:00:11,130 --> 00:00:17,129
如果您想要给枚举一个更实用的定义，那就是给一个值指定一个名称。

5
00:00:17,129 --> 00:00:20,969
我们不用设置一堆叫做 a,b,c 的整数值

6
00:00:20,969 --> 00:00:25,500
而是可以设置一个包含与整数 a,b,c 相对应的枚举

7
00:00:25,500 --> 00:00:30,739
这很方便我们设置一组数值，而不仅仅只是用整形作为一个类型

8
00:00:30,739 --> 00:00:35,759
当然你也可以给它赋值任何整数，并且限制那些值可以可以赋值

9
00:00:35,759 --> 00:00:38,899
就这样，没什么复杂的。

10
00:00:38,899 --> 00:00:44,579
这就是一种给值命名的方式，这在你想用一些整数来表示特定的状态或数值时很有用。

11
00:00:44,579 --> 00:00:48,560
给这些值命名后，你的代码会变得更易读
(定义枚举类型的主要目的：增加程序的可读性)

12
00:00:48,600 --> 00:00:51,240
最后要说的是：枚举值就是一个整数

13
00:00:51,240 --> 00:00:55,590
在代码里，可能看起来有点不一样，它还能让你的代码保持得更整洁

14
00:00:55,590 --> 00:00:56,670
让我们来看一下

15
00:00:56,670 --> 00:00:59,850
假设我有三个值要处理

16
00:00:59,850 --> 00:01:06,959
把 A 设为0，B 设为1，C设为2

17
00:01:06,959 --> 00:01:11,780
现在我有了三个要处理的值，然后在 main 函数里来使用一个变量value

18
00:01:11,780 --> 00:01:14,040
把 value 设置为上面三个值的其中一个

19
00:01:14,040 --> 00:01:19,920
我可能有些代码来检查当前的 value, 然后执行某些操作

20
00:01:19,920 --> 00:01:22,439
这看起来还行，但是也有一些问题

21
00:01:22,439 --> 00:01:32,250
首先就是，A,B,C 没有分组，在后面的代码中你可能还有变量 D，或者你想重新声明 A, 这就出现问题了

22
00:01:32,250 --> 00:01:35,260
最本质上的问题就是这些数据没有进行分组。

23
00:01:35,260 --> 00:01:41,340
而且这些都是整数，这意味如果我突然把 value 赋值为5，那下面的代码就没有任何意义了

24
00:01:41,340 --> 00:01:50,189
我们希望可以定义一种数据类型，使它的值只能是这三个中的的某一个值，而且可以把这些数据组合起来；这就是枚举的使用场景了。

25
00:01:50,189 --> 00:01:53,430
定义一个叫 Example 的枚举来替代这些

26
00:01:53,430 --> 00:01:57,930
然后把我们想要的值放在这里，比如说 A,B,C

27
00:01:57,930 --> 00:02:02,549
这里不用Integer作为类型，可以用这个枚举的名称作为一个实际类型

28
00:02:02,549 --> 00:02:06,689
所以我可以写一个Example类型的值，把这里的 a,b,c 改成小写

29
00:02:06,689 --> 00:02:11,759
这样我就可以用我的枚举值了，我可以这样给 value 赋值

30
00:02:11,759 --> 00:02:16,939
如果我给它赋值其他的值就会报错，因为它必须是这三个值中的一个

31
00:02:16,939 --> 00:02:20,560
最后记住了，这些数据就是一些整数。

32
00:02:20,560 --> 00:02:26,960
如果我把它赋值为 B,然后进行比较是否等于 1

33
00:02:26,960 --> 00:02:32,789
因为B的值就是1，如果你把鼠标停在上面，编辑器会告诉你B的值就是1

34
00:02:32,789 --> 00:02:36,039
你也可以改变这些变量的值

35
00:02:36,039 --> 00:02:40,680
默认情况下，第一个变量的值是0，然后接下来变量会一个接一个的递增(1,2,3...)

36
00:02:40,680 --> 00:02:46,409
你可以把这个设置为0，这个设为2，然后这个是6

37
00:02:46,409 --> 00:02:47,639
你想设置任何数都行

38
00:02:47,639 --> 00:02:53,610
如果你想把它设置为不是从0开始的，比如说5，而且你没有指定接下来这些变量的值

39
00:02:53,610 --> 00:02:59,009
你就会看到这个的值就是6，这个是7，因为它就是从5开始递增的

40
00:02:59,009 --> 00:03:04,620
还有一个就是你还可以指定你的枚举值的数据类型

41
00:03:04,620 --> 00:03:07,199
在这里写上冒号，然后是数据类型

42
00:03:07,199 --> 00:03:10,860
比如说，unsigned char类型。 枚举值的默认类型是 32 位的整数。

43
00:03:10,860 --> 00:03:14,819
但是在这个例子中，我们没必要使用 32 位的值。

44
00:03:14,819 --> 00:03:18,870
我们可以使用 8 位的整数，比如 unsigned char

45
00:03:18,870 --> 00:03:21,930
这样更好，因为这占用了更少的内存空间

46
00:03:21,930 --> 00:03:24,659
你不能用 float

47
00:03:24,659 --> 00:03:28,680
因为这里float不是整形，这里只能用整形

48
00:03:28,680 --> 00:03:31,169
比如说可以在这里用 char

49
00:03:31,169 --> 00:03:33,419
好了 这些就是 enum 的本质内容

50
00:03:33,419 --> 00:03:39,449
它就是给特定值命名的一种方式，这样你就不用到处处理各种整形数据了

51
00:03:39,449 --> 00:03:46,860
让我们来看一个在Log类中真实使用枚举的例子，这个Log类我们在“如何个写一个C++类”(p20)中说过

52
00:03:46,860 --> 00:03:48,870
让我们回到Log类中

53
00:03:48,870 --> 00:03:52,680
你会看到我们在这里使用了3个不同的日志级别

54
00:03:52,680 --> 00:03:55,229
它们的值是0到2

55
00:03:55,229 --> 00:03:58,860
这里是一个非常适合使用枚举的地方

56
00:03:58,860 --> 00:04:03,860
在这里我们有三个整形的值用来表示不同的特定状态

57
00:04:03,860 --> 00:04:09,479
在这个例子中，不同的log级别会展示出不同的日志内容。 在这个log类内部

58
00:04:09,479 --> 00:04:16,439
我要建一个log级别的枚举值，枚举值是Error, Warning 和 Info

59
00:04:16,439 --> 00:04:21,990
按照我的编程封给，我喜欢显示的写成 Error = 0

60
00:04:21,990 --> 00:04:26,819
但这不是必须的，因为它默认就是从0开始的

61
00:04:26,819 --> 00:04:30,360
我就是喜欢做些增加代码可读性的事

62
00:04:30,360 --> 00:04:34,079
把这些删掉；日志级别的类型不是int了

63
00:04:34,079 --> 00:04:40,589
当然我也还可以这么写，把它赋值为Info, 因为枚举值其实就是整数，这样也能工作的

64
00:04:40,589 --> 00:04:48,689
但是这样写的话，我可以把 m_LogLevel设置为任何整数，但是我只想把它设置为这三个当中的某个值

65
00:04:48,689 --> 00:05:00,930
所以我把这个设置为Level枚举类型，注意这里我就创见了限制，它的值只能是前面设置的那三个。编译器会从语法上就执行这个限制。你可以很容易地绕过它

66
00:05:00,930 --> 00:05:03,449
它不是物理上无法设置的东西。

67
00:05:03,449 --> 00:05:07,589
当然，这个例子中的枚举值就是4个字节的整形，它就是四个字节的内存。

68
00:05:07,589 --> 00:05:09,509
你可以把任何东西放进那个内存中。

69
00:05:09,509 --> 00:05:16,259
通过设置Level类型来限制你的代码，只允许设置为Level的枚举值

70
00:05:16,259 --> 00:05:21,180
修改SetLevel函数, 然后在做这些比较，仍然可以很好地工作

71
00:05:21,180 --> 00:05:26,879
我只要把LogLevelError改成Error, 因为m_LogLevel是枚举类型的

72
00:05:26,879 --> 00:05:32,550
因为它是一个整数，我仍然可以进行比较，对于这种情况枚举是非常非常有用的

73
00:05:32,550 --> 00:05:37,500
把这个改成Warning, 再把这个改成Info, 还要改动的就是这里

74
00:05:37,500 --> 00:05:44,100
log.LogLevelError 这是一个整数，现在改成 Log::Error

75
00:05:44,100 --> 00:05:51,600
因为我们的Error枚举值是在Log类命名空间的，而枚举类型Level本身不是一个命名空间

76
00:05:51,600 --> 00:05:55,290
还有一些叫枚举类的东西，我们会在以后的视频中讲到

77
00:05:55,290 --> 00:05:59,100
但是对于普通的枚举来说，Level不是一个命名空间

78
00:05:59,100 --> 00:06:05,639
所以你不能把它当作命名空间，也就是说Error, Warning和Info只是单纯的存在Log类里

79
00:06:05,639 --> 00:06:08,399
而且你看我也可以把它写成Warning 也没啥问题

80
00:06:08,399 --> 00:06:13,139
你可能看到写成Error出现了一个报错

81
00:06:13,139 --> 00:06:16,889
原因是因为我们还定义了一个叫Error的方法

82
00:06:16,889 --> 00:06:22,769
名字重复了，我故意写成这样就是为了给你们展示命名冲突是怎样的

83
00:06:22,769 --> 00:06:26,819
在这里我们要引用Error的时候，程序是没法工作的

84
00:06:26,819 --> 00:06:31,110
他不知道你调用的是Error函数，我们绝对不能在这里定义一个叫Error的东西

85
00:06:31,110 --> 00:06:33,660
如果我们想要有一个同名的函数。

86
00:06:33,660 --> 00:06:36,600
我们只需要在枚举值前面加上Level就好了

87
00:06:36,600 --> 00:06:41,069
顺便说下，这是很普遍的做法，这样我们就很清楚要用的是什么了

88
00:06:41,069 --> 00:06:43,860
而且这个名字在枚举里也并没有什么太大的意义

89
00:06:43,860 --> 00:06:45,629
把这个设置为LevelError

90
00:06:47,160 --> 00:06:50,160
LevelWarning 还有 LevelInfo

91
00:06:50,160 --> 00:06:56,189
现在可以删掉这些，这里改成LevelError

92
00:06:56,189 --> 00:06:59,639
运行代码，就会得到我们期望的结果

93
00:06:59,639 --> 00:07:01,139
打印出了Error的信息

94
00:07:01,139 --> 00:07:03,060
因为我们把log级别设置为Error

95
00:07:03,060 --> 00:07:07,920
好了，枚举的本质就是为了让代码更清晰

96
00:07:07,920 --> 00:07:12,509
枚举的背后就是整数，你可以像整数一样以任何方式使用它们

97
00:07:12,509 --> 00:07:16,800
在以后的视频里会有很多很多用到枚举的地方

98
00:07:16,800 --> 00:07:19,829
我也会在另一个视频里讲解枚举类

99
00:07:19,829 --> 00:07:25,199
本质上来说，在任何使用数字集合的地方，枚举都是很好的选择

100
00:07:25,199 --> 00:07:32,069
下次见，GoodBye~

