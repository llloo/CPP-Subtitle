1
00:00:00,000 --> 00:00:02,975
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:03,120 --> 00:00:06,375
今天我们来讨论下C++中的const关键字

3
00:00:06,375 --> 00:00:09,474
好像很多人对这个很困惑，希望这个视频能让你搞明白

4
00:00:09,651 --> 00:00:18,625
我喜欢把const叫做一个假的关键字，这是因为它实际上在生成代码的时候并没有做什么

5
00:00:18,781 --> 00:00:27,625
它有点像类和结构体的可见性，是一种针对开发人员写代码的强制规则

6
00:00:27,625 --> 00:00:30,993
为了让代码保持整洁的的机制

7
00:00:31,212 --> 00:00:38,200
基本上const就是你做出承诺某些东西是不变的，是不会改动的

8
00:00:38,391 --> 00:00:45,075
但是这只是个承诺，而且你可以绕过或不遵守这个承诺，就像在现实生活中一样

9
00:00:45,100 --> 00:00:49,000
就像我承诺每天都做视频，但是并没有

10
00:00:48,975 --> 00:00:53,274
不管怎么说，重点是它只是一个承诺

11
00:00:53,458 --> 00:00:57,799
它承诺某些东西是不变的，至于是否遵守这个承诺就取决于你了

12
00:00:57,979 --> 00:01:09,474
这是某种意义上你应该遵守的承诺
我们把它保持不变的原因是这样可以帮助简化代码

13
00:01:09,621 --> 00:01:13,099
而且还有很多其他的优点，我接下来会讲到

14
00:01:13,316 --> 00:01:16,200
回到代码来给你演示下我在说什么

15
00:01:16,351 --> 00:01:22,599
如果我像这样声明一个整形，设置为5，这样我可以把它改成任何我想要的数

16
00:01:22,859 --> 00:01:27,099
但是如果我把它声明为const,你看我就不能再改动它

17
00:01:27,256 --> 00:01:29,799
当我在这里写const, 就相当于做了一些事了

18
00:01:29,799 --> 00:01:36,375
首先，从语法上指定了这个整数a是一个常数,以后也不会去改动它

19
00:01:36,474 --> 00:01:42,174
如果你要声明MAX_AGE=90这之类的东西const是很有意义的

20
00:01:42,400 --> 00:01:48,700
你肯定不想它是个变量，因为你定义的是一个最大年龄，而且再也不会去改变它

21
00:01:48,936 --> 00:01:51,950
它只是一个你需要在程序里保持的数字

22
00:01:52,048 --> 00:01:56,424
这可能是如何使用const的最简单的例子了

23
00:01:56,424 --> 00:02:01,025
这就是声明一个我不会去改动的变量一种很简单的方式

24
00:02:01,146 --> 00:02:07,200
实际上我不希望它是一个variable, 因为variable暗示它是可以改变的

25
00:02:07,419 --> 00:02:15,525
但是const, 表明你声明的是一个不会改变的常量而不是一个变量

26
00:02:15,650 --> 00:02:18,074
const还有一些其他的用法，我们来看下

27
00:02:18,243 --> 00:02:24,324
第一个适用于指针，当你声明一个指针，然后我要创建一个整形

28
00:02:24,577 --> 00:02:27,574
但是我会在堆上创建这个整形，这样我实际上就得到一个指针

29
00:02:27,650 --> 00:02:31,175
因为这个声明没有const, 我可以做两件事

30
00:02:31,257 --> 00:02:35,275
我可以解引用a，然后把它设置为一个值比如2

31
00:02:35,375 --> 00:02:40,675
然后打印a，我会得到2

32
00:02:40,675 --> 00:02:45,675
然后我可以做的另一件事就是重新分配指针，这样他就会指向其他的东西

33
00:02:45,699 --> 00:02:47,750
比如MAX_AGE

34
00:02:48,949 --> 00:02:52,775
为了绕开这个const限制，我可以把它强制转换成int*类型

35
00:02:52,906 --> 00:02:55,199
通常情况下你不应该这么做

36
00:02:55,308 --> 00:02:58,875
记得我之前说过你可以不遵守const承诺，这就是一种方法

37
00:02:59,027 --> 00:03:03,550
但是如果在这种情况下你这么做，你可以看到我们声明了MAX_AGE是一个常量

38
00:03:03,724 --> 00:03:06,675
编译器有可能会把它当成一个只读的常量

39
00:03:06,853 --> 00:03:10,150
如果你尝试解引用然后写入数据，程序可能会崩溃

40
00:03:10,283 --> 00:03:12,275
但是在这里它还是可以工作的

41
00:03:12,444 --> 00:03:18,125
按F5, 你可以看到打印出了90，因为我们在这里重新分配了指针

42
00:03:18,351 --> 00:03:23,974
我们可以做两件事，我们可以改变这个指针的内容，就是指针指向的内存内容

43
00:03:24,651 --> 00:03:28,150
然后我们也可以改变指针指向的内存地址

44
00:03:28,349 --> 00:03:34,425
现在让我们加上const，首先在这个前面加上const，这就变成了cosnt int *

45
00:03:34,625 --> 00:03:38,125
这是什么意思呢，这就是说你不能再去修改指针指向的内容了

46
00:03:38,574 --> 00:03:44,775
你看我在这里创建了一个指针，但是当我解引用这个指针然后改变他的值时


47
00:03:44,983 --> 00:03:46,349
你能看到我不可以这么做

48
00:03:46,488 --> 00:03:51,650
a的值是实际内存地址的内容，当然，读取a是没有问题的

49
00:03:51,699 --> 00:03:54,824
你看我在这里解引用然后打印它，没有报错

50
00:03:55,074 --> 00:04:00,074
你还可以注意到，当我尝试改变a的时候也是没有报错的

51
00:04:00,180 --> 00:04:05,180
当我把指针指向其他地方比如MAX_AGE的时候，这也没问题

52
00:04:05,256 --> 00:04:11,175
我只是不能改变指针指向的内容，也就是指针指向的内存地址的内容

53
00:04:11,362 --> 00:04:16,362
使用const的第二种方式是把像这样它放在指针的后面

54
00:04:16,495 --> 00:04:24,774
这个作用正好相反，我可以改变指针指向的内容，但是不能把指针自身重新赋值让它指向其他东西

55
00:04:25,004 --> 00:04:32,425
注意，如果你把const放在这里，在*前面int后边

56
00:04:32,643 --> 00:04:44,550
这个和我之前写的功能是一样的， const int* 和 int const*是同一个意思

57
00:04:44,709 --> 00:04:50,100
你只是移动了const,但关键是在*前面还是后面

58
00:04:50,384 --> 00:04:58,524
要让指针变成常量，使它不能被重新分配，你要把const放在*后面在变量名之前

59
00:04:58,714 --> 00:05:05,475
记住这个，因为有时候你会看到不同编码风格的人会写int const*

60
00:05:05,657 --> 00:05:08,250
你要知道它和const int*是一样的

61
00:05:08,456 --> 00:05:11,875
如果你写成int cont*，那就完全不同了

62
00:05:11,992 --> 00:05:18,475
所以这样写是不行的，我不能让它等于任何东西比如空指针等

63
00:05:18,757 --> 00:05:22,875
但是我可以改变指针的内容

64
00:05:23,100 --> 00:05:32,199
最后，我可以像这样写两个const，这就意味着我既不能改变指针的内容，也不能改变指针本身让他指向别处

65
00:05:32,403 --> 00:05:34,175
这是const的第二种使用方式

66
00:05:34,274 --> 00:05:41,399
当你处理指针时，你可以是在说指针本身或者是指针指向的内容

67
00:05:41,603 --> 00:05:49,524
当你把const放在声明处，你可以看到放在*的左边还是右边代表这不同的含义

68
00:05:49,735 --> 00:05:55,149
今天最后要说的是在类和方法中使用const，先来写个类

69
00:05:57,074 --> 00:06:05,500
类名叫Entity，有两个变量 m_X,m_Y，写个示例来初始化它们

70
00:06:05,756 --> 00:06:12,074
我要尝试写getter和setter， 先写GetX,返回m_X

71
00:06:12,238 --> 00:06:20,000
我要把const放在方法名的右边，在参数列表的后面写上const

72
00:06:20,352 --> 00:06:26,250
这就是const的第三种用法，他和变量没有关系，而是用在方法名的后面

73
00:06:26,250 --> 00:06:27,725
顺便说一下，这只有在类里才能这么用

74
00:06:27,899 --> 00:06:37,024
这意味这这个方法不会修改任何实际的类，因此这里你可以看到我们不能修改类的成员变量

75
00:06:37,024 --> 00:06:42,399
如果我试着写m_X=2,这是不行的

76
00:06:42,484 --> 00:06:48,699
对吧，我已经承诺了这个方法不会更改类，这只是一个只读的方法

77
00:06:48,877 --> 00:06:53,425
这个方法只能从类中读取数据，不能修改数据

78
00:06:53,564 --> 00:06:57,100
所以在getter方法后面写上const是有意义的

79
00:06:57,100 --> 00:07:04,100
但是如果是setter，如果我想要一个SetX用来设置m_X的值，我会在这里写m_X=x

80
00:07:04,100 --> 00:07:08,800
所以我不能在这里写const，因为很显然我要更改这个类

81
00:07:09,025 --> 00:07:12,524
所以const通常是用在这里的(getter)

82
00:07:12,670 --> 00:07:16,300
现在如果m_X是一个指针，而且你想让它是常量

83
00:07:16,471 --> 00:07:23,050
你可以把它改成一个指针，然后你可以写const int* const GetX() const

84
00:07:23,300 --> 00:07:29,024
看吧，我们这里一行写了三次const， C++ man，有啥感想？

85
00:07:29,297 --> 00:07:36,699
这表示我们返回了一个不能修改的的指针，指针的内容也不能被修改

86
00:07:36,699 --> 00:07:41,925
而且这个函数也承诺不会修改实际的Entity类

87
00:07:42,175 --> 00:07:45,250
是的，我们对这种方法施加了很多限制

88
00:07:45,411 --> 00:07:50,411
让我们把它改回不是指针的情况，有件事我要快速说下 hh

89
00:07:50,725 --> 00:08:00,675
我要说的是在这里把*放在类型后面，m_X就变成了一个指针，但是m_Y仍然是一个int类型

90
00:08:00,897 --> 00:08:05,897
如果你要让这一行都变成指针，那你要在每个变量前面都加上*

91
00:08:06,190 --> 00:08:11,774
说这个可能跟有点跑题了，但我想你们可能对这个会有点困惑

92
00:08:11,893 --> 00:08:18,000
我们回到了正常情况，问题是我为什么要把这个声明为常量

93
00:08:18,138 --> 00:08:24,625
我明白这是一种承诺，承诺不会在这个函数里修改东西

94
00:08:24,900 --> 00:08:30,050
如果有人扩展这个函数，它们就会说，cool，这里不允许对这个类进行写操作

95
00:08:30,179 --> 00:08:34,600
但是这个是强制的吗？答案是 YES

96
00:08:34,678 --> 00:08:39,678
如果我们在main函数里有Entity的示例，让我们来写一个实际的例子

97
00:08:40,299 --> 00:08:46,450
我创建一个Entity，然后还有一个函数PrintEntity可以访问getter方法

98
00:08:46,673 --> 00:08:54,674
std::cout, 这里传入Entity, 然后 e.GetX(),我们这里就有了一个非常合理的函数

99
00:08:55,799 --> 00:09:02,024
现在我希望能用常量引用传递这个参数，因为我不想复制Entity

100
00:09:02,275 --> 00:09:05,299
我们会在以后的视频中讨论复制的内容

101
00:09:05,417 --> 00:09:12,975
但基本上在这里我不想去复制Entity类，因为这要占用空间，这里是8字节

102
00:09:12,975 --> 00:09:16,399
总的来说就是我不想复制所有的对象，因为那样会很慢

103
00:09:16,519 --> 00:09:20,049
特别是那些只读的东西，所以我要通过常量引用来传递参数

104
00:09:20,449 --> 00:09:24,000
还有件事，如果我通过常量引用来传递参数

105
00:09:24,024 --> 00:09:28,625
这意味着e是常量，就像指针一样，如果这个是指针

106
00:09:28,848 --> 00:09:35,850
我可以修改它的指向，所以我可以写e=nullptr; 这没什么问题

107
00:09:36,078 --> 00:09:44,049
但我不能修改e的内容，如果这里是引用的话，也是同样的情况，不能修改e

108
00:09:44,248 --> 00:09:50,799
我不能给它重新分配，这和指针的工作方式不同

109
00:09:51,012 --> 00:09:55,625
如果你重新分配这个引用，你实际上是在改变这个对象而不是其他的对象

110
00:09:55,810 --> 00:10:02,850
这里没有像指针那样有指针本身和指针指向内容的区别，因为引用就是内容。

111
00:10:03,028 --> 00:10:08,028
这就是你能修改的内容，引用就是那个Entity,因此你不能修改Entity尽管你是引用

112
00:10:08,149 --> 00:10:10,750
重要的就是你你不能修改Entity

113
00:10:10,750 --> 00:10:16,350
所以如果我把这个const移走，突然我就不能调用GetX函数了

114
00:10:16,399 --> 00:10:22,738
因为GetX函数不能保证它不会修改Entity了

115
00:10:22,738 --> 00:10:25,700
他可能会做这样的事，这是怎么回事呢？

116
00:10:25,780 --> 00:10:31,799
我没有直接修改Entity, 但是我调用了一个可以修改Entity的方法，这是不允许的

117
00:10:32,049 --> 00:10:39,450
所以我必须要把方法标记为const，这意味着我可以通过const Entity可以调用任何const函数

118
00:10:39,716 --> 00:10:42,674
正因为如此，你有时候会看到两个版本的函数

119
00:10:42,807 --> 00:10:47,807
比如一个只返回m_X，没有const，另一个放回的事m_X带有const

120
00:10:47,807 --> 00:10:53,899
在这种情况下，它将使用GetX的const版本，否则它会用另一个

121
00:10:54,073 --> 00:10:59,924
有两个功能基本一样的函数看起来有点乱，但是它就是这么工作的

122
00:11:00,058 --> 00:11:08,475
正因为这样，记住如果没有修改类或者不应该修改类时，总是把你的方法标记为const

123
00:11:08,654 --> 00:11:14,325
因为这样，你就能阻止其让人在有常量引用或类似情况下使用你的方法

124
00:11:14,582 --> 00:11:20,149
在某些情况下，有一种const的情况是，你确实需要把方法标记为const

125
00:11:20,354 --> 00:11:25,354
但是由于某些原因，又确实需要修改一些变量

126
00:11:25,508 --> 00:11:30,075
假设这里有个变量，我们要修改它

127
00:11:30,279 --> 00:11:36,500
或许只是为了调试，或者他不会真的影响程序，我们仍然想把这个方法标记为const

128
00:11:36,725 --> 00:11:39,799
但是我们还是要更改这个变量，我们可以做到的

129
00:11:40,013 --> 00:11:45,013
在C++中有个关键词mutable，意思是可以被更改的(可变的)

130
00:11:45,013 --> 00:11:50,750
如果我们把var设置为mutable，你会看到即使在const方法中我们也可以修改的

131
00:11:50,934 --> 00:11:55,934
如果你不标记mutable就不行，标记mutable就可以了，就可以修改它了

132
00:11:56,116 --> 00:12:04,149
这就是什么是mutable的答案，mutable就是允许const方法可以修改变量

133
00:12:04,319 --> 00:12:09,319
希望你们喜欢这个视频，如果喜欢记得点赞

134
00:12:09,575 --> 00:12:19,725
...

