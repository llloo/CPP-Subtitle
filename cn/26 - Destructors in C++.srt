1
00:00:00,000 --> 00:00:03,580
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:03,580 --> 00:00:07,339
上次我们学习了C++中的构造函数以及如何使用它们

3
00:00:07,339 --> 00:00:09,750
如果你还没看的话赶紧去看吧

4
00:00:09,750 --> 00:00:12,509
今天我们要学习的是构造函数的邪恶的兄弟(evil twin), 析构函数(destructor)

5
00:00:12,550 --> 00:00:18,890
它们有相似之处，构造函数在你创建一个对象实例的时候运行，而析构函数是在你销毁一个对象的时候运行

6
00:00:18,890 --> 00:00:22,640
在任何时候，当一个对象被销毁的时候，析构函数都会被调用

7
00:00:22,640 --> 00:00:27,519
构造函数通常用在你需要设置变量或者做些初始化工作的时候

8
00:00:27,519 --> 00:00:33,399
同样地，析构函数可以用在你释放任何内容或者需要清理内存空间的时候

9
00:00:33,450 --> 00:00:36,280
析构函数同时适用于栈和堆分配的内存。

10
00:00:36,280 --> 00:00:40,740
因此如果你用new关键字创建一个对象(存在于堆上)，然后你调用delete, 析构函数就会被调用

11
00:00:40,740 --> 00:00:46,250
如果你只有基于栈的对象，当跳出作用于的时候这个对象会被删除，所以这时侯析构函数也会被调用

12
00:00:46,369 --> 00:00:48,420
让我们来看些例子

13
00:00:48,420 --> 00:00:53,340
在讲解构造函数的视频中，我们创建了这个Entity类，还有一些构建函数。

14
00:00:53,340 --> 00:00:55,090
让我们来增加一个析构函数

15
00:00:55,090 --> 00:00:58,429
析构函数前面有个波形符 (~)，然后是类名

16
00:00:58,429 --> 00:01:03,350
总的来说，构造和析构函数在声明和定义的唯一区别就是

17
00:01:03,350 --> 00:01:07,189
放在析构函数前面的这个波形符 (~)

18
00:01:07,189 --> 00:01:08,609
这就是析构函数的定义方式

19
00:01:08,609 --> 00:01:18,700
这个例子中，我们有一个包含两个成员X和Y的类，很明显当我们为这两个浮点数申请内存的时候并没有考虑怎样去清除

20
00:01:18,700 --> 00:01:24,200
暂时先别担心，我们以后会学习内存分配等更多复杂的问题。

21
00:01:24,200 --> 00:01:28,790
在这里我们继续添加一条消息用来告诉我们这个对象已经被删除

22
00:01:28,790 --> 00:01:31,920
我可以写上 ”Destroyed Entity!“

23
00:01:33,209 --> 00:01:38,840
然后在构造函数里写上 ”Constructed Entity“

24
00:01:39,969 --> 00:01:43,969
这里应该写 ”Created“, 因为前面我们写的是 ”Destroyed“ 而不是 ”Destructed“

25
00:01:43,969 --> 00:01:46,680
把这个构造函数删掉，免得我们弄混掉

26
00:01:46,680 --> 00:01:52,269
我把X和Y设置为0，然后这些也删掉。

27
00:01:52,939 --> 00:01:58,450
因为这是栈分配的，我们会看到当main函数执行完的时候析构函数就会被调用

28
00:01:58,450 --> 00:02:01,829
好吧，我们其实是看不到的，因为程序在那个时候会直接关掉。

29
00:02:01,829 --> 00:02:06,290
所以我要在这里写一个函数用来做Entity的所有操作

30
00:02:06,959 --> 00:02:10,120
把代码移到这里，然后调用Function

31
00:02:10,189 --> 00:02:12,210
如果我像这样直接运行代码

32
00:02:12,210 --> 00:02:18,509
你会先看到打印出”Created Entity“, 然后Print函数执行并打印出X和Y, 最后打印出 ”Destroyed Entity“

33
00:02:18,870 --> 00:02:20,680
让我们来深入了解下这些是怎样工作的

34
00:02:20,680 --> 00:02:25,180
在28行放置一个断点，然后按F5运行

35
00:02:25,180 --> 00:02:27,229
现在控制台中没有任何东西

36
00:02:27,229 --> 00:02:31,560
按下F10再看，你会看到 ”Created Entity“

37
00:02:31,560 --> 00:02:35,860
然后再按F10去调用Print函数，你会看到X和Y被打印出来了

38
00:02:35,860 --> 00:02:42,159
最后在到达作用域的底部，我们又跳回了34行函数返回的地方

39
00:02:42,159 --> 00:02:48,830
因为这个对象实在栈上创建的，所以当作用域结束时它会被自动销毁，就是这里的这个。

40
00:02:48,960 --> 00:02:55,300
因此，如果我再按F10，你可以看到控制台打印出了”Destroyed Entity“，因为析构函数被调用了

41
00:02:55,379 --> 00:02:58,509
然后回到了函数的返回地址，没啥问题。

42
00:02:58,509 --> 00:03:00,169
所以本质上来说析构函数就是

43
00:03:00,169 --> 00:03:04,889
就是一个在对象销毁时会被调用的特殊的函数和方法

44
00:03:04,889 --> 00:03:08,770
在实际的工作中我们为什么要写析构函数呢？

45
00:03:08,770 --> 00:03:13,270
那就是如果你在构造函数中做了一些初始化工作

46
00:03:13,270 --> 00:03:17,819
你可能会想要在析构函数里进行释放或者销毁工作

47
00:03:17,819 --> 00:03:19,490
如果不这么做的话，就可能会造成内存泄露

48
00:03:19,490 --> 00:03:21,650
一个很好的例子就是堆分配对象

49
00:03:21,650 --> 00:03:26,909
如果你手动在堆上分配了任何类型的内存空间，那么你也要手动地进行清除。

50
00:03:26,939 --> 00:03:33,750
如果在使用Entity或者在Entity的构造函数中进行的分配，那么你就要在析构函数中清除它们。

51
00:03:33,750 --> 00:03:37,800
因为析构函数调用后，那个Entity对象就不存在了

52
00:03:37,800 --> 00:03:44,389
你也可以手动调用析构函数，我见过很多人这么做

53
00:03:44,389 --> 00:03:46,800
如果你真的这样做了，那就有点奇怪。

54
00:03:47,189 --> 00:03:50,930
因为我能想到的唯一这样做的原因就是你使用new来进行内存分配

55
00:03:50,930 --> 00:03:54,900
当你删除它时，你打算用free函数之类的东西

56
00:03:54,900 --> 00:03:58,189
然后呢你还要手动调用析构函数

57
00:03:58,189 --> 00:04:00,189
我不知道，我很少这样用

58
00:04:00,189 --> 00:04:08,530
但是你还是可以像调用其他函数一样使用 ”e.~Entity()“来调用析构函数

59
00:04:08,810 --> 00:04:14,539
如果我们运行代码，你可以看到打印了 ”Destroyed Entity“ 两次

60
00:04:14,539 --> 00:04:19,000
在这里我们实际上并没有释放任何资源，只是打印了两次消息，所以程序没有崩溃。

61
00:04:19,300 --> 00:04:25,930
同样的我一点也不推荐这样写，我也很少看到别人这么写。

62
00:04:25,970 --> 00:04:30,259
好了，析构函数说完了，下次见，Goodbye！

