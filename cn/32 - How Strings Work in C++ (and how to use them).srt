1
00:00:00,000 --> 00:00:03,480
Hey 大家好，我是 Cherno，欢迎回到我的 C++ 系列

2
00:00:03,660 --> 00:00:06,674
今天我们要学习C++中的字符串

3
00:00:06,674 --> 00:00:09,240
有两个视频你应该先看看，如果你还没看的话

4
00:00:09,240 --> 00:00:17,010
是关于指针(p16)和上周或者前两天关于数组的(p31)的视频

5
00:00:17,010 --> 00:00:22,000
因为你会发现字符串和数组关系是很紧密的

6
00:00:22,000 --> 00:00:27,300
首先，字符串是什么？ 本质上来说字符串就是一组字符

7
00:00:27,300 --> 00:00:32,725
字符(character)是指字母，数字和符号这些东西 本质上就是文本

8
00:00:32,725 --> 00:00:41,280
对我们来说，当然会需要把用某种方式把它们的形状和格式在电脑上表示出来

9
00:00:41,280 --> 00:00:53,399
问题就来了，当我编程时我想要展示文本或者一组文本，它可能是一个单一字符
也可能是整个段落，可能只是一个单词，也可能是一堆单词

10
00:00:53,524 --> 00:00:56,600
所有这些都被称作字符串，文本字符串(string of text)

11
00:00:56,600 --> 00:01:03,520
所以我们需要用某种方法让它们能在程序里表现出来，这就是C++的字符串

12
00:01:03,520 --> 00:01:08,549
对我们来说就是一种能够表示和处理文本的方法

13
00:01:08,549 --> 00:01:11,700
你想要弄明白字符串是怎样工作的，这也是我接下来要讨论的内容

14
00:01:11,700 --> 00:01:19,510
我是说在这个C++系列中，你们知道的
我喜欢深入探讨并和你们分享事情的工作原理

15
00:01:19,510 --> 00:01:25,170
因为就个人而言，当我学习新东西时，我非常喜欢去弄明白它的工作原理

16
00:01:25,170 --> 00:01:33,049
这能帮助我理解怎样去使用它，因为如果你只是告诉我遇到字符串是应该怎么做

17
00:01:33,257 --> 00:01:34,799
cool，我知道字符串是什么

18
00:01:34,799 --> 00:01:39,299
但是在将来当我遇到什么，我没法确定它是否能起作用

19
00:01:39,299 --> 00:01:44,299
如果我知道底层技术的工作原理，我就可以做出有根据的猜测

20
00:01:44,531 --> 00:01:48,750
然后确定我正在尝试做的事情是否一开始就是行不通的

21
00:01:48,967 --> 00:01:56,500
为了理解C++中字符串的工作原理
你先要理解字符是怎样工作的，还有字符实际上是什么

22
00:01:56,875 --> 00:02:01,825
字符就像是字母，符号和数字以不同的形式展示出来

23
00:02:02,042 --> 00:02:09,675
这不是一个关于世界上不同类型字符编码系统的视频教程

24
00:02:09,845 --> 00:02:19,050
因为(编码规范)有很多,而且还都很复杂，还取决于规范实际上是什么

25
00:02:19,250 --> 00:02:22,750
所以我们可能会在以后的视频中去深入讲解

26
00:02:22,966 --> 00:02:25,199
但是现在我们要讨论的是字符是怎样工作的

27
00:02:25,479 --> 00:02:30,074
你可能已经注意到了，C++中有一种数据类型叫char,它是character的缩写

28
00:02:30,232 --> 00:02:33,900
我们之前有用过它，它占用一个字节的内存

29
00:02:35,224 --> 00:02:40,900
它很有用，因为能把指针转换为char类型指针，让你可以根据字节进行指针运算

30
00:02:41,093 --> 00:02:49,474
它对分配内存缓冲区也很有用，如果你想分配1k的内存，
你可以分配1024个char就好了

31
00:02:49,920 --> 00:02:58,349
它对字符串和文本也很有用，因为C++默认处理的字符方式就是ASCII字符

32
00:02:58,649 --> 00:03:01,000
这个视频中我们先不说文本编码

33
00:03:01,363 --> 00:03:08,250
但是我们在C++中处理字符的方式是字符占一个字节，这就是ASCII

34
00:03:08,459 --> 00:03:15,025
ASCII可以扩展为很多，比如说utf-8 utf-16 utf-32,我们还有宽字符(wide string)

35
00:03:15,488 --> 00:03:27,650
当然字符其实是可以大于一个字节的，在其他语言中(比如日文，中文)我们有两个字节，三个，四个字节的字符

36
00:03:28,287 --> 00:03:30,800
有一些和我们在英文中不同的字符

37
00:03:30,966 --> 00:03:34,025
我们需要使用它们，就要有足够多的编码

38
00:03:34,188 --> 00:03:43,224
如果我们只用1字节来表示字符，1字节就是8bit，这意味着我们有2的8次方也就是256种可能

39
00:03:43,474 --> 00:03:56,040
如果把英文字母，数字，符号，日文字幕，韩文等这些放在一起肯定要远远多于256

40
00:03:56,040 --> 00:04:01,150
这样8bit就不够用了，我们没办法适配所有的语言

41
00:04:01,150 --> 00:04:11,275
所以我们有了utf-16，就是16位的字符编码，这意味着我们有2的16次方中可能性，就是65536

42
00:04:11,699 --> 00:04:19,800
我们还有其他中编码，但是在C++基础语言中不使用任何库只是原始数据类型的话，char是1字节

43
00:04:19,968 --> 00:04:30,699
当你在C++中使用一个字符串
就是普通字符串普通的字符而不是2字节的宽字符

44
00:04:30,725 --> 00:04:35,050
我们说的就是一个字节的字符，就是我们日常说的英语

45
00:04:35,050 --> 00:04:39,800
如果你要使用其他语言，比如俄语，那就没法使用这个(1字节字符)

46
00:04:39,912 --> 00:04:44,912
你必须要用其他的字符编码，这些我们可以在以后讨论

47
00:04:45,012 --> 00:04:47,324
但是讨论字符串是很有趣的

48
00:04:47,532 --> 00:04:52,725
因为字符串和文本这些东西以后可能会用在游戏引擎字体渲染

49
00:04:52,921 --> 00:04:57,425
实际上这是一个大多数人会忽视的非常复杂的问题

50
00:04:57,655 --> 00:05:02,655
其实文本和语言是一个非常复杂的问题

51
00:05:02,759 --> 00:05:06,699
好了，先介绍到这里，让我们来讨论下字符串在C++总到底是怎样工作的

52
00:05:06,935 --> 00:05:11,925
我之前说过，字符就是char数据类型的，字符串基本上就是字符组成的数组

53
00:05:11,925 --> 00:05:16,399
这就是为什么我让你们去看那个数组视频(p31)

54
00:05:16,728 --> 00:05:19,625
字符串就是字符数组，而数组就是一类元素的集合

55
00:05:19,706 --> 00:05:23,625
一组字符的集合就组成了字符串或文本

56
00:05:23,830 --> 00:05:27,925
你可能注意到，在这个系列中，我们经常用const char*指代字符串

57
00:05:27,925 --> 00:05:29,524
让我们来看看它是如何工作的

58
00:05:29,747 --> 00:05:34,324
我们可以用const char* 来声明一个C风格的字符串

59
00:05:34,528 --> 00:05:40,800
命名为name，然后让它等于双引号中的某些文本，所以我们设为“Cherno”

60
00:05:41,033 --> 00:05:43,800
这是C语言风格定义字符串的方式

61
00:05:43,800 --> 00:05:50,824
因为在C++中有个库(string库), 可以让我们操作字符串变得很简单

62
00:05:50,824 --> 00:05:54,300
但是即使你知道了C++中的字符串，了解这个(const char*)的工作还是很重要的

63
00:05:54,396 --> 00:05:56,875
其实你不需要把它声明为const  char
(C++11开始这种声明必须加上const)

64
00:05:57,050 --> 00:06:02,250
但是人们通常都会这么做，因为你不会去改变这个值

65
00:06:02,502 --> 00:06:07,725
字符串是不可变的，就是说你不能扩展一个字符串让它变得更长

66
00:06:07,933 --> 00:06:10,975
因为这是一个固定分配的内存块

67
00:06:11,125 --> 00:06:15,850
如果你想要一个更长的字符串
那你就要去分配一个全新的内存并删除旧的字符串

68
00:06:16,350 --> 00:06:20,800
因为这个的char*不是在堆上分配的

69
00:06:20,800 --> 00:06:25,899
你不能调用delete来删除它，也不能用delete[]之类的

70
00:06:26,087 --> 00:06:30,574
我们还没讲new和delete和堆分配，栈分配这些东西

71
00:06:30,837 --> 00:06:33,425
很快就要讲到了，我知道得好好讲讲这些东西

72
00:06:33,668 --> 00:06:38,668
但经验法则是，如果你不用new关键字，那就不要用delete

73
00:06:38,796 --> 00:06:43,796
在这里我们创建了这个“Cherno”字符串，我们没写new char之类的

74
00:06:43,878 --> 00:06:46,274
只是写了“Cherno”，所以也不需要delete

75
00:06:46,477 --> 00:06:49,649
如果你声明成了const，也就是你不能改变它的内容

76
00:06:49,750 --> 00:06:52,125
我们在以后还会有一个关于const的视频

77
00:06:52,373 --> 00:06:57,524
但是你不能改变它，比如这里的第三个字符，e改成a

78
00:06:57,681 --> 00:07:00,699
你不能这么做，因为它是const的

79
00:07:00,934 --> 00:07:05,125
如果你知道不会去修改这个字符串就加上const, 否则就去掉

80
00:07:05,125 --> 00:07:10,125
好了，下一个问题很酷，就是一个字符串在内存中是什么样子的？

81
00:07:10,125 --> 00:07:11,425
它到底是怎么工作的？

82
00:07:11,550 --> 00:07:16,550
在这里设置断点，按F5运行程序，然后就可以看看name的内存情况

83
00:07:16,550 --> 00:07:21,550
如果我打开内存视图，输入name，name就是指针，回车

84
00:07:21,800 --> 00:07:27,800
你可以看到我们在这里有一堆的内存，如果你看后面，有个单词Cherno在这里

85
00:07:27,936 --> 00:07:35,125
所以内存视图的这边是(”Cherno“的)ASCII编码表示，他们都是单独的字节

86
00:07:35,125 --> 00:07:38,899
这就你把它转换成ASCII的字节的样子

87
00:07:39,167 --> 00:07:42,250
你可以查看一个网站，asciitable.com

88
00:07:42,399 --> 00:07:45,800
上面有一个表格，上面有ASCII编码实际对应的字符

89
00:07:45,800 --> 00:07:52,300
在我们这里有43，它是16进制的数字，如果我们看16进制对应的列找到43

90
00:07:52,507 --> 00:07:56,649
你可以看到它对应大写的字母C，也就是你在这里看到的

91
00:07:56,872 --> 00:08:02,925
就是"Cherno"的第一个字母，还有剩下其他的字母
这就是调试可以帮助我们的地方

92
00:08:03,157 --> 00:08:10,074
你可以看到这6个字符组成了Cherno这个单词
然后我们还可以看到一个设置为0的字符

93
00:08:10,338 --> 00:08:12,250
这被称为空终止符(the null termination character)

94
00:08:12,412 --> 00:08:15,524
这样我们就知道字符串在哪里结束

95
00:08:15,699 --> 00:08:20,934
你会注意到我们不知道“Cherno”有多大， 它是一个指针，对吧？

96
00:08:21,206 --> 00:08:25,324
那么我们怎么找出他的大小呢？这就是能用到空终止符的地方了

97
00:08:25,675 --> 00:08:31,100
字符串从指针的内存地址开始，直到0结束

98
00:08:31,345 --> 00:08:38,250
当我们把它打印到控制台，我们可以写cout << name << endl;

99
00:08:38,549 --> 00:08:41,325
如果我重新运行代码，你可以看到控制台打印出了Cherno

100
00:08:41,333 --> 00:08:43,575
它只是一个至针，那它是怎么知道在哪里结束呢

101
00:08:43,755 --> 00:08:48,000
当它跑到0，然后就会意识到这是我字符串结尾的空终止符

102
00:08:48,168 --> 00:08:54,850
如果你要自己去声明，比如我创建另一个名为name2的字符串

103
00:08:55,075 --> 00:09:02,825
我要完全手动操作，我要新建一个char数组，有6个字符，我要在这里把它初始化

104
00:09:03,133 --> 00:09:04,674
把它设置为单个字符

105
00:09:04,808 --> 00:09:12,575
C++中的字符是用单引号，不是双引号，双引号默认是char指针

106
00:09:12,757 --> 00:09:16,049
不是字符串，而是char指针, 但是很快就会变成字符串

107
00:09:16,300 --> 00:09:19,424
C h e r n o ...

108
00:09:19,720 --> 00:09:23,500
这是一个数组，而不是字符串，就是一个包含6个字符的数组

109
00:09:23,500 --> 00:09:25,524
你可以看到在这里没有空终止符

110
00:09:25,696 --> 00:09:30,696
所以如果我试着把name2打印到控制台，我们也可以看下他的内存

111
00:09:30,750 --> 00:09:36,125
打印到控制台，你可以看到Cherno，然后还有一大堆随机字符

112
00:09:36,381 --> 00:09:41,381
这是内存中name2的ascii码形式

113
00:09:41,395 --> 00:09:43,975
回到内存视图，输入name2

114
00:09:43,975 --> 00:09:48,975
你可以看到Cherno,然后是一堆奇怪的字符

115
00:09:49,062 --> 00:09:52,625
你可以看到内存被设置为cc,这实际上是内存守卫

116
00:09:52,824 --> 00:09:55,500
为了让我们知道这些内存是在我们的数组外面的

117
00:09:55,709 --> 00:10:04,325
当我们在调试模式下分配数组内存，C或C++标准库会插入栈守卫之类的东西

118
00:10:04,595 --> 00:10:09,075
这样我们就知道是不是在分配的内存外面了

119
00:10:09,328 --> 00:10:11,125
这就是另一个视频的内容了

120
00:10:11,274 --> 00:10:16,274
因为这儿没有0，所以cout就不知道打印到哪里就结束

121
00:10:16,465 --> 00:10:18,500
这就是为什么我们打印出了这些随机字符

122
00:10:18,708 --> 00:10:26,850
但是如果我们扩展数组，添加0或者'\0',也就是实际的ASCII字符

123
00:10:27,079 --> 00:10:31,174
如果回去看ASCII表，你就可以看到它实际上就是null

124
00:10:31,549 --> 00:10:33,399
你怎样声明一个null呢？写下'\0'就好了

125
00:10:33,399 --> 00:10:36,299
这里有一个错误，因为我们现在已经有7个字符了，对吧！

126
00:10:36,299 --> 00:10:41,549
或者你直接写0也可以，因为这就是他的实际值

127
00:10:41,965 --> 00:10:45,774
按F5，你可以看到现在正确打印“Cherno”，没有了随机字符

128
00:10:45,979 --> 00:10:49,350
这就是字符数组的工作原理，这也是字符串的基本工作原理

129
00:10:49,350 --> 00:10:52,200
这就是字符串，字符串就是字符的集合

130
00:10:52,200 --> 00:10:58,375
我认为我讲的已经很深入了，如果你对字符串的工作原理还有什么问题

131
00:10:58,500 --> 00:11:03,500
可以在下面留言，我会尽可能的回答，我认为我已经说得很详细了 :)

132
00:11:03,875 --> 00:11:08,500
ok C++怎么处理这些，我们在C++中应该怎样使用字符串

133
00:11:08,750 --> 00:11:15,674
C++标准库里有个类叫string, 实际上还有一个模板类basic_string

134
00:11:15,916 --> 00:11:24,774
std::string 本质上就是这个basic_string的char作为模板参数的模板类实例

135
00:11:24,958 --> 00:11:28,149
这叫模板特化(template specialization)

136
00:11:28,991 --> 00:11:37,125
就是把char作为模板类basic_string的模板参数，意味着char就是每个字符背后的的数据类型

137
00:11:37,358 --> 00:11:38,625
这才是你真正应该使用的

138
00:11:38,833 --> 00:11:41,149
有个东西叫wstring，也就是 wide string

139
00:11:41,149 --> 00:11:43,250
我们还是先不讨论这个，还是保持内容简洁

140
00:11:43,470 --> 00:11:46,975
在C++中使用字符串时你应该使用std::string

141
00:11:46,975 --> 00:11:48,475
std::string实际是怎么工作的？

142
00:11:48,732 --> 00:11:54,325
本质上它就是一个char数组，一个char的数组和一些内置函数

143
00:11:54,544 --> 00:11:59,899
在这个系列的后面，当我们开始讲数据结构的时候，我们会去写自己的数据结构

144
00:12:00,123 --> 00:12:07,200
你在C++模板库里看到的所有的C++数据结构，我们都要动手去实现自己的版本

145
00:12:07,416 --> 00:12:12,416
看看她们是如何工作的，以及怎样去优化它们，所以坚持看下去

146
00:12:12,625 --> 00:12:17,625
但现在它只是一个char指针,本质上就是一个字符数组和一些内置函数

147
00:12:17,625 --> 00:12:18,924
让我们来谈谈怎样使用std::string

148
00:12:19,127 --> 00:12:23,625
ok,回到程序中，使用std::string更改当前的代码

149
00:12:23,856 --> 00:12:28,450
首先就是要 include <string>, iostream里实际上已经有了string的定义

150
00:12:28,683 --> 00:12:33,683
但是如果我们想要打印到控制台，你马上会发现需要包含string头文件

151
00:12:34,167 --> 00:12:38,649
把char*改为std::string,就是这样，好了。

152
00:12:38,926 --> 00:12:44,000
string有个接受参数为char指针或者const char指针 的构造函数

153
00:12:44,000 --> 00:12:47,799
如果你把鼠标放在这个上面，你会发现它实际上是一个const char 数组而不是char数组

154
00:12:48,015 --> 00:12:50,799
这个之前在讲const char*时我忘记说到了

155
00:12:51,006 --> 00:12:55,325
这就是为什么通常给他赋值为const char*而不是char*

156
00:12:55,511 --> 00:13:02,125
因为当你在C++中用双引号来定义字符串一个或者多个单词时

157
00:13:02,125 --> 00:13:04,975
它其实就是const char 数组，而不是char数组

158
00:13:05,202 --> 00:13:10,202
当时当你需要操作字符串的内容时转换为char*是没问题的

159
00:13:10,291 --> 00:13:11,399
再次打印

160
00:13:11,562 --> 00:13:12,875
我们也可以叫它name

161
00:13:13,074 --> 00:13:16,174
你可以看到这样比const char*的写法干净多了

162
00:13:16,174 --> 00:13:18,524
如果按F5，你可以看到结果一样

163
00:13:18,736 --> 00:13:22,850
如果我没有包含string头文件只有iostream

164
00:13:23,015 --> 00:13:24,600
你会看到有一个报错

165
00:13:24,750 --> 00:13:30,075
输出流操作符告诉我们不可以把字符串发送到cout输出流中

166
00:13:30,269 --> 00:13:37,375
因为在string头文件中这个操作符的被重载
实现了允许我们把字符串传入输出流

167
00:13:37,663 --> 00:13:42,350
这就是为什么尽管iostream中已经有了string的定义我还要include string头文件

168
00:13:42,625 --> 00:13:47,625
当然因为这是一个有很多功能的类，实际上我们有很多方法

169
00:13:47,750 --> 00:13:51,200
比如使用name.size()可以得到它的大小

170
00:13:51,387 --> 00:13:56,387
如果我们有个const char*或者char*，就必须要用C函数

171
00:13:56,638 --> 00:14:02,299
比如strlen()也就是字符串的长度，strcpy是复制字符串

172
00:14:02,523 --> 00:14:07,523
所有这些和定义在string类中的这些方法让它很可爱

173
00:14:07,523 --> 00:14:08,825
这就是我们使用字符串的方式

174
00:14:08,990 --> 00:14:12,450
我知道你发现自己常做的一件事就是追加字符串

175
00:14:12,652 --> 00:14:18,100
我想要"Cherno"加上" hello!"或者其他什么 这可能就会报错

176
00:14:18,336 --> 00:14:22,450
原因就是你在尝试将两个const char数组相加

177
00:14:22,475 --> 00:14:30,424
对吧？双引号里包含的内容是const char数组，它不是真正的string

178
00:14:30,684 --> 00:14:35,684
它不是字符串，你不能将两个指针或者两个数组加在一起，它不是这么工作的

179
00:14:35,774 --> 00:14:46,325
所以如果你想这么做，要么就是把它们分成多行，然后name+= " hello!"

180
00:14:46,375 --> 00:14:52,024
你这样做是在将一个指针加到了字符串name上了

181
00:14:52,600 --> 00:14:57,075
然后 += 这个操作符在string类中被重载了，所以可以支持你这么操作

182
00:14:57,075 --> 00:15:03,850
或者我经常做的是显式地调用string构造函数将其中一个传入string构造函数中

183
00:15:04,008 --> 00:15:09,008
相当于你在创建一个字符串，然后附加这个给他，这很好

184
00:15:09,174 --> 00:15:14,625
这样做你会得到更多的拷贝，但是大多数情况下这没问题

185
00:15:14,850 --> 00:15:20,024
如果你想查找字符串中的文本，可以使用name.find()，然后传入你要查找的文本

186
00:15:20,268 --> 00:15:23,950
比如所我想在“Cherno hello!”中查找 "no"

187
00:15:24,155 --> 00:15:33,600
可以写如果这个 != std::string::opos 这是一个非法位置

188
00:15:34,028 --> 00:15:42,325
然后 bool contains,因为name.find返回的是这个文本的位置

189
00:15:42,503 --> 00:15:48,424
在这里它会返回这个的起始位置
所以如果你想去看看它是否包含一些内容，就是用这个

190
00:15:48,500 --> 00:15:50,850
因为在string类中没有contains函数

191
00:15:50,850 --> 00:15:53,875
不管怎样，我可以继续向你介绍所有的string API

192
00:15:54,149 --> 00:15:59,149
我在下面的视频描述里放了一个C++字符串的参考链接

193
00:15:59,250 --> 00:16:03,700
如果你想查看所有API,可以看看这个链接

194
00:16:03,875 --> 00:16:05,625
这就是字符串，很容易使用

195
00:16:05,851 --> 00:16:10,851
我们会在以后或者其他系列经常使用到他们，(另一个系列)可能会很快就开始了 :)

196
00:16:13,200 --> 00:16:17,399
另外我想快速提一下的是，把这些字符串传给其他函数

197
00:16:18,024 --> 00:16:22,750
如果我写一个叫PrintString的函数，我想能给它传一个字符串

198
00:16:22,750 --> 00:16:26,325
我不会只写std::string string

199
00:16:26,325 --> 00:16:29,174
然后 cout << string << endl;

200
00:16:29,174 --> 00:16:32,549
我不会这样做，是因为这实际上是一个拷贝

201
00:16:32,549 --> 00:16:34,174
我们之前没有太多地讨论这个问题

202
00:16:34,411 --> 00:16:39,075
但是当你像这样把类对象传入一个函数是

203
00:16:39,263 --> 00:16:46,174
你实际上在做的是创建了这个对象的一个拷贝然后传给这个函数

204
00:16:46,395 --> 00:16:56,325
所以如果我想这样做 string += "h"，这不会影响到这里传入的原始字符串

205
00:16:56,725 --> 00:17:03,049
这很明显是一个只读函数 我们不会修改任何东西，只是想把它打印出来

206
00:17:03,348 --> 00:17:04,625
所以我们为什么要去复制整个字符串呢

207
00:17:04,835 --> 00:17:12,299
复制字符串意味着我们必须在堆上动态地在创建全新的char数组
来存储我们之前已经得到的完全相同的文本

208
00:17:12,299 --> 00:17:16,714
这可不快，复制字符串实际上很慢

209
00:17:16,900 --> 00:17:21,900
在某些情况下这是主要的短板，因为字符串操作是很常见的

210
00:17:22,653 --> 00:17:27,653
所以任何时候像这样传入一个只读字符串时，确保通过常量引用传递它

211
00:17:27,873 --> 00:17:31,825
okay? 我们在这里前面加上const和引用&

212
00:17:32,044 --> 00:17:36,325
&告诉我们是一个引用，意味着它不会被复制

213
00:17:36,523 --> 00:17:39,549
const意味着我们承诺在这里不会修改它

214
00:17:39,799 --> 00:17:44,799
我说承诺是因为技术上来说如果我们想的话我们可以覆盖数据

215
00:17:44,799 --> 00:17:46,924
但是我们承诺不会这么做

216
00:17:47,181 --> 00:17:51,375
以后我会有一个关于const引用的更深入的视频

217
00:17:51,525 --> 00:17:55,049
因为有很多关于这个的内容还有一些技巧可以讲一下

218
00:17:55,271 --> 00:17:57,400
这些基本上就是字符串的内容

219
00:17:57,647 --> 00:18:00,200
如果你们喜欢这个视频，请点赞

220
00:18:00,396 --> 00:18:06,625
...

