1
00:00:01,100 --> 00:00:06,900
Hey 大家好 我是Cherno！欢迎回到我的C++系列 我们今天来聊聊引用（reference）

2
00:00:06,900 --> 00:00:12,599
上周我们聊了指针，如果你没有看那期视频那你一定要去看

3
00:00:12,599 --> 00:00:16,300
因为事实上引用（reference）只是指针的一个扩展

4
00:00:16,300 --> 00:00:23,399
所以你要想听懂引用的内容 最少需要先去了解指针是如何工作的

5
00:00:23,399 --> 00:00:28,399
所以如果你还没看就快去看把(p16  - POINTERS in C++)

6
00:00:28,500 --> 00:00:33,500
ok，指针和引用是在c++和其他语言中常被提及的两种关键字

7
00:00:33,600 --> 00:00:36,299
它们实际上是一回事

8
00:00:36,320 --> 00:00:43,500
我在这里想说的是，在计算机实际上指针和引用的使用来说，
指针和引用几乎是一回事

9
00:00:43,500 --> 00:00:48,500
当然，我们如何写它们，怎么用它们还是有一些不同的。

10
00:00:48,700 --> 00:00:54,700
但是本质上来看，引用就是指针，他俩就是一回事

11
00:00:54,700 --> 00:01:00,100
引用只是基于指针的一种语法糖，来使得代码更易读易写而已。

12
00:01:00,100 --> 00:01:06,025
顾名思义，引用就是指对现有变量引用的一种方式。

13
00:01:06,125 --> 00:01:07,125
和指针不同

14
00:01:07,200 --> 00:01:13,349
指针中要先创建一个指针变量，然后给他赋值nullptr或者其他等于0的值

15
00:01:13,375 --> 00:01:14,625
引用不能这么做

16
00:01:14,625 --> 00:01:21,650
因为“引用”必须引用一个已存在的变量，引用本身并不是一个新的变量

17
00:01:21,875 --> 00:01:24,200
它们并不真正占用内存

18
00:01:24,200 --> 00:01:28,400
它们也不像你之前用的典型的变量那样存储数据。

19
00:01:28,400 --> 00:01:32,099
因为它只是其他变量的引用。

20
00:01:32,099 --> 00:01:35,924
这期视频我会给大家列举几个例子，但也会尽量简明扼要

21
00:01:36,150 --> 00:01:41,900
因为引用并没有那么复杂，而且学习引用最好的办法就是开始使用他们

22
00:01:41,900 --> 00:01:44,500
而且在这个系列中我一直都会用到它们

23
00:01:44,500 --> 00:01:47,700
然后你就能明白在哪里引用最好

24
00:01:47,700 --> 00:01:50,900
或者至少是了解我所认为的引用最佳的应用场景

25
00:01:50,900 --> 00:01:52,689
不管了，看代码吧

26
00:01:52,690 --> 00:01:57,100
比如说我创建一个整形变量 a 赋值 为5

27
00:01:57,099 --> 00:02:00,799
如果我想创建这个变量的引用，我可以这样写

28
00:02:00,799 --> 00:02:07,150
先是变量类型，紧跟着&符 但要注意&其实是变量声明的一部分

29
00:02:07,325 --> 00:02:17,199
上一期关于指针的视频我们学到，&加在已存在的变量前可以指向它的内存地址

30
00:02:17,199 --> 00:02:22,199
在这不一样，&符号实际上是变量类型的一部分

31
00:02:22,199 --> 00:02:26,930
这里他不是贴着一个已存在的变量，他是变量类型的一部分

32
00:02:26,930 --> 00:02:28,199
记住这个不同点

33
00:02:28,199 --> 00:02:35,879
并不是有&就一定是取地址或一定是引用，具体情况要看这里的上下文

34
00:02:35,879 --> 00:02:38,530
在这里因为他挨着变量类型，所以是引用

35
00:02:38,530 --> 00:02:41,349
我们接着写，给这个引用命名 ref ，让它等于 a 

36
00:02:41,349 --> 00:02:47,069
这就是所有需要做的事，在这儿不用写任何那些奇怪的操作符

37
00:02:47,069 --> 00:02:49,629
就是让它等于一个已存在的变量即可

38
00:02:49,629 --> 00:02:53,300
到现在为止，我们就创建了一个别名（alias）

39
00:02:53,525 --> 00:03:00,344
因为这个ref  "变量" ，加引号意思是它其实不是变量，其实是引用

40
00:03:00,560 --> 00:03:05,129
这个 ref 变量并不真正存在，它只存在在我们的源码里

41
00:03:05,129 --> 00:03:11,199
如果你现在编译这个程序，你不会创建两个变量a和ref，只有a

42
00:03:11,199 --> 00:03:14,250
我们现在能做的，就是把ref当a一样使用。

43
00:03:14,250 --> 00:03:17,069
我们设置ref 等于2 

44
00:03:17,069 --> 00:03:19,719
然后输出 a 的值

45
00:03:19,719 --> 00:03:23,750
运行下，现在你会看到a的值是2了

46
00:03:23,750 --> 00:03:26,050
因为我们刚刚把ref 也就是 a 改成了2

47
00:03:26,050 --> 00:03:31,050
在任何情况下，ref 就是 a，我们只是给 a 创建了一个别名

48
00:03:31,110 --> 00:03:36,699
在这个例子里，我们的引用不是一个指针，编译器没有必要创建一个新的变量

49
00:03:36,699 --> 00:03:42,180
如果你编译程序，到最后a等于2，因为那就是我们做的事

50
00:03:42,289 --> 00:03:47,289
这只是我们在源码里的一种操作，如果我们希望给某个变量一个别名，引用能让写代码更好写一点

51
00:03:47,400 --> 00:03:49,680
现在我们搞点稍微复杂的

52
00:03:49,680 --> 00:03:53,099
假设我们想要一个函数，使得输入的整数递增

53
00:03:53,099 --> 00:03:59,719
如果我们这样写，然后这样写

54
00:03:59,719 --> 00:04:07,180
如果我创建个整形变量a在这里，然后调用这个函数，把a放进去作为参数

55
00:04:07,180 --> 00:04:14,050
这里将要发生的是，由于我们是传值调用（passing by value），你可以看到这里不是指针或者引用

56
00:04:14,050 --> 00:04:17,850
所以调用过程中程序将会拷贝参数值5到这个函数里

57
00:04:17,850 --> 00:04:20,920
直接拷贝，这将会创造一个全新的变量value

58
00:04:20,920 --> 00:04:24,000
就像是这样直接声明并赋值一个变量

59
00:04:24,000 --> 00:04:26,069
这两者是完全一样的

60
00:04:26,069 --> 00:04:34,269
这很好证明，这里我的值输出是5（a没有增加，只是value增加了）

61
00:04:34,269 --> 00:04:39,949
我需要的是引用传递（passing by reference）这个变量来让他递增

62
00:04:39,949 --> 00:04:45,629
因为我真正想做的是影响这个变量a，所以我该怎么做呢？

63
00:04:45,629 --> 00:04:49,899
怎么做才能通过把变量传递进函数来真正改变这个变量的值呢？

64
00:04:49,899 --> 00:04:54,819
上次我们说到指针是内存地址，所以理论上讲

65
00:04:54,819 --> 00:04:57,180
这里我希望你可以把这些知识在大脑里融合一下 因为都这些非常有趣

66
00:04:57,180 --> 00:05:00,899
理论上讲，我们可以做的事是，我们很聪明对吧~

67
00:05:00,899 --> 00:05:07,379
我们可以不传递5这个值进函数里，而是直接传递a这个变量的地址

68
00:05:07,379 --> 00:05:14,069
因为我们可以在函数里找到这个变量地址，看到数字5，然后加以更改

69
00:05:14,069 --> 00:05:18,199
我们可以通过内存地址完成写入，因为我们把内存地址传进了函数

70
00:05:18,199 --> 00:05:19,180
我们来试一下

71
00:05:19,180 --> 00:05:24,449
我将要做的是把函数的形参变为一个指针，就还叫它value吧

72
00:05:24,449 --> 00:05:31,230
在调用函数的时候我会将a的内存地址而不是a本身传递给函数

73
00:05:31,230 --> 00:05:34,199
它现在就是在传递变量的内存地址了

74
00:05:34,199 --> 00:05:41,480
还有一件事，就是要把这里改成逆向引用从而改变地址存储的数值，而不是地址本身

75
00:05:41,480 --> 00:05:46,250
如果只有高亮的部分的话，递增的就是地址本身了对吧~

76
00:05:46,250 --> 00:05:57,649
指针就是地址，实质是一个整数，如果直接在它后面++而不在前面带星号的话，它就会增加内存地址本身而不是实际的数值

77
00:05:57,675 --> 00:06:06,345
现在，由于操作符的优先级，递增符号会优先执行
所以我在这里加一个括号来保证先逆向引用，再递增

78
00:06:06,350 --> 00:06:12,680
因为我不想先增加地址，再解引用；我想先解引用，再递增那个地址的数值

79
00:06:12,730 --> 00:06:17,100
所以如果我编译代码，你能看到结果变成了6 

80
00:06:17,100 --> 00:06:20,819
我们成功地通过引用传递了一个参数进函数中

81
00:06:20,819 --> 00:06:26,350
但是，这个视频是关于引用的，所以如果使用引用的话，我们可以更简单地实现之前我们做的事情

82
00:06:26,350 --> 00:06:30,129
用更少的代码，也不用各种对变量名的装饰

83
00:06:30,129 --> 00:06:32,720
我在这种情况下就会使用引用

84
00:06:32,720 --> 00:06:37,069
我们可以把这里的指针形参改成引用的形式

85
00:06:37,069 --> 00:06:42,069
这样做的好处是，我可以去掉这里的解引用，改回原来的样子

86
00:06:42,069 --> 00:06:45,899
在这里我也不需要传递变量的地址，我只需要传递a

87
00:06:45,899 --> 00:06:50,050
由于它是引用传递，虽然我们实际上重写了代码，但做了完全相同的事情

88
00:06:50,050 --> 00:06:55,050
最终编译之后，他们的结果将是完全相同的

89
00:06:55,050 --> 00:06:57,430
只不过这一次我们的源码看起来更nice了

90
00:06:57,430 --> 00:06:59,350
再说一遍，这是唯一的区别。

91
00:06:59,350 --> 00:07:02,269
我们跑一下程序，你能看到我们得到了6

92
00:07:02,269 --> 00:07:04,769
好了，这就是关于引用的全部了

93
00:07:04,769 --> 00:07:11,519
引用只是指针的一种语法糖，没有任何事情是引用能做但指针不能的

94
00:07:11,519 --> 00:07:15,980
指针很像引用，但是它们更有用也更强大。

95
00:07:15,980 --> 00:07:20,319
但是如果你能学会使用引用的方法，就像我们在这儿做的，那一定要用

96
00:07:20,379 --> 00:07:23,680
因为这会让你的代码变得干净和简单很多，更有可读性

97
00:07:23,680 --> 00:07:28,680
不像指针会让程序很难懂，引用会让源码看起来干净很多

98
00:07:28,730 --> 00:07:34,800
还有一件重要的事就是一旦你声明了一个引用，你就不能更改它所引用的对象

99
00:07:34,800 --> 00:07:40,024
我的的意思是，假如我们有两个变量 a 和 b

100
00:07:40,024 --> 00:07:41,800
b=8; a=5

101
00:07:41,925 --> 00:07:51,449
然后我要声明一个a的引用，然后再把引用改变为b的引用。

102
00:07:51,449 --> 00:07:54,149
我可以这么做吗？答案是不行，你不能这么做

103
00:07:54,225 --> 00:08:00,800
这里你新建了一个对a的引用ref，然后在设置ref=b

104
00:08:01,250 --> 00:08:05,100
这样就会把a被赋值为b的值，也就是8

105
00:08:05,449 --> 00:08:09,850
所以现在a=8， b=8

106
00:08:09,850 --> 00:08:12,550
这就是你最终得到的

107
00:08:12,750 --> 00:08:17,930
当然，这也意味着当你声明一个引用时，你必须将一个实际的变量赋值给它

108
00:08:18,100 --> 00:08:20,230
你不能只声明不赋值

109
00:08:20,300 --> 00:08:23,399
能看到编译器不允许代码通过，需要初始化引用变量

110
00:08:23,399 --> 00:08:27,930
当你声明一个引用时，你必须立刻给它赋值，因为它必须是某物的引用

111
00:08:27,930 --> 00:08:30,500
记住它是引用，不是真的变量

112
00:08:30,839 --> 00:08:38,330
所以在这个例子里，如果我确实想改变ref所指代的是什么该怎么办呢？

113
00:08:38,330 --> 00:08:41,450
当然像我之前提到的，这不是一个真正的变量

114
00:08:41,450 --> 00:08:47,330
我们需要创建一些变量使得它先指向a，然后再让它指向b

115
00:08:47,330 --> 00:08:51,850
其实我一直说指向是希望你能明白我想用指针

116
00:08:51,850 --> 00:08:54,350
所以，把这里改掉，声明一个指针

117
00:08:54,350 --> 00:08:59,580
我们先让它指向a，再让它指向b

118
00:08:59,580 --> 00:09:01,500
我们可以让它像这样切换

119
00:09:01,500 --> 00:09:08,000
因为如果想要改变指针指向的值，我需要首先解引用

120
00:09:08,000 --> 00:09:09,480
然后才能给它赋值

121
00:09:09,480 --> 00:09:15,549
所以在这个例子里，我将要让a等于2，让b等于1

122
00:09:15,799 --> 00:09:21,049
如果我想把两个变量的值都输出出来，应该是2 和 1

123
00:09:21,049 --> 00:09:23,379
可以看到，确实是

124
00:09:23,379 --> 00:09:25,519
好了，这就是我要说的了，很简单的东西

125
00:09:25,519 --> 00:09:32,475
我们会在将来大量的使用引用，以后会一直用到它，就像指针一样

126
00:09:32,674 --> 00:09:36,450
随着这个系列的深入，你会在将来看到更多示例

127
00:09:36,450 --> 00:09:41,024
如果你喜欢，请点赞，你也可以在Twitter和Instagram上关注我

128
00:09:41,412 --> 00:09:46,412
如果你真的非常喜欢这个系列，可以在Patreon上支持我。

