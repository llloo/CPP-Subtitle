1
00:00:00,000 --> 00:00:01,600
Hey 大家好 我是cherno

2
00:00:01,600 --> 00:00:03,774
欢迎来到另一个视频

3
00:00:03,825 --> 00:00:05,730
当我们讨论c++中的函数

4
00:00:05,730 --> 00:00:09,960
“什么？！周中也有视频？我在做梦吗？还是Cherno疯了？”

5
00:00:09,960 --> 00:00:10,800
也许吧

6
00:00:10,800 --> 00:00:14,550
但这不是重点，我只是想对所有喜欢这个系列的人说声谢谢

7
00:00:14,550 --> 00:00:18,059
我真的很高兴你们喜欢这个，因为这真的很有乐趣

8
00:00:18,059 --> 00:00:20,429
如果你想让我知道你对我的视频有多喜欢

9
00:00:20,429 --> 00:00:21,719
你可以在Instagram上关注我

10
00:00:21,719 --> 00:00:22,920
链接在视频描述中

11
00:00:22,920 --> 00:00:24,510
最近我很喜欢摄影

12
00:00:24,510 --> 00:00:25,559
如果你们能关注我，对我来说意义很大

13
00:00:25,559 --> 00:00:32,009
比如说暂停这段视频，先去关注我。不管怎样，回到functions

14
00:00:32,009 --> 00:00:33,630
那么函数到底是什么呢

15
00:00:33,630 --> 00:00:38,850
这些函数基本上是我们编写的代码块，它们被设计用来执行某个特定的任务

16
00:00:38,850 --> 00:00:40,020
当我们讲到class（类）的时候

17
00:00:40,020 --> 00:00:42,179
那些代码块被称为methods（方法）

18
00:00:42,179 --> 00:00:43,380
但是当我说function（函数）时

19
00:00:43,380 --> 00:00:46,619
我是在明确地说某种不属于某个class的东西

20
00:00:46,619 --> 00:00:50,250
对于我们来说，分割函数以防止重复代码是很常见的

21
00:00:50,250 --> 00:00:53,429
我们不希望多次写同一段代码，因为

22
00:00:53,429 --> 00:00:54,179
如果我们这样做了

23
00:00:54,179 --> 00:00:59,520
显然，除了复制和粘贴大量的代码，并最终获得一团糟以外

24
00:00:59,520 --> 00:01:02,369
也意味着，如果我们决定改变一些代码

25
00:01:02,369 --> 00:01:05,969
我们必须在所有粘贴原始代码的地方改变它

26
00:01:05,969 --> 00:01:08,069
这对维护来说将会是一场灾难

27
00:01:08,069 --> 00:01:12,569
所以我们可以做的就是写一个函数来做我们想做的

28
00:01:12,569 --> 00:01:14,489
然后我们可以在代码中多次调用它，

29
00:01:14,489 --> 00:01:15,239
在我们需要的时候。

30
00:01:15,239 --> 00:01:18,150
你可以这么理解函数，有一个输入和一个输出

31
00:01:18,150 --> 00:01:20,069
尽管这并非绝对必要的

32
00:01:20,069 --> 00:01:22,709
我们可以提供特定的参数

33
00:01:22,709 --> 00:01:24,689
然后这个函数可以为我们返回一个值

34
00:01:24,689 --> 00:01:27,750
假设我们想把两个数相乘

35
00:01:27,750 --> 00:01:29,790
我们想要写出一个函数来实现它

36
00:01:29,790 --> 00:01:33,150
我要做的第一件事就是在这里写一个叫返回值（return value)的东西

37
00:01:33,150 --> 00:01:35,730
这是这个函数会返回的类型

38
00:01:35,730 --> 00:01:37,469
因为我们把两个整数相乘

39
00:01:37,469 --> 00:01:37,799
当然

40
00:01:37,799 --> 00:01:39,090
将产生一个整数

41
00:01:39,090 --> 00:01:45,900
所以我们返回值是int，我将给这个函数一个名字，在本例中，叫Multiply，它会接受两个参数

42
00:01:45,900 --> 00:01:48,599
它们是我们想要相乘的数字

43
00:01:48,599 --> 00:01:51,540
我把它们叫做A和B，然后我将给函数一个身体

44
00:01:51,540 --> 00:01:54,599
它所要做的就是返回a*b

45
00:01:54,599 --> 00:01:55,019
 

46
00:01:55,019 --> 00:02:01,560
所以你可以看到我们这里有一个函数，它接受两个参数，都是整数，然后仅仅返回这两个数字的乘积

47
00:02:01,560 --> 00:02:03,810
我们并不一定要提供参数

48
00:02:03,810 --> 00:02:04,500
例如

49
00:02:04,500 --> 00:02:08,699
我可以不提供任何参数，然后返回5乘以8

50
00:02:08,699 --> 00:02:11,610
这仍然是一个返回一个整数的函数

51
00:02:11,610 --> 00:02:13,860
但它只是不取任何参数

52
00:02:13,860 --> 00:02:16,919
我们还可以告诉函数我们不想让它返回任何东西

53
00:02:16,919 --> 00:02:17,939
我们通过写一个void

54
00:02:17,939 --> 00:02:19,710
来作为它的返回类型

55
00:02:19,710 --> 00:02:21,229
void当然代表没东西，所以反过来

56
00:02:21,229 --> 00:02:21,240
 

57
00:02:21,240 --> 00:02:23,569
我们可以做类似于把结果打印到控制台

58
00:02:23,569 --> 00:02:23,580
 

59
00:02:26,520 --> 00:02:28,710
让我们回到原来的例子

60
00:02:28,710 --> 00:02:30,780
我们有int a和int b

61
00:02:30,780 --> 00:02:33,930
我们返回了这两个整数的乘积

62
00:02:33,930 --> 00:02:35,759
那么我们如何调用这个函数呢

63
00:02:35,759 --> 00:02:38,159
嗯，调用一个函数很简单

64
00:02:38,159 --> 00:02:40,680
让我们试着打印乘法的结果

65
00:02:40,680 --> 00:02:46,379
首先，我要声明一个变量来存储这个结果，所以我输入int result = Multiply()

66
00:02:46,379 --> 00:02:48,389
然后我们就用3和2

67
00:02:48,389 --> 00:02:56,969
这样做的结果就是用这两个参数来调用Multiply函数，然后把返回值，也就是a*b的结果

68
00:02:56,969 --> 00:02:58,560
存到这个result整型变量

69
00:02:58,560 --> 00:03:01,259
然后我们可以通过控制台输出这个result

70
00:03:01,259 --> 00:03:03,930
让我们按F5来运行我们的程序，当它build好后

71
00:03:03,930 --> 00:03:05,039
你可以看我们得到了6

72
00:03:05,039 --> 00:03:05,189
这个

73
00:03:05,189 --> 00:03:05,550
显然

74
00:03:05,550 --> 00:03:07,349
是3乘以2的结果

75
00:03:07,349 --> 00:03:08,580
让我们说的更详细

76
00:03:08,580 --> 00:03:13,229
假设我想要做一系列乘法，然后把它们都打印到控制台

77
00:03:13,229 --> 00:03:15,330
如果我在没有函数的情况下做类似的事情

78
00:03:15,330 --> 00:03:16,379
那么它看起来会很乱

79
00:03:16,379 --> 00:03:16,530
所以

80
00:03:16,530 --> 00:03:17,189
例如

81
00:03:17,189 --> 00:03:18,599
我需要重复这段代码

82
00:03:18,599 --> 00:03:21,389
让我们去复制粘贴几次

83
00:03:21,389 --> 00:03:24,419
我把它们叫做result2和result3

84
00:03:24,419 --> 00:03:31,379
我们做8*5，和90*45，如果我运行我的程序，哦

85
00:03:31,379 --> 00:03:32,009
等一下

86
00:03:32,009 --> 00:03:33,509
我为啥得到一样的值

87
00:03:33,509 --> 00:03:33,960
哦看呀

88
00:03:33,960 --> 00:03:35,250
当我复制并粘贴这段代码时

89
00:03:35,250 --> 00:03:37,229
我忘记更改变量了

90
00:03:37,229 --> 00:03:39,120
你可能以为我是偶然犯的这个错误

91
00:03:39,120 --> 00:03:40,259
但实际上我是故意这么做的

92
00:03:40,259 --> 00:03:41,460
用以证明一些东西

93
00:03:41,460 --> 00:03:44,639
这种情况其实经常发生

94
00:03:44,639 --> 00:03:46,409
人们复制和粘贴代码块

95
00:03:46,409 --> 00:03:49,139
然后忘记改变一个小细节

96
00:03:49,139 --> 00:03:57,389
在某些情况下，你可能只是运行你的程序，甚至没有注意到不对，直到在之后某个地方造成错误

97
00:03:57,389 --> 00:04:01,259
然而，如果你为它创建一个函数，这种问题就非常容易解决

98
00:04:01,259 --> 00:04:04,229
让我们通过打印result2和result3来解决它

99
00:04:04,229 --> 00:04:05,219
如果我运行这个

100
00:04:05,219 --> 00:04:06,539
我们会得到正确的结果

101
00:04:06,539 --> 00:04:07,259
很好

102
00:04:07,259 --> 00:04:07,530
然而

103
00:04:07,530 --> 00:04:09,990
你可以看到我实际上是多次调用这个

104
00:04:09,990 --> 00:04:11,879
这有点烦

105
00:04:11,880 --> 00:04:19,500
如果我决定用8乘以5来代替这个乘法函数

106
00:04:19,500 --> 00:04:19,889
看看这个

107
00:04:19,889 --> 00:04:22,230
我必须在每个地方替换它

108
00:04:22,230 --> 00:04:24,569
3*2， 90*45

109
00:04:24,569 --> 00:04:29,519
这。。我不想这么麻烦，所以先做乘法，然后打印结果

110
00:04:29,519 --> 00:04:31,410
让我们来为它写一个函数

111
00:04:31,410 --> 00:04:34,110
返回类型是void，因为它并不会返回什么给我们

112
00:04:34,110 --> 00:04:36,629
它只会执行我们要求它做的事情

113
00:04:36,629 --> 00:04:39,180
我们把它命名为”MultiplyAndLog“

114
00:04:39,180 --> 00:04:41,519
然后让我们看一下我们想要的参数

115
00:04:41,519 --> 00:04:44,910
所以这三段代码之间到底什么变化了？

116
00:04:44,910 --> 00:04:46,740
我们实际相乘的数

117
00:04:46,740 --> 00:04:47,639
仅此而已

118
00:04:47,639 --> 00:04:50,759
所以它们成为了我们函数的参数

119
00:04:50,759 --> 00:04:50,769
 

120
00:04:50,769 --> 00:04:56,009
到底这三段代码什么发生了变化，我们需要指定什么才能让这个函数执行我们想要的操作

121
00:04:56,009 --> 00:04:57,779
让我们写下我们的参数

122
00:04:57,779 --> 00:05:01,350
所以我们会接受两个int，a和b，你可以管它们叫任何东西

123
00:05:01,350 --> 00:05:02,629
但a和b听起来还是合理的

124
00:05:02,629 --> 00:05:02,639
 

125
00:05:02,639 --> 00:05:05,040
我们将把其中一段复制粘贴到这个函数中

126
00:05:05,040 --> 00:05:05,790
这看起来很不错

127
00:05:05,790 --> 00:05:17,220
当然，我将用我们的参数来替换3和2，这样我们就可以使用我们指定的参数来执行该函数里的惩罚运算了，这会导致a*b发生，然后打印结果到控制台

128
00:05:17,220 --> 00:05:17,790
所以现在

129
00:05:17,790 --> 00:05:25,649
我不需要写很多次这些，我只需要简单地调用MultiplyAndLog，并传入参数

130
00:05:25,649 --> 00:05:27,470
所以比如说3和2

131
00:05:27,470 --> 00:05:27,480
 

132
00:05:27,480 --> 00:05:29,519
然后是8和5

133
00:05:31,110 --> 00:05:33,920
然后是90和45

134
00:05:33,920 --> 00:05:33,930
 

135
00:05:35,850 --> 00:05:37,050
仅此而已，看呀

136
00:05:37,050 --> 00:05:38,370
我可以这些代码都删掉

137
00:05:38,370 --> 00:05:40,139
这就是我们最后得到的样子

138
00:05:40,139 --> 00:05:42,060
干净易读的程序

139
00:05:42,060 --> 00:05:44,040
如果我启动我的程序

140
00:05:44,040 --> 00:05:46,649
你可以看到我们得到了正确的值

141
00:05:46,649 --> 00:05:48,120
这是一个很简单的例子

142
00:05:48,120 --> 00:05:51,449
但我认为它很有效地证明了函数是非常重要的

143
00:05:51,449 --> 00:05:54,810
你的目标应该是把你的代码拆分成许多许多函数

144
00:05:54,810 --> 00:05:55,110
然而

145
00:05:55,110 --> 00:05:57,329
我想强调的一点是，不要太过分

146
00:05:57,329 --> 00:06:02,759
你不需要给每一行代码都准备一个函数，这对任何人都没有好处

147
00:06:02,759 --> 00:06:06,269
那样很难维护、你的代码看起来会很混乱很拥挤、

148
00:06:06,269 --> 00:06:10,649
而且那样其实会让你的代码更慢。我们每次调用函数时（用星号强调，后面会提到）

149
00:06:10,649 --> 00:06:12,689
编译器会生成一个调用指令

150
00:06:12,689 --> 00:06:16,019
这基本上意味着，在一个运行的程序中

151
00:06:16,019 --> 00:06:17,819
为了让我们调用一个函数

152
00:06:17,819 --> 00:06:20,519
我们需要为这个函数创建一整个stack frame（栈框架）

153
00:06:20,519 --> 00:06:23,250
也就是说，我们得把参数之类的东西push（推）到栈上

154
00:06:23,250 --> 00:06:26,040
我们还需要把一个叫做返回地址的东西放到栈上

155
00:06:26,040 --> 00:06:34,500
然后我们其实要跳到我们程序的某个不同部分，以执行我们的函数里的指令，然后我们push的那个返回值

156
00:06:34,500 --> 00:06:37,560
我们需要返回给调用函数之前的地方

157
00:06:37,560 --> 00:06:38,189
所以这整个的

158
00:06:38,189 --> 00:06:41,399
为了执行函数指令而在内存中跳转来跳转去

159
00:06:41,399 --> 00:06:43,019
所有这些都需要时间

160
00:06:43,019 --> 00:06:44,220
所以它减慢了我们的程序

161
00:06:44,220 --> 00:06:44,370
现在

162
00:06:44,370 --> 00:06:51,329
我之前之所以说星号的原因是，因为这都是建立在假设编译器决定保留我们的函数作为一个函数而非内联（inline）它

163
00:06:51,329 --> 00:06:53,970
我们将在以后的视频中深入讨论inlining

164
00:06:53,970 --> 00:06:58,949
我之所以说这么多，是因为不想让你直接为每一行代码创建一个函数

165
00:06:58,949 --> 00:07:00,360
别太夸张了

166
00:07:00,360 --> 00:07:03,569
你需要一点经验来意识到你什么时候需要一个函数

167
00:07:03,569 --> 00:07:04,139
但基本上

168
00:07:04,139 --> 00:07:08,279
如果您看到自己正在多次做一个常见的任务，那么为它创建一个函数

169
00:07:08,279 --> 00:07:08,670
 

170
00:07:08,670 --> 00:07:12,569
函数的主要目的是防止代码重复

171
00:07:12,569 --> 00:07:16,769
我们不希望只是到处复制和粘贴代码

172
00:07:16,769 --> 00:07:16,980
现在

173
00:07:16,980 --> 00:07:18,720
如果我们再回到我们的代码

174
00:07:18,720 --> 00:07:21,930
你可能会注意到这个主函数有点奇怪

175
00:07:21,930 --> 00:07:24,120
它说他的返回值是int

176
00:07:24,120 --> 00:07:24,870
然而

177
00:07:24,870 --> 00:07:27,389
找不到return这个关键字

178
00:07:27,389 --> 00:07:29,879
很明显我没有返回任何东西

179
00:07:29,879 --> 00:07:32,100
如果我指定一个返回类型

180
00:07:32,100 --> 00:07:34,230
我真的需要返回一些东西吗

181
00:07:34,230 --> 00:07:36,899
让我们来试试看，在这个乘法函数中什么也不做

182
00:07:36,899 --> 00:07:38,699
按ctrl F7来编译该文件

183
00:07:38,699 --> 00:07:39,149
看看它

184
00:07:39,149 --> 00:07:41,970
我得到一个错误告诉我Multiply必须返回一个值

185
00:07:41,970 --> 00:07:45,089
因此带有返回类型的函数实际上需要返回值吗？

186
00:07:45,089 --> 00:07:46,410
答案是肯定的

187
00:07:46,410 --> 00:07:47,160
他们需要

188
00:07:47,160 --> 00:07:49,889
主函数实际上是一个特殊的函数

189
00:07:49,889 --> 00:07:55,560
主函数且只有主函数可以不用返回一个值

190
00:07:55,560 --> 00:07:57,329
如果你没有指定返回值

191
00:07:57,329 --> 00:07:59,790
它会自动假设你返回0

192
00:07:59,790 --> 00:08:02,129
所以它和我这样写的是一样的

193
00:08:02,129 --> 00:08:03,990
这只是现代c、c++版本的特点

194
00:08:03,990 --> 00:08:08,399
为了让你的代码更简洁。好玩的是

195
00:08:08,399 --> 00:08:09,569
所有这些必须返回一个值的规定

196
00:08:09,569 --> 00:08:13,139
实际上只适用于调试模式

197
00:08:13,139 --> 00:08:14,850
如果我们在release模式编译

198
00:08:14,850 --> 00:08:16,680
你会发现我们实际上并没有错误

199
00:08:16,680 --> 00:08:21,689
这并不是说我们在这里做的是正确的,因为如果拿那个返回值做其他事

200
00:08:21,689 --> 00:08:23,879
会得到未定义行为

201
00:08:23,879 --> 00:08:26,160
只是编译器并没有对我们大喊而已

202
00:08:26,160 --> 00:08:26,699
然而

203
00:08:26,699 --> 00:08:27,540
在调试模式下

204
00:08:27,540 --> 00:08:29,459
当特定的调试编译标记（flags）被激活时

205
00:08:29,459 --> 00:08:33,990
我们将会得错误，它将帮助我们调试代码

206
00:08:33,990 --> 00:08:39,389
因为在任何时候你都不应该写一个函数，说它会返回什么，但是并没有返回

207
00:08:39,389 --> 00:08:42,299
ok，这是对函数的基本介绍

208
00:08:42,299 --> 00:08:43,740
函数非常有用

209
00:08:43,740 --> 00:08:46,200
我将会在未来写更多函数

210
00:08:46,200 --> 00:08:48,840
每个程序都是由一系列函数组成的

211
00:08:48,840 --> 00:08:50,669
非常重要的东西

212
00:08:50,669 --> 00:08:53,100
如果你不认为你完全理解函数是如何工作的

213
00:08:53,100 --> 00:08:53,730
别担心

214
00:08:53,730 --> 00:08:54,870
因为在整个系列中

215
00:08:54,870 --> 00:08:57,870
我们将会运行很多函数，你将会习惯它

216
00:08:57,870 --> 00:08:58,950
最好的学习方法当然是

217
00:08:58,950 --> 00:08:59,250
 

218
00:08:59,250 --> 00:08:59,970
练习

219
00:08:59,970 --> 00:09:03,629
我们还通常将函数拆分为声明和定义

220
00:09:03,629 --> 00:09:04,409
所以声明

221
00:09:04,409 --> 00:09:07,139
通常会存在头文件，而定义

222
00:09:07,139 --> 00:09:08,429
会写在翻译单元里

223
00:09:08,429 --> 00:09:09,450
或者说cpp文件里

224
00:09:09,450 --> 00:09:12,210
然后我将制作一个专门讲头文件的视频

225
00:09:12,210 --> 00:09:16,259
我们将在那个视频中讲到头文件中到函数声明

226
00:09:16,259 --> 00:09:19,899
无论如何，希望你喜欢这个视频，如果喜欢，请点赞。

227
00:09:19,899 --> 00:09:21,975
别忘了在推特和Ins上关注我

228
00:09:21,975 --> 00:09:25,975
如果你真的非常喜欢这个视频，并且希望能够提前看到以后视频的草稿

229
00:09:25,975 --> 00:09:31,774
和参加对视频内容的讨论，你可以在Patreon上支持我，链接在视频详情...

230
00:09:31,774 --> 00:09:36,774
下次见，Good Bye!

